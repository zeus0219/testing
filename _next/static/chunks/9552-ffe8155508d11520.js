(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [9552],
  {
    28187: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.pbkdf2Async = T.pbkdf2 = void 0);
      let J = L(83008),
        W = L(8692),
        Y = L(8962);
      function Z(O, T, L, Z) {
        (0, J.hash)(O);
        let {
          c: X,
          dkLen: ee,
          asyncTick: et,
        } = (0, Y.checkOpts)({ dkLen: 32, asyncTick: 10 }, Z);
        if (((0, J.number)(X), (0, J.number)(ee), (0, J.number)(et), X < 1))
          throw Error("PBKDF2: iterations (c) should be >= 1");
        let er = (0, Y.toBytes)(T),
          en = (0, Y.toBytes)(L),
          es = new Uint8Array(ee),
          ei = W.hmac.create(O, er),
          ea = ei._cloneInto().update(en);
        return { c: X, dkLen: ee, asyncTick: et, DK: es, PRF: ei, PRFSalt: ea };
      }
      function X(O, T, L, J, W) {
        return O.destroy(), T.destroy(), J && J.destroy(), W.fill(0), L;
      }
      function ee(O, T, L, J) {
        let W;
        let { c: ee, dkLen: et, DK: er, PRF: en, PRFSalt: es } = Z(O, T, L, J),
          ei = new Uint8Array(4),
          ea = (0, Y.createView)(ei),
          eo = new Uint8Array(en.outputLen);
        for (let O = 1, T = 0; T < et; O++, T += en.outputLen) {
          let L = er.subarray(T, T + en.outputLen);
          ea.setInt32(0, O, !1),
            (W = es._cloneInto(W)).update(ei).digestInto(eo),
            L.set(eo.subarray(0, L.length));
          for (let O = 1; O < ee; O++) {
            en._cloneInto(W).update(eo).digestInto(eo);
            for (let O = 0; O < L.length; O++) L[O] ^= eo[O];
          }
        }
        return X(en, es, er, W, eo);
      }
      async function et(O, T, L, J) {
        let W;
        let {
            c: ee,
            dkLen: et,
            asyncTick: er,
            DK: en,
            PRF: es,
            PRFSalt: ei,
          } = Z(O, T, L, J),
          ea = new Uint8Array(4),
          eo = (0, Y.createView)(ea),
          ec = new Uint8Array(es.outputLen);
        for (let O = 1, T = 0; T < et; O++, T += es.outputLen) {
          let L = en.subarray(T, T + es.outputLen);
          eo.setInt32(0, O, !1),
            (W = ei._cloneInto(W)).update(ea).digestInto(ec),
            L.set(ec.subarray(0, L.length)),
            await (0, Y.asyncLoop)(ee - 1, er, () => {
              es._cloneInto(W).update(ec).digestInto(ec);
              for (let O = 0; O < L.length; O++) L[O] ^= ec[O];
            });
        }
        return X(es, ei, en, W, ec);
      }
      (T.pbkdf2 = ee), (T.pbkdf2Async = et);
    },
    43756: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.scryptAsync = T.scrypt = void 0);
      let J = L(83008),
        W = L(93782),
        Y = L(28187),
        Z = L(8962),
        X = (O, T) => (O << T) | (O >>> (32 - T));
      function ee(O, T, L, J, W, Y) {
        let Z = O[T++] ^ L[J++],
          ee = O[T++] ^ L[J++],
          et = O[T++] ^ L[J++],
          er = O[T++] ^ L[J++],
          en = O[T++] ^ L[J++],
          es = O[T++] ^ L[J++],
          ei = O[T++] ^ L[J++],
          ea = O[T++] ^ L[J++],
          eo = O[T++] ^ L[J++],
          ec = O[T++] ^ L[J++],
          eu = O[T++] ^ L[J++],
          eh = O[T++] ^ L[J++],
          ed = O[T++] ^ L[J++],
          ep = O[T++] ^ L[J++],
          eg = O[T++] ^ L[J++],
          ey = O[T++] ^ L[J++],
          em = Z,
          eb = ee,
          eA = et,
          ew = er,
          ev = en,
          ek = es,
          eE = ei,
          eS = ea,
          eP = eo,
          eC = ec,
          eB = eu,
          eO = eh,
          eT = ed,
          eN = ep,
          eR = eg,
          eI = ey;
        for (let O = 0; O < 8; O += 2)
          (ev ^= X((em + eT) | 0, 7)),
            (eP ^= X((ev + em) | 0, 9)),
            (eT ^= X((eP + ev) | 0, 13)),
            (em ^= X((eT + eP) | 0, 18)),
            (eC ^= X((ek + eb) | 0, 7)),
            (eN ^= X((eC + ek) | 0, 9)),
            (eb ^= X((eN + eC) | 0, 13)),
            (ek ^= X((eb + eN) | 0, 18)),
            (eR ^= X((eB + eE) | 0, 7)),
            (eA ^= X((eR + eB) | 0, 9)),
            (eE ^= X((eA + eR) | 0, 13)),
            (eB ^= X((eE + eA) | 0, 18)),
            (ew ^= X((eI + eO) | 0, 7)),
            (eS ^= X((ew + eI) | 0, 9)),
            (eO ^= X((eS + ew) | 0, 13)),
            (eI ^= X((eO + eS) | 0, 18)),
            (eb ^= X((em + ew) | 0, 7)),
            (eA ^= X((eb + em) | 0, 9)),
            (ew ^= X((eA + eb) | 0, 13)),
            (em ^= X((ew + eA) | 0, 18)),
            (eE ^= X((ek + ev) | 0, 7)),
            (eS ^= X((eE + ek) | 0, 9)),
            (ev ^= X((eS + eE) | 0, 13)),
            (ek ^= X((ev + eS) | 0, 18)),
            (eO ^= X((eB + eC) | 0, 7)),
            (eP ^= X((eO + eB) | 0, 9)),
            (eC ^= X((eP + eO) | 0, 13)),
            (eB ^= X((eC + eP) | 0, 18)),
            (eT ^= X((eI + eR) | 0, 7)),
            (eN ^= X((eT + eI) | 0, 9)),
            (eR ^= X((eN + eT) | 0, 13)),
            (eI ^= X((eR + eN) | 0, 18));
        (W[Y++] = (Z + em) | 0),
          (W[Y++] = (ee + eb) | 0),
          (W[Y++] = (et + eA) | 0),
          (W[Y++] = (er + ew) | 0),
          (W[Y++] = (en + ev) | 0),
          (W[Y++] = (es + ek) | 0),
          (W[Y++] = (ei + eE) | 0),
          (W[Y++] = (ea + eS) | 0),
          (W[Y++] = (eo + eP) | 0),
          (W[Y++] = (ec + eC) | 0),
          (W[Y++] = (eu + eB) | 0),
          (W[Y++] = (eh + eO) | 0),
          (W[Y++] = (ed + eT) | 0),
          (W[Y++] = (ep + eN) | 0),
          (W[Y++] = (eg + eR) | 0),
          (W[Y++] = (ey + eI) | 0);
      }
      function et(O, T, L, J, W) {
        let Y = J + 0,
          Z = J + 16 * W;
        for (let J = 0; J < 16; J++) L[Z + J] = O[T + (2 * W - 1) * 16 + J];
        for (let J = 0; J < W; J++, Y += 16, T += 16)
          ee(L, Z, O, T, L, Y),
            J > 0 && (Z += 16),
            ee(L, Y, O, (T += 16), L, Z);
      }
      function er(O, T, L) {
        let {
          N: X,
          r: ee,
          p: et,
          dkLen: er,
          asyncTick: en,
          maxmem: es,
          onProgress: ei,
        } = (0, Z.checkOpts)(
          { dkLen: 32, asyncTick: 10, maxmem: 1073742848 },
          L
        );
        if (
          ((0, J.number)(X),
          (0, J.number)(ee),
          (0, J.number)(et),
          (0, J.number)(er),
          (0, J.number)(en),
          (0, J.number)(es),
          void 0 !== ei && "function" != typeof ei)
        )
          throw Error("progressCb should be function");
        let ea = 128 * ee,
          eo = ea / 4;
        if (
          X <= 1 ||
          (X & (X - 1)) != 0 ||
          X >= 2 ** (ea / 8) ||
          X > 4294967296
        )
          throw Error(
            "Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32"
          );
        if (et < 0 || et > ((4294967296 - 1) * 32) / ea)
          throw Error(
            "Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)"
          );
        if (er < 0 || er > (4294967296 - 1) * 32)
          throw Error(
            "Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32"
          );
        let ec = ea * (X + et);
        if (ec > es)
          throw Error(
            `Scrypt: parameters too large, ${ec} (128 * r * (N + p)) > ${es} (maxmem)`
          );
        let eu = (0, Y.pbkdf2)(W.sha256, O, T, { c: 1, dkLen: ea * et }),
          eh = (0, Z.u32)(eu),
          ed = (0, Z.u32)(new Uint8Array(ea * X)),
          ep = (0, Z.u32)(new Uint8Array(ea)),
          eg = () => {};
        if (ei) {
          let O = 2 * X * et,
            T = Math.max(Math.floor(O / 1e4), 1),
            L = 0;
          eg = () => {
            L++, ei && (!(L % T) || L === O) && ei(L / O);
          };
        }
        return {
          N: X,
          r: ee,
          p: et,
          dkLen: er,
          blockSize32: eo,
          V: ed,
          B32: eh,
          B: eu,
          tmp: ep,
          blockMixCb: eg,
          asyncTick: en,
        };
      }
      function en(O, T, L, J, Z) {
        let X = (0, Y.pbkdf2)(W.sha256, O, L, { c: 1, dkLen: T });
        return L.fill(0), J.fill(0), Z.fill(0), X;
      }
      function es(O, T, L) {
        let {
          N: J,
          r: W,
          p: Y,
          dkLen: Z,
          blockSize32: X,
          V: ee,
          B32: es,
          B: ei,
          tmp: ea,
          blockMixCb: eo,
        } = er(O, T, L);
        for (let O = 0; O < Y; O++) {
          let T = X * O;
          for (let O = 0; O < X; O++) ee[O] = es[T + O];
          for (let O = 0, T = 0; O < J - 1; O++)
            et(ee, T, ee, (T += X), W), eo();
          et(ee, (J - 1) * X, es, T, W), eo();
          for (let O = 0; O < J; O++) {
            let O = es[T + X - 16] % J;
            for (let L = 0; L < X; L++) ea[L] = es[T + L] ^ ee[O * X + L];
            et(ea, 0, es, T, W), eo();
          }
        }
        return en(O, Z, ei, ee, ea);
      }
      async function ei(O, T, L) {
        let {
          N: J,
          r: W,
          p: Y,
          dkLen: X,
          blockSize32: ee,
          V: es,
          B32: ei,
          B: ea,
          tmp: eo,
          blockMixCb: ec,
          asyncTick: eu,
        } = er(O, T, L);
        for (let O = 0; O < Y; O++) {
          let T = ee * O;
          for (let O = 0; O < ee; O++) es[O] = ei[T + O];
          let L = 0;
          await (0, Z.asyncLoop)(J - 1, eu, () => {
            et(es, L, es, (L += ee), W), ec();
          }),
            et(es, (J - 1) * ee, ei, T, W),
            ec(),
            await (0, Z.asyncLoop)(J, eu, () => {
              let O = ei[T + ee - 16] % J;
              for (let L = 0; L < ee; L++) eo[L] = ei[T + L] ^ es[O * ee + L];
              et(eo, 0, ei, T, W), ec();
            });
        }
        return en(O, X, ea, es, eo);
      }
      (T.scrypt = es), (T.scryptAsync = ei);
    },
    60626: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.sha384 = T.sha512_256 = T.sha512_224 = T.sha512 = T.SHA512 = void 0);
      let J = L(26522),
        W = L(11379),
        Y = L(8962),
        [Z, X] = W.default.split(
          [
            "0x428a2f98d728ae22",
            "0x7137449123ef65cd",
            "0xb5c0fbcfec4d3b2f",
            "0xe9b5dba58189dbbc",
            "0x3956c25bf348b538",
            "0x59f111f1b605d019",
            "0x923f82a4af194f9b",
            "0xab1c5ed5da6d8118",
            "0xd807aa98a3030242",
            "0x12835b0145706fbe",
            "0x243185be4ee4b28c",
            "0x550c7dc3d5ffb4e2",
            "0x72be5d74f27b896f",
            "0x80deb1fe3b1696b1",
            "0x9bdc06a725c71235",
            "0xc19bf174cf692694",
            "0xe49b69c19ef14ad2",
            "0xefbe4786384f25e3",
            "0x0fc19dc68b8cd5b5",
            "0x240ca1cc77ac9c65",
            "0x2de92c6f592b0275",
            "0x4a7484aa6ea6e483",
            "0x5cb0a9dcbd41fbd4",
            "0x76f988da831153b5",
            "0x983e5152ee66dfab",
            "0xa831c66d2db43210",
            "0xb00327c898fb213f",
            "0xbf597fc7beef0ee4",
            "0xc6e00bf33da88fc2",
            "0xd5a79147930aa725",
            "0x06ca6351e003826f",
            "0x142929670a0e6e70",
            "0x27b70a8546d22ffc",
            "0x2e1b21385c26c926",
            "0x4d2c6dfc5ac42aed",
            "0x53380d139d95b3df",
            "0x650a73548baf63de",
            "0x766a0abb3c77b2a8",
            "0x81c2c92e47edaee6",
            "0x92722c851482353b",
            "0xa2bfe8a14cf10364",
            "0xa81a664bbc423001",
            "0xc24b8b70d0f89791",
            "0xc76c51a30654be30",
            "0xd192e819d6ef5218",
            "0xd69906245565a910",
            "0xf40e35855771202a",
            "0x106aa07032bbd1b8",
            "0x19a4c116b8d2d0c8",
            "0x1e376c085141ab53",
            "0x2748774cdf8eeb99",
            "0x34b0bcb5e19b48a8",
            "0x391c0cb3c5c95a63",
            "0x4ed8aa4ae3418acb",
            "0x5b9cca4f7763e373",
            "0x682e6ff3d6b2b8a3",
            "0x748f82ee5defb2fc",
            "0x78a5636f43172f60",
            "0x84c87814a1f0ab72",
            "0x8cc702081a6439ec",
            "0x90befffa23631e28",
            "0xa4506cebde82bde9",
            "0xbef9a3f7b2c67915",
            "0xc67178f2e372532b",
            "0xca273eceea26619c",
            "0xd186b8c721c0c207",
            "0xeada7dd6cde0eb1e",
            "0xf57d4f7fee6ed178",
            "0x06f067aa72176fba",
            "0x0a637dc5a2c898a6",
            "0x113f9804bef90dae",
            "0x1b710b35131c471b",
            "0x28db77f523047d84",
            "0x32caab7b40c72493",
            "0x3c9ebe0a15c9bebc",
            "0x431d67c49c100d4c",
            "0x4cc5d4becb3e42b6",
            "0x597f299cfc657e2a",
            "0x5fcb6fab3ad6faec",
            "0x6c44198c4a475817",
          ].map((O) => BigInt(O))
        ),
        ee = new Uint32Array(80),
        et = new Uint32Array(80);
      class er extends J.SHA2 {
        constructor() {
          super(128, 64, 16, !1),
            (this.Ah = 1779033703),
            (this.Al = -205731576),
            (this.Bh = -1150833019),
            (this.Bl = -2067093701),
            (this.Ch = 1013904242),
            (this.Cl = -23791573),
            (this.Dh = -1521486534),
            (this.Dl = 1595750129),
            (this.Eh = 1359893119),
            (this.El = -1377402159),
            (this.Fh = -1694144372),
            (this.Fl = 725511199),
            (this.Gh = 528734635),
            (this.Gl = -79577749),
            (this.Hh = 1541459225),
            (this.Hl = 327033209);
        }
        get() {
          let {
            Ah: O,
            Al: T,
            Bh: L,
            Bl: J,
            Ch: W,
            Cl: Y,
            Dh: Z,
            Dl: X,
            Eh: ee,
            El: et,
            Fh: er,
            Fl: en,
            Gh: es,
            Gl: ei,
            Hh: ea,
            Hl: eo,
          } = this;
          return [O, T, L, J, W, Y, Z, X, ee, et, er, en, es, ei, ea, eo];
        }
        set(O, T, L, J, W, Y, Z, X, ee, et, er, en, es, ei, ea, eo) {
          (this.Ah = 0 | O),
            (this.Al = 0 | T),
            (this.Bh = 0 | L),
            (this.Bl = 0 | J),
            (this.Ch = 0 | W),
            (this.Cl = 0 | Y),
            (this.Dh = 0 | Z),
            (this.Dl = 0 | X),
            (this.Eh = 0 | ee),
            (this.El = 0 | et),
            (this.Fh = 0 | er),
            (this.Fl = 0 | en),
            (this.Gh = 0 | es),
            (this.Gl = 0 | ei),
            (this.Hh = 0 | ea),
            (this.Hl = 0 | eo);
        }
        process(O, T) {
          for (let L = 0; L < 16; L++, T += 4)
            (ee[L] = O.getUint32(T)), (et[L] = O.getUint32((T += 4)));
          for (let O = 16; O < 80; O++) {
            let T = 0 | ee[O - 15],
              L = 0 | et[O - 15],
              J =
                W.default.rotrSH(T, L, 1) ^
                W.default.rotrSH(T, L, 8) ^
                W.default.shrSH(T, L, 7),
              Y =
                W.default.rotrSL(T, L, 1) ^
                W.default.rotrSL(T, L, 8) ^
                W.default.shrSL(T, L, 7),
              Z = 0 | ee[O - 2],
              X = 0 | et[O - 2],
              er =
                W.default.rotrSH(Z, X, 19) ^
                W.default.rotrBH(Z, X, 61) ^
                W.default.shrSH(Z, X, 6),
              en =
                W.default.rotrSL(Z, X, 19) ^
                W.default.rotrBL(Z, X, 61) ^
                W.default.shrSL(Z, X, 6),
              es = W.default.add4L(Y, en, et[O - 7], et[O - 16]),
              ei = W.default.add4H(es, J, er, ee[O - 7], ee[O - 16]);
            (ee[O] = 0 | ei), (et[O] = 0 | es);
          }
          let {
            Ah: L,
            Al: J,
            Bh: Y,
            Bl: er,
            Ch: en,
            Cl: es,
            Dh: ei,
            Dl: ea,
            Eh: eo,
            El: ec,
            Fh: eu,
            Fl: eh,
            Gh: ed,
            Gl: ep,
            Hh: eg,
            Hl: ey,
          } = this;
          for (let O = 0; O < 80; O++) {
            let T =
                W.default.rotrSH(eo, ec, 14) ^
                W.default.rotrSH(eo, ec, 18) ^
                W.default.rotrBH(eo, ec, 41),
              em =
                W.default.rotrSL(eo, ec, 14) ^
                W.default.rotrSL(eo, ec, 18) ^
                W.default.rotrBL(eo, ec, 41),
              eb = (eo & eu) ^ (~eo & ed),
              eA = (ec & eh) ^ (~ec & ep),
              ew = W.default.add5L(ey, em, eA, X[O], et[O]),
              ev = W.default.add5H(ew, eg, T, eb, Z[O], ee[O]),
              ek = 0 | ew,
              eE =
                W.default.rotrSH(L, J, 28) ^
                W.default.rotrBH(L, J, 34) ^
                W.default.rotrBH(L, J, 39),
              eS =
                W.default.rotrSL(L, J, 28) ^
                W.default.rotrBL(L, J, 34) ^
                W.default.rotrBL(L, J, 39),
              eP = (L & Y) ^ (L & en) ^ (Y & en),
              eC = (J & er) ^ (J & es) ^ (er & es);
            (eg = 0 | ed),
              (ey = 0 | ep),
              (ed = 0 | eu),
              (ep = 0 | eh),
              (eu = 0 | eo),
              (eh = 0 | ec),
              ({ h: eo, l: ec } = W.default.add(
                0 | ei,
                0 | ea,
                0 | ev,
                0 | ek
              )),
              (ei = 0 | en),
              (ea = 0 | es),
              (en = 0 | Y),
              (es = 0 | er),
              (Y = 0 | L),
              (er = 0 | J);
            let eB = W.default.add3L(ek, eS, eC);
            (L = W.default.add3H(eB, ev, eE, eP)), (J = 0 | eB);
          }
          ({ h: L, l: J } = W.default.add(
            0 | this.Ah,
            0 | this.Al,
            0 | L,
            0 | J
          )),
            ({ h: Y, l: er } = W.default.add(
              0 | this.Bh,
              0 | this.Bl,
              0 | Y,
              0 | er
            )),
            ({ h: en, l: es } = W.default.add(
              0 | this.Ch,
              0 | this.Cl,
              0 | en,
              0 | es
            )),
            ({ h: ei, l: ea } = W.default.add(
              0 | this.Dh,
              0 | this.Dl,
              0 | ei,
              0 | ea
            )),
            ({ h: eo, l: ec } = W.default.add(
              0 | this.Eh,
              0 | this.El,
              0 | eo,
              0 | ec
            )),
            ({ h: eu, l: eh } = W.default.add(
              0 | this.Fh,
              0 | this.Fl,
              0 | eu,
              0 | eh
            )),
            ({ h: ed, l: ep } = W.default.add(
              0 | this.Gh,
              0 | this.Gl,
              0 | ed,
              0 | ep
            )),
            ({ h: eg, l: ey } = W.default.add(
              0 | this.Hh,
              0 | this.Hl,
              0 | eg,
              0 | ey
            )),
            this.set(
              L,
              J,
              Y,
              er,
              en,
              es,
              ei,
              ea,
              eo,
              ec,
              eu,
              eh,
              ed,
              ep,
              eg,
              ey
            );
        }
        roundClean() {
          ee.fill(0), et.fill(0);
        }
        destroy() {
          this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      T.SHA512 = er;
      class en extends er {
        constructor() {
          super(),
            (this.Ah = -1942145080),
            (this.Al = 424955298),
            (this.Bh = 1944164710),
            (this.Bl = -1982016298),
            (this.Ch = 502970286),
            (this.Cl = 855612546),
            (this.Dh = 1738396948),
            (this.Dl = 1479516111),
            (this.Eh = 258812777),
            (this.El = 2077511080),
            (this.Fh = 2011393907),
            (this.Fl = 79989058),
            (this.Gh = 1067287976),
            (this.Gl = 1780299464),
            (this.Hh = 286451373),
            (this.Hl = -1848208735),
            (this.outputLen = 28);
        }
      }
      class es extends er {
        constructor() {
          super(),
            (this.Ah = 573645204),
            (this.Al = -64227540),
            (this.Bh = -1621794909),
            (this.Bl = -934517566),
            (this.Ch = 596883563),
            (this.Cl = 1867755857),
            (this.Dh = -1774684391),
            (this.Dl = 1497426621),
            (this.Eh = -1775747358),
            (this.El = -1467023389),
            (this.Fh = -1101128155),
            (this.Fl = 1401305490),
            (this.Gh = 721525244),
            (this.Gl = 746961066),
            (this.Hh = 246885852),
            (this.Hl = -2117784414),
            (this.outputLen = 32);
        }
      }
      class ei extends er {
        constructor() {
          super(),
            (this.Ah = -876896931),
            (this.Al = -1056596264),
            (this.Bh = 1654270250),
            (this.Bl = 914150663),
            (this.Ch = -1856437926),
            (this.Cl = 812702999),
            (this.Dh = 355462360),
            (this.Dl = -150054599),
            (this.Eh = 1731405415),
            (this.El = -4191439),
            (this.Fh = -1900787065),
            (this.Fl = 1750603025),
            (this.Gh = -619958771),
            (this.Gl = 1694076839),
            (this.Hh = 1203062813),
            (this.Hl = -1090891868),
            (this.outputLen = 48);
        }
      }
      (T.sha512 = (0, Y.wrapConstructor)(() => new er())),
        (T.sha512_224 = (0, Y.wrapConstructor)(() => new en())),
        (T.sha512_256 = (0, Y.wrapConstructor)(() => new es())),
        (T.sha384 = (0, Y.wrapConstructor)(() => new ei()));
    },
    31953: function (O, T) {
      // "use strict";
      function L(O) {
        if (!Number.isSafeInteger(O) || O < 0)
          throw Error(`positive integer expected, not ${O}`);
      }
      function J(O) {
        if ("boolean" != typeof O) throw Error(`boolean expected, not ${O}`);
      }
      function W(O) {
        return (
          O instanceof Uint8Array ||
          (null != O &&
            "object" == typeof O &&
            "Uint8Array" === O.constructor.name)
        );
      }
      function Y(O, ...T) {
        if (!W(O)) throw Error("Uint8Array expected");
        if (T.length > 0 && !T.includes(O.length))
          throw Error(
            `Uint8Array expected of length ${T}, not of length=${O.length}`
          );
      }
      function Z(O) {
        if ("function" != typeof O || "function" != typeof O.create)
          throw Error("Hash should be wrapped by utils.wrapConstructor");
        L(O.outputLen), L(O.blockLen);
      }
      function X(O, T = !0) {
        if (O.destroyed) throw Error("Hash instance has been destroyed");
        if (T && O.finished)
          throw Error("Hash#digest() has already been called");
      }
      function ee(O, T) {
        Y(O);
        let L = T.outputLen;
        if (O.length < L)
          throw Error(
            `digestInto() expects output buffer of length at least ${L}`
          );
      }
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.output =
          T.exists =
          T.hash =
          T.bytes =
          T.bool =
          T.number =
          T.isBytes =
            void 0),
        (T.number = L),
        (T.bool = J),
        (T.isBytes = W),
        (T.bytes = Y),
        (T.hash = Z),
        (T.exists = X),
        (T.output = ee);
      let et = { number: L, bool: J, bytes: Y, hash: Z, exists: X, output: ee };
      T.default = et;
    },
    47391: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.add5L =
          T.add5H =
          T.add4H =
          T.add4L =
          T.add3H =
          T.add3L =
          T.add =
          T.rotlBL =
          T.rotlBH =
          T.rotlSL =
          T.rotlSH =
          T.rotr32L =
          T.rotr32H =
          T.rotrBL =
          T.rotrBH =
          T.rotrSL =
          T.rotrSH =
          T.shrSL =
          T.shrSH =
          T.toBig =
          T.split =
          T.fromBig =
            void 0);
      let L = BigInt(4294967296 - 1),
        J = BigInt(32);
      function W(O, T = !1) {
        return T
          ? { h: Number(O & L), l: Number((O >> J) & L) }
          : { h: 0 | Number((O >> J) & L), l: 0 | Number(O & L) };
      }
      function Y(O, T = !1) {
        let L = new Uint32Array(O.length),
          J = new Uint32Array(O.length);
        for (let Y = 0; Y < O.length; Y++) {
          let { h: Z, l: X } = W(O[Y], T);
          [L[Y], J[Y]] = [Z, X];
        }
        return [L, J];
      }
      (T.fromBig = W), (T.split = Y);
      let Z = (O, T) => (BigInt(O >>> 0) << J) | BigInt(T >>> 0);
      T.toBig = Z;
      let X = (O, T, L) => O >>> L;
      T.shrSH = X;
      let ee = (O, T, L) => (O << (32 - L)) | (T >>> L);
      T.shrSL = ee;
      let et = (O, T, L) => (O >>> L) | (T << (32 - L));
      T.rotrSH = et;
      let er = (O, T, L) => (O << (32 - L)) | (T >>> L);
      T.rotrSL = er;
      let en = (O, T, L) => (O << (64 - L)) | (T >>> (L - 32));
      T.rotrBH = en;
      let es = (O, T, L) => (O >>> (L - 32)) | (T << (64 - L));
      T.rotrBL = es;
      let ei = (O, T) => T;
      T.rotr32H = ei;
      let ea = (O, T) => O;
      T.rotr32L = ea;
      let eo = (O, T, L) => (O << L) | (T >>> (32 - L));
      T.rotlSH = eo;
      let ec = (O, T, L) => (T << L) | (O >>> (32 - L));
      T.rotlSL = ec;
      let eu = (O, T, L) => (T << (L - 32)) | (O >>> (64 - L));
      T.rotlBH = eu;
      let eh = (O, T, L) => (O << (L - 32)) | (T >>> (64 - L));
      function ed(O, T, L, J) {
        let W = (T >>> 0) + (J >>> 0);
        return { h: (O + L + ((W / 4294967296) | 0)) | 0, l: 0 | W };
      }
      (T.rotlBL = eh), (T.add = ed);
      let ep = (O, T, L) => (O >>> 0) + (T >>> 0) + (L >>> 0);
      T.add3L = ep;
      let eg = (O, T, L, J) => (T + L + J + ((O / 4294967296) | 0)) | 0;
      T.add3H = eg;
      let ey = (O, T, L, J) => (O >>> 0) + (T >>> 0) + (L >>> 0) + (J >>> 0);
      T.add4L = ey;
      let em = (O, T, L, J, W) => (T + L + J + W + ((O / 4294967296) | 0)) | 0;
      T.add4H = em;
      let eb = (O, T, L, J, W) =>
        (O >>> 0) + (T >>> 0) + (L >>> 0) + (J >>> 0) + (W >>> 0);
      T.add5L = eb;
      let eA = (O, T, L, J, W, Y) =>
        (T + L + J + W + Y + ((O / 4294967296) | 0)) | 0;
      T.add5H = eA;
      let ew = {
        fromBig: W,
        split: Y,
        toBig: Z,
        shrSH: X,
        shrSL: ee,
        rotrSH: et,
        rotrSL: er,
        rotrBH: en,
        rotrBL: es,
        rotr32H: ei,
        rotr32L: ea,
        rotlSH: eo,
        rotlSL: ec,
        rotlBH: eu,
        rotlBL: eh,
        add: ed,
        add3L: ep,
        add3H: eg,
        add4L: ey,
        add4H: em,
        add5H: eA,
        add5L: eb,
      };
      T.default = ew;
    },
    85732: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.crypto = void 0),
        (T.crypto =
          "object" == typeof globalThis && "crypto" in globalThis
            ? globalThis.crypto
            : void 0);
    },
    28566: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.shake256 =
          T.shake128 =
          T.keccak_512 =
          T.keccak_384 =
          T.keccak_256 =
          T.keccak_224 =
          T.sha3_512 =
          T.sha3_384 =
          T.sha3_256 =
          T.sha3_224 =
          T.Keccak =
          T.keccakP =
            void 0);
      let J = L(31953),
        W = L(47391),
        Y = L(33610),
        Z = [],
        X = [],
        ee = [],
        et = BigInt(0),
        er = BigInt(1),
        en = BigInt(2),
        es = BigInt(7),
        ei = BigInt(256),
        ea = BigInt(113);
      for (let O = 0, T = er, L = 1, J = 0; O < 24; O++) {
        ([L, J] = [J, (2 * L + 3 * J) % 5]),
          Z.push(2 * (5 * J + L)),
          X.push((((O + 1) * (O + 2)) / 2) % 64);
        let W = et;
        for (let O = 0; O < 7; O++)
          (T = ((T << er) ^ ((T >> es) * ea)) % ei) & en &&
            (W ^= er << ((er << BigInt(O)) - er));
        ee.push(W);
      }
      let [eo, ec] = (0, W.split)(ee, !0),
        eu = (O, T, L) =>
          L > 32 ? (0, W.rotlBH)(O, T, L) : (0, W.rotlSH)(O, T, L),
        eh = (O, T, L) =>
          L > 32 ? (0, W.rotlBL)(O, T, L) : (0, W.rotlSL)(O, T, L);
      function ed(O, T = 24) {
        let L = new Uint32Array(10);
        for (let J = 24 - T; J < 24; J++) {
          for (let T = 0; T < 10; T++)
            L[T] = O[T] ^ O[T + 10] ^ O[T + 20] ^ O[T + 30] ^ O[T + 40];
          for (let T = 0; T < 10; T += 2) {
            let J = (T + 8) % 10,
              W = (T + 2) % 10,
              Y = L[W],
              Z = L[W + 1],
              X = eu(Y, Z, 1) ^ L[J],
              ee = eh(Y, Z, 1) ^ L[J + 1];
            for (let L = 0; L < 50; L += 10)
              (O[T + L] ^= X), (O[T + L + 1] ^= ee);
          }
          let T = O[2],
            W = O[3];
          for (let L = 0; L < 24; L++) {
            let J = X[L],
              Y = eu(T, W, J),
              ee = eh(T, W, J),
              et = Z[L];
            (T = O[et]), (W = O[et + 1]), (O[et] = Y), (O[et + 1] = ee);
          }
          for (let T = 0; T < 50; T += 10) {
            for (let J = 0; J < 10; J++) L[J] = O[T + J];
            for (let J = 0; J < 10; J++)
              O[T + J] ^= ~L[(J + 2) % 10] & L[(J + 4) % 10];
          }
          (O[0] ^= eo[J]), (O[1] ^= ec[J]);
        }
        L.fill(0);
      }
      T.keccakP = ed;
      class ep extends Y.Hash {
        constructor(O, T, L, W = !1, Z = 24) {
          if (
            (super(),
            (this.blockLen = O),
            (this.suffix = T),
            (this.outputLen = L),
            (this.enableXOF = W),
            (this.rounds = Z),
            (this.pos = 0),
            (this.posOut = 0),
            (this.finished = !1),
            (this.destroyed = !1),
            (0, J.number)(L),
            0 >= this.blockLen || this.blockLen >= 200)
          )
            throw Error("Sha3 supports only keccak-f1600 function");
          (this.state = new Uint8Array(200)),
            (this.state32 = (0, Y.u32)(this.state));
        }
        keccak() {
          Y.isLE || (0, Y.byteSwap32)(this.state32),
            ed(this.state32, this.rounds),
            Y.isLE || (0, Y.byteSwap32)(this.state32),
            (this.posOut = 0),
            (this.pos = 0);
        }
        update(O) {
          (0, J.exists)(this);
          let { blockLen: T, state: L } = this,
            W = (O = (0, Y.toBytes)(O)).length;
          for (let J = 0; J < W; ) {
            let Y = Math.min(T - this.pos, W - J);
            for (let T = 0; T < Y; T++) L[this.pos++] ^= O[J++];
            this.pos === T && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          let { state: O, suffix: T, pos: L, blockLen: J } = this;
          (O[L] ^= T),
            (128 & T) != 0 && L === J - 1 && this.keccak(),
            (O[J - 1] ^= 128),
            this.keccak();
        }
        writeInto(O) {
          (0, J.exists)(this, !1), (0, J.bytes)(O), this.finish();
          let T = this.state,
            { blockLen: L } = this;
          for (let J = 0, W = O.length; J < W; ) {
            this.posOut >= L && this.keccak();
            let Y = Math.min(L - this.posOut, W - J);
            O.set(T.subarray(this.posOut, this.posOut + Y), J),
              (this.posOut += Y),
              (J += Y);
          }
          return O;
        }
        xofInto(O) {
          if (!this.enableXOF)
            throw Error("XOF is not possible for this instance");
          return this.writeInto(O);
        }
        xof(O) {
          return (0, J.number)(O), this.xofInto(new Uint8Array(O));
        }
        digestInto(O) {
          if (((0, J.output)(O, this), this.finished))
            throw Error("digest() was already called");
          return this.writeInto(O), this.destroy(), O;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          (this.destroyed = !0), this.state.fill(0);
        }
        _cloneInto(O) {
          let {
            blockLen: T,
            suffix: L,
            outputLen: J,
            rounds: W,
            enableXOF: Y,
          } = this;
          return (
            O || (O = new ep(T, L, J, Y, W)),
            O.state32.set(this.state32),
            (O.pos = this.pos),
            (O.posOut = this.posOut),
            (O.finished = this.finished),
            (O.rounds = W),
            (O.suffix = L),
            (O.outputLen = J),
            (O.enableXOF = Y),
            (O.destroyed = this.destroyed),
            O
          );
        }
      }
      T.Keccak = ep;
      let eg = (O, T, L) => (0, Y.wrapConstructor)(() => new ep(T, O, L));
      (T.sha3_224 = eg(6, 144, 28)),
        (T.sha3_256 = eg(6, 136, 32)),
        (T.sha3_384 = eg(6, 104, 48)),
        (T.sha3_512 = eg(6, 72, 64)),
        (T.keccak_224 = eg(1, 144, 28)),
        (T.keccak_256 = eg(1, 136, 32)),
        (T.keccak_384 = eg(1, 104, 48)),
        (T.keccak_512 = eg(1, 72, 64));
      let ey = (O, T, L) =>
        (0, Y.wrapXOFConstructorWithOpts)(
          (J = {}) => new ep(T, O, void 0 === J.dkLen ? L : J.dkLen, !0)
        );
      (T.shake128 = ey(31, 168, 16)), (T.shake256 = ey(31, 136, 32));
    },
    33610: function (O, T, L) {
      // "use strict";
      /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(
        T,
        "__esModule",
        { value: !0 }
      ),
        (T.randomBytes =
          T.wrapXOFConstructorWithOpts =
          T.wrapConstructorWithOpts =
          T.wrapConstructor =
          T.checkOpts =
          T.Hash =
          T.concatBytes =
          T.toBytes =
          T.utf8ToBytes =
          T.asyncLoop =
          T.nextTick =
          T.hexToBytes =
          T.bytesToHex =
          T.byteSwap32 =
          T.byteSwapIfBE =
          T.byteSwap =
          T.isLE =
          T.rotl =
          T.rotr =
          T.createView =
          T.u32 =
          T.u8 =
          T.isBytes =
            void 0);
      let J = L(85732),
        W = L(31953);
      function Y(O) {
        return (
          O instanceof Uint8Array ||
          (null != O &&
            "object" == typeof O &&
            "Uint8Array" === O.constructor.name)
        );
      }
      T.isBytes = Y;
      let Z = (O) => new Uint8Array(O.buffer, O.byteOffset, O.byteLength);
      T.u8 = Z;
      let X = (O) =>
        new Uint32Array(O.buffer, O.byteOffset, Math.floor(O.byteLength / 4));
      T.u32 = X;
      let ee = (O) => new DataView(O.buffer, O.byteOffset, O.byteLength);
      T.createView = ee;
      let et = (O, T) => (O << (32 - T)) | (O >>> T);
      T.rotr = et;
      let er = (O, T) => (O << T) | ((O >>> (32 - T)) >>> 0);
      (T.rotl = er),
        (T.isLE =
          68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]);
      let en = (O) =>
        ((O << 24) & 4278190080) |
        ((O << 8) & 16711680) |
        ((O >>> 8) & 65280) |
        ((O >>> 24) & 255);
      function es(O) {
        for (let L = 0; L < O.length; L++) O[L] = (0, T.byteSwap)(O[L]);
      }
      (T.byteSwap = en),
        (T.byteSwapIfBE = T.isLE ? (O) => O : (O) => (0, T.byteSwap)(O)),
        (T.byteSwap32 = es);
      let ei = Array.from({ length: 256 }, (O, T) =>
        T.toString(16).padStart(2, "0")
      );
      function ea(O) {
        (0, W.bytes)(O);
        let T = "";
        for (let L = 0; L < O.length; L++) T += ei[O[L]];
        return T;
      }
      T.bytesToHex = ea;
      let eo = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
      function ec(O) {
        return O >= eo._0 && O <= eo._9
          ? O - eo._0
          : O >= eo._A && O <= eo._F
          ? O - (eo._A - 10)
          : O >= eo._a && O <= eo._f
          ? O - (eo._a - 10)
          : void 0;
      }
      function eu(O) {
        if ("string" != typeof O)
          throw Error("hex string expected, got " + typeof O);
        let T = O.length,
          L = T / 2;
        if (T % 2)
          throw Error(
            "padded hex string expected, got unpadded hex of length " + T
          );
        let J = new Uint8Array(L);
        for (let T = 0, W = 0; T < L; T++, W += 2) {
          let L = ec(O.charCodeAt(W)),
            Y = ec(O.charCodeAt(W + 1));
          if (void 0 === L || void 0 === Y)
            throw Error(
              'hex string expected, got non-hex character "' +
                (O[W] + O[W + 1]) +
                '" at index ' +
                W
            );
          J[T] = 16 * L + Y;
        }
        return J;
      }
      T.hexToBytes = eu;
      let eh = async () => {};
      async function ed(O, L, J) {
        let W = Date.now();
        for (let Y = 0; Y < O; Y++) {
          J(Y);
          let O = Date.now() - W;
          (O >= 0 && O < L) || (await (0, T.nextTick)(), (W += O));
        }
      }
      function ep(O) {
        if ("string" != typeof O)
          throw Error(`utf8ToBytes expected string, got ${typeof O}`);
        return new Uint8Array(new TextEncoder().encode(O));
      }
      function eg(O) {
        return "string" == typeof O && (O = ep(O)), (0, W.bytes)(O), O;
      }
      function ey(...O) {
        let T = 0;
        for (let L = 0; L < O.length; L++) {
          let J = O[L];
          (0, W.bytes)(J), (T += J.length);
        }
        let L = new Uint8Array(T);
        for (let T = 0, J = 0; T < O.length; T++) {
          let W = O[T];
          L.set(W, J), (J += W.length);
        }
        return L;
      }
      (T.nextTick = eh),
        (T.asyncLoop = ed),
        (T.utf8ToBytes = ep),
        (T.toBytes = eg),
        (T.concatBytes = ey);
      class em {
        clone() {
          return this._cloneInto();
        }
      }
      T.Hash = em;
      let eb = {}.toString;
      function eA(O, T) {
        if (void 0 !== T && "[object Object]" !== eb.call(T))
          throw Error("Options should be object or undefined");
        return Object.assign(O, T);
      }
      function ew(O) {
        let T = (T) => O().update(eg(T)).digest(),
          L = O();
        return (
          (T.outputLen = L.outputLen),
          (T.blockLen = L.blockLen),
          (T.create = () => O()),
          T
        );
      }
      function ev(O) {
        let T = (T, L) => O(L).update(eg(T)).digest(),
          L = O({});
        return (
          (T.outputLen = L.outputLen),
          (T.blockLen = L.blockLen),
          (T.create = (T) => O(T)),
          T
        );
      }
      function ek(O) {
        let T = (T, L) => O(L).update(eg(T)).digest(),
          L = O({});
        return (
          (T.outputLen = L.outputLen),
          (T.blockLen = L.blockLen),
          (T.create = (T) => O(T)),
          T
        );
      }
      function eE(O = 32) {
        if (J.crypto && "function" == typeof J.crypto.getRandomValues)
          return J.crypto.getRandomValues(new Uint8Array(O));
        throw Error("crypto.getRandomValues must be defined");
      }
      (T.checkOpts = eA),
        (T.wrapConstructor = ew),
        (T.wrapConstructorWithOpts = ev),
        (T.wrapXOFConstructorWithOpts = ek),
        (T.randomBytes = eE);
    },
    32957: function (O, T, L) {
      // "use strict";
      var J,
        W =
          (this && this.__importDefault) ||
          function (O) {
            return O && O.__esModule ? O : { default: O };
          };
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ParsedMessage = void 0);
      let Y = W(L(36949)),
        Z = W(L(26979)),
        X = L(15279),
        ee = `
sign-in-with-ethereum =
    [ scheme "://" ] domain %s" wants you to sign in with your Ethereum account:" LF
    address LF
    LF
    [ statement LF ]
    LF
    %s"URI: " URI LF
    %s"Version: " version LF
    %s"Chain ID: " chain-id LF
    %s"Nonce: " nonce LF
    %s"Issued At: " issued-at
    [ LF %s"Expiration Time: " expiration-time ]
    [ LF %s"Not Before: " not-before ]
    [ LF %s"Request ID: " request-id ]
    [ LF %s"Resources:"
    resources ]

domain = authority

address = "0x" 40*40HEXDIG
    ; Must also conform to captilization
    ; checksum encoding specified in EIP-55
    ; where applicable (EOAs).

statement = 1*( reserved / unreserved / " " )
    ; The purpose is to exclude LF (line breaks).

version = "1"

nonce = 8*( ALPHA / DIGIT )

issued-at = date-time
expiration-time = date-time
not-before = date-time

request-id = *pchar

chain-id = 1*DIGIT
    ; See EIP-155 for valid CHAIN_IDs.

resources = *( LF resource )

resource = "- " URI

; ------------------------------------------------------------------------------
; RFC 3986

URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

hier-part     = "//" authority path-abempty
              / path-absolute
              / path-rootless
              / path-empty

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

authority     = [ userinfo "@" ] host [ ":" port ]
userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
host          = IP-literal / IPv4address / reg-name
port          = *DIGIT

IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"

IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

IPv6address   =                            6( h16 ":" ) ls32
              /                       "::" 5( h16 ":" ) ls32
              / [               h16 ] "::" 4( h16 ":" ) ls32
              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
              / [ *4( h16 ":" ) h16 ] "::"              ls32
              / [ *5( h16 ":" ) h16 ] "::"              h16
              / [ *6( h16 ":" ) h16 ] "::"

h16           = 1*4HEXDIG
ls32          = ( h16 ":" h16 ) / IPv4address
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
dec-octet     = DIGIT                 ; 0-9
                 / %x31-39 DIGIT         ; 10-99
                 / "1" 2DIGIT            ; 100-199
                 / "2" %x30-34 DIGIT     ; 200-249
                 / "25" %x30-35          ; 250-255

reg-name      = *( unreserved / pct-encoded / sub-delims )

path-abempty  = *( "/" segment )
path-absolute = "/" [ segment-nz *( "/" segment ) ]
path-rootless = segment-nz *( "/" segment )
path-empty    = 0pchar

segment       = *pchar
segment-nz    = 1*pchar

pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

query         = *( pchar / "/" / "?" )

fragment      = *( pchar / "/" / "?" )

pct-encoded   = "%" HEXDIG HEXDIG

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
reserved      = gen-delims / sub-delims
gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="

; ------------------------------------------------------------------------------
; RFC 3339

date-fullyear   = 4DIGIT
date-month      = 2DIGIT  ; 01-12
date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                          ; month/year
time-hour       = 2DIGIT  ; 00-23
time-minute     = 2DIGIT  ; 00-59
time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
                          ; rules
time-secfrac    = "." 1*DIGIT
time-numoffset  = ("+" / "-") time-hour ":" time-minute
time-offset     = "Z" / time-numoffset

partial-time    = time-hour ":" time-minute ":" time-second
                  [time-secfrac]
full-date       = date-fullyear "-" date-month "-" date-mday
full-time       = partial-time time-offset

date-time       = full-date "T" full-time

; ------------------------------------------------------------------------------
; RFC 5234

ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
LF             =  %x0A
                  ; linefeed
DIGIT          =  %x30-39
                  ; 0-9
HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
`;
      class et {
        static generateApi() {
          let O = new Y.default(ee);
          if ((O.generate(), O.errors.length))
            throw (
              (console.error(O.errorsToAscii()),
              console.error(O.linesToAscii()),
              console.log(O.displayAttributeErrors()),
              Error("ABNF grammar has errors"))
            );
          return O.toObject();
        }
      }
      (J = et), (et.grammarObj = J.generateApi());
      class er {
        constructor(O) {
          let T = new Z.default.parser();
          T.ast = new Z.default.ast();
          let L = Z.default.ids,
            J = function (O, T, J, W, Y) {
              let X = L.SEM_OK;
              return (
                O === L.SEM_PRE &&
                  0 === J &&
                  (Y.scheme = Z.default.utils.charsToString(T, J, W)),
                X
              );
            };
          T.ast.callbacks.scheme = J;
          let W = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.domain = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks.domain = W;
          let Y = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.address = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks.address = Y;
          let ee = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.statement = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks.statement = ee;
          let er = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O !== L.SEM_PRE ||
                Y.uri ||
                (Y.uri = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks.uri = er;
          let en = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.version = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks.version = en;
          let es = function (O, T, J, W, Y) {
            let ee = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.chainId = (0, X.parseIntegerNumber)(
                  Z.default.utils.charsToString(T, J, W)
                )),
              ee
            );
          };
          T.ast.callbacks["chain-id"] = es;
          let ei = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.nonce = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks.nonce = ei;
          let ea = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.issuedAt = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks["issued-at"] = ea;
          let eo = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.expirationTime = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks["expiration-time"] = eo;
          let ec = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.notBefore = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks["not-before"] = ec;
          let eu = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.requestId = Z.default.utils.charsToString(T, J, W)),
              X
            );
          };
          T.ast.callbacks["request-id"] = eu;
          let eh = function (O, T, J, W, Y) {
            let X = L.SEM_OK;
            return (
              O === L.SEM_PRE &&
                (Y.resources = Z.default.utils
                  .charsToString(T, J, W)
                  .slice(3)
                  .split("\n- ")),
              X
            );
          };
          T.ast.callbacks.resources = eh;
          let ed = T.parse(et.grammarObj, "sign-in-with-ethereum", O);
          if (!ed.success)
            throw Error(`Invalid message: ${JSON.stringify(ed)}`);
          let ep = {};
          for (let [O, L] of (T.ast.translate(ep), Object.entries(ep)))
            this[O] = L;
          if (0 === this.domain.length) throw Error("Domain cannot be empty.");
          if (!(0, X.isEIP55Address)(this.address))
            throw Error("Address not conformant to EIP-55.");
        }
      }
      T.ParsedMessage = er;
    },
    88125: function (O, T, L) {
      // "use strict";
      var J =
          (this && this.__createBinding) ||
          (Object.create
            ? function (O, T, L, J) {
                void 0 === J && (J = L);
                var W = Object.getOwnPropertyDescriptor(T, L);
                (!W ||
                  ("get" in W
                    ? !T.__esModule
                    : W.writable || W.configurable)) &&
                  (W = {
                    enumerable: !0,
                    get: function () {
                      return T[L];
                    },
                  }),
                  Object.defineProperty(O, J, W);
              }
            : function (O, T, L, J) {
                void 0 === J && (J = L), (O[J] = T[L]);
              }),
        W =
          (this && this.__exportStar) ||
          function (O, T) {
            for (var L in O)
              "default" === L ||
                Object.prototype.hasOwnProperty.call(T, L) ||
                J(T, O, L);
          };
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ParsedMessage = void 0);
      let Y = L(32957);
      Object.defineProperty(T, "ParsedMessage", {
        enumerable: !0,
        get: function () {
          return Y.ParsedMessage;
        },
      }),
        W(L(15279), T);
    },
    15279: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.parseIntegerNumber = T.isEIP55Address = void 0);
      let J = L(28566),
        W = L(33610),
        Y = (O) => {
          if (42 != O.length) return !1;
          let T = `${O}`.toLowerCase().replace("0x", ""),
            L = (0, W.bytesToHex)((0, J.keccak_256)(T)),
            Y = "0x";
          for (let O = 0; O < T.length; O++)
            parseInt(L[O], 16) >= 8 ? (Y += T[O].toUpperCase()) : (Y += T[O]);
          return O === Y;
        };
      T.isEIP55Address = Y;
      let Z = (O) => {
        let T = parseInt(O);
        if (isNaN(T) || T === 1 / 0) throw Error("Invalid number.");
        return T;
      };
      T.parseIntegerNumber = Z;
    },
    36949: function (O, T, L) {
      O.exports = function (O) {
        let T;
        let { Buffer: J } = L(30410),
          W = "api.js: ",
          Y = this,
          Z = L(26979),
          X = L(80407),
          ee = L(90103),
          et = new (L(72810))(),
          {
            attributes: er,
            showAttributes: en,
            showAttributeErrors: es,
            showRuleDependencies: ei,
          } = L(49212),
          ea = L(23906),
          eo = function (O, T, L) {
            let J;
            let W = 0,
              Y = 1,
              X = 2,
              ee = `<span class="${Z.style.CLASS_CTRLCHAR}">`,
              et = "</span>",
              er = `<span class="${Z.style.CLASS_NOMATCH}">`,
              en = "</span>",
              es = "",
              ei = !0;
            for (; ei && Array.isArray(O) && 0 !== O.length; ) {
              if ("number" != typeof T)
                throw Error("abnfToHtml: beg must be type number");
              if (T >= O.length) break;
              J = "number" != typeof L || T + L >= O.length ? O.length : T + L;
              let ei = W;
              for (let L = T; L < J; L += 1) {
                let T = O[L];
                if (T >= 32 && T <= 126)
                  switch (
                    (ei === Y
                      ? ((es += et), (ei = W))
                      : ei === X && ((es += en), (ei = W)),
                    T)
                  ) {
                    case 32:
                      es += "&nbsp;";
                      break;
                    case 60:
                      es += "&lt;";
                      break;
                    case 62:
                      es += "&gt;";
                      break;
                    case 38:
                      es += "&amp;";
                      break;
                    case 34:
                      es += "&quot;";
                      break;
                    case 39:
                      es += "&#039;";
                      break;
                    case 92:
                      es += "&#092;";
                      break;
                    default:
                      es += String.fromCharCode(T);
                  }
                else
                  9 === T || 10 === T || 13 === T
                    ? (ei === W
                        ? ((es += ee), (ei = Y))
                        : ei === X && ((es += en + ee), (ei = Y)),
                      9 === T && (es += "TAB"),
                      10 === T && (es += "LF"),
                      13 === T && (es += "CR"))
                    : (ei === W
                        ? ((es += er), (ei = X))
                        : ei === Y && ((es += et + er), (ei = X)),
                      (es += `\\x${Z.utils.charToHex(T)}`));
              }
              ei === X && (es += en), ei === Y && (es += et);
              break;
            }
            return es;
          },
          ec = function (O, T, L) {
            let J = "";
            for (let W = T; W < T + L; W += 1) {
              let T = O[W];
              if (T >= 32 && T <= 126) J += String.fromCharCode(T);
              else
                switch (T) {
                  case 9:
                    J += "\\t";
                    break;
                  case 10:
                    J += "\\n";
                    break;
                  case 13:
                    J += "\\r";
                    break;
                  default:
                    J += "\\unknown";
                }
            }
            return J;
          },
          eu = function (O) {
            let T = "Annotated Input Grammar";
            return (
              O.forEach((O) => {
                T += `
line no: ${O.lineNo} : char index: ${O.beginChar} : length: ${
                  O.length
                } : abnf: ${ec(Y.chars, O.beginChar, O.length)}`;
              }),
              (T += "\n")
            );
          },
          eh = function (O) {
            let T = "";
            T += `<table class="${Z.style.CLASS_GRAMMAR}">
`;
            let L = "Annotated Input Grammar";
            return (
              (T += `<caption>${L}</caption>
<tr><th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th></tr>
`),
              O.forEach((O) => {
                T += `<tr><td>${O.lineNo}</td><td>${O.beginChar}</td><td>${
                  O.length
                }</td><td>${eo(Y.chars, O.beginChar, O.length)}</td></tr>
`;
              }),
              (T += "</table>\n")
            );
          },
          ed = function (O, T, L, J) {
            let [W] = Z,
              Y = "",
              X = `<span class="${W.CLASS_NOMATCH}">&raquo;</span>`;
            return (
              (Y += `<p><table class="${W.CLASS_GRAMMAR}">
`),
              J &&
                "string" == typeof J &&
                (Y += `<caption>${J}</caption>
`),
              (Y +=
                "<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\n"),
              O.forEach((O) => {
                let J, W, ee, et, er;
                let en = "",
                  es = "";
                0 === T.length
                  ? ((er = X), (W = 0))
                  : ((ee = (J = T[O.line]).beginChar),
                    O.char > ee && (en = eo(L, ee, O.char - ee)),
                    (ee = O.char) < (et = J.beginChar + J.length) &&
                      (es = eo(L, ee, et - ee)),
                    (er = en + X + es),
                    (W = O.char - J.beginChar),
                    (Y += `<tr><td>${O.line}</td><td>${
                      J.beginChar
                    }</td><td>${W}</td><td>${er}</td></tr>
<tr><td colspan="3"></td><td>&uarr;:&nbsp;${Z.utils.stringToAsciiHtml(
                      O.msg
                    )}</td></tr>
`));
              }),
              (Y += "</table></p>\n")
            );
          },
          ep = function (O, T, L) {
            let J, W, Y, Z;
            return (
              (J = ""),
              O.forEach((O) => {
                (W = T[O.line]),
                  (J += `${W.lineNo}: ${W.beginChar}: ${
                    O.char - W.beginChar
                  }: `),
                  (Y = W.beginChar),
                  (Z = O.char - W.beginChar),
                  (J += ec(L, Y, Z) + " >> "),
                  (Y = O.char),
                  (Z = W.beginChar + W.length - O.char),
                  (J +=
                    ec(L, Y, Z) +
                    "\n" +
                    `${W.lineNo}: ` +
                    `${W.beginChar}: ` +
                    `${O.char - W.beginChar}: ` +
                    "error: " +
                    O.msg +
                    "\n");
              }),
              J
            );
          },
          eg = !1,
          ey = !1,
          em = !1,
          eb = !1,
          eA = 0;
        if (((this.errors = []), J.isBuffer(O)))
          this.chars = X.decode("BINARY", O);
        else if (Array.isArray(O)) this.chars = O.slice();
        else if ("string" == typeof O) this.chars = X.decode("STRING", O);
        else
          throw Error(
            `${W}input source is not a string, byte Buffer or character array`
          );
        (this.sabnf = X.encode("STRING", this.chars)),
          (this.scan = function (O, T) {
            (this.lines = ee(this.chars, this.errors, O, T)), (eg = !0);
          }),
          (this.parse = function (O, T, L) {
            if (!eg) throw Error(`${W}grammar not scanned`);
            et.syntax(this.chars, this.lines, this.errors, O, T, L), (ey = !0);
          }),
          (this.translate = function () {
            if (!ey) throw Error(`${W}grammar not scanned and parsed`);
            let O = et.semantic(this.chars, this.lines, this.errors);
            0 === this.errors.length &&
              ((this.rules = O.rules),
              (this.udts = O.udts),
              (T = O.lineMap),
              (em = !0));
          }),
          (this.attributes = function () {
            if (!em)
              throw Error(`${W}grammar not scanned, parsed and translated`);
            return (
              (eA = er(this.rules, this.udts, T, this.errors)), (eb = !0), eA
            );
          }),
          (this.generate = function (O) {
            if (
              ((this.lines = ee(this.chars, this.errors, O)),
              this.errors.length ||
                (et.syntax(this.chars, this.lines, this.errors, O),
                this.errors.length))
            )
              return;
            let L = et.semantic(this.chars, this.lines, this.errors);
            this.errors.length ||
              ((this.rules = L.rules),
              (this.udts = L.udts),
              (T = L.lineMap),
              (eA = er(this.rules, this.udts, T, this.errors)),
              (eb = !0));
          }),
          (this.displayRules = function (O = "index") {
            if (!em)
              throw Error(`${W}grammar not scanned, parsed and translated`);
            return ea(this.rules, this.udts, O);
          }),
          (this.displayRuleDependencies = function (O = "index") {
            if (!eb)
              throw Error(
                `${W}no attributes - must be preceeded by call to attributes()`
              );
            return ei(O);
          }),
          (this.displayAttributes = function (O = "index") {
            if (!eb)
              throw Error(
                `${W}no attributes - must be preceeded by call to attributes()`
              );
            return eA && es(O), en(O);
          }),
          (this.displayAttributeErrors = function () {
            if (!eb)
              throw Error(
                `${W}no attributes - must be preceeded by call to attributes()`
              );
            return es();
          }),
          (this.toSource = function (O, T) {
            if (!eb)
              throw Error(
                `${W}can't generate parser source - must be preceeded by call to attributes()`
              );
            if (eA)
              throw Error(
                `${W}can't generate parser source - attributes have ${eA} errors`
              );
            return et.generateSource(
              this.chars,
              this.lines,
              this.rules,
              this.udts,
              O,
              T
            );
          }),
          (this.toObject = function () {
            if (!eb)
              throw Error(
                `${W}can't generate parser source - must be preceeded by call to attributes()`
              );
            if (eA)
              throw Error(
                `${W}can't generate parser source - attributes have ${eA} errors`
              );
            return et.generateObject(this.sabnf, this.rules, this.udts);
          }),
          (this.errorsToAscii = function () {
            return ep(this.errors, this.lines, this.chars);
          }),
          (this.errorsToHtml = function (O) {
            return ed(this.errors, this.lines, this.chars, O);
          }),
          (this.linesToAscii = function () {
            return eu(this.lines);
          }),
          (this.linesToHtml = function () {
            return eh(this.lines);
          });
      };
    },
    49212: function (O, T, L) {
      O.exports = (function () {
        let O = L(47351),
          {
            ruleAttributes: T,
            showAttributes: J,
            showAttributeErrors: W,
          } = L(13017),
          { ruleDependencies: Y, showRuleDependencies: Z } = L(80881);
        class X {
          constructor(O, T) {
            (this.rules = O),
              (this.udts = T),
              (this.ruleCount = O.length),
              (this.udtCount = T.length),
              (this.startRule = 0),
              (this.dependenciesComplete = !1),
              (this.attributesComplete = !1),
              (this.isMutuallyRecursive = !1),
              (this.ruleIndexes = this.indexArray(this.ruleCount)),
              (this.ruleAlphaIndexes = this.indexArray(this.ruleCount)),
              (this.ruleTypeIndexes = this.indexArray(this.ruleCount)),
              (this.udtIndexes = this.indexArray(this.udtCount)),
              (this.udtAlphaIndexes = this.indexArray(this.udtCount)),
              (this.attrsErrorCount = 0),
              (this.attrs = []),
              (this.attrsErrors = []),
              (this.attrsWorking = []),
              (this.ruleDeps = []);
            for (let T = 0; T < this.ruleCount; T += 1)
              this.attrs.push(this.attrGen(this.rules[T])),
                this.attrsWorking.push(this.attrGen(this.rules[T])),
                this.ruleDeps.push(
                  this.rdGen(O[T], this.ruleCount, this.udtCount)
                );
            (this.compRulesAlpha = this.compRulesAlpha.bind(this)),
              (this.compUdtsAlpha = this.compUdtsAlpha.bind(this)),
              (this.compRulesType = this.compRulesType.bind(this)),
              (this.compRulesGroup = this.compRulesGroup.bind(this));
          }
          attrGen(O) {
            return {
              left: !1,
              nested: !1,
              right: !1,
              empty: !1,
              finite: !1,
              cyclic: !1,
              leaf: !1,
              isOpen: !1,
              isComplete: !1,
              rule: O,
            };
          }
          attrInit(O) {
            (O.left = !1),
              (O.nested = !1),
              (O.right = !1),
              (O.empty = !1),
              (O.finite = !1),
              (O.cyclic = !1),
              (O.leaf = !1),
              (O.isOpen = !1),
              (O.isComplete = !1);
          }
          attrCopy(O, T) {
            (O.left = T.left),
              (O.nested = T.nested),
              (O.right = T.right),
              (O.empty = T.empty),
              (O.finite = T.finite),
              (O.cyclic = T.cyclic),
              (O.leaf = T.leaf),
              (O.isOpen = T.isOpen),
              (O.isComplete = T.isComplete),
              (O.rule = T.rule);
          }
          rdGen(T, L, J) {
            return {
              rule: T,
              recursiveType: O.ATTR_N,
              groupNumber: -1,
              refersTo: this.falseArray(L),
              refersToUdt: this.falseArray(J),
              referencedBy: this.falseArray(L),
            };
          }
          typeToString(T) {
            switch (T) {
              case O.ATTR_N:
                return " N";
              case O.ATTR_R:
                return " R";
              case O.ATTR_MR:
                return "MR";
              default:
                return "UNKNOWN";
            }
          }
          falseArray(O) {
            let T = [];
            if (O > 0) for (let L = 0; L < O; L += 1) T.push(!1);
            return T;
          }
          falsifyArray(O) {
            for (let T = 0; T < O.length; T += 1) O[T] = !1;
          }
          indexArray(O) {
            let T = [];
            if (O > 0) for (let L = 0; L < O; L += 1) T.push(L);
            return T;
          }
          compRulesAlpha(O, T) {
            return this.rules[O].lower < this.rules[T].lower
              ? -1
              : this.rules[O].lower > this.rules[T].lower
              ? 1
              : 0;
          }
          compUdtsAlpha(O, T) {
            return this.udts[O].lower < this.udts[T].lower
              ? -1
              : this.udts[O].lower > this.udts[T].lower
              ? 1
              : 0;
          }
          compRulesType(O, T) {
            return this.ruleDeps[O].recursiveType <
              this.ruleDeps[T].recursiveType
              ? -1
              : this.ruleDeps[O].recursiveType > this.ruleDeps[T].recursiveType
              ? 1
              : 0;
          }
          compRulesGroup(T, L) {
            if (
              this.ruleDeps[T].recursiveType === O.ATTR_MR &&
              this.ruleDeps[L].recursiveType === O.ATTR_MR
            ) {
              if (this.ruleDeps[T].groupNumber < this.ruleDeps[L].groupNumber)
                return -1;
              if (this.ruleDeps[T].groupNumber > this.ruleDeps[L].groupNumber)
                return 1;
            }
            return 0;
          }
        }
        return {
          attributes: function (O = [], L = [], J = [], W = []) {
            let Z = new X(O, L);
            return (
              Y(Z),
              T(Z),
              Z.attrsErrorCount &&
                W.push({
                  line: 0,
                  char: 0,
                  msg: `${Z.attrsErrorCount} attribute errors`,
                }),
              Z.attrsErrorCount
            );
          },
          showAttributes: J,
          showAttributeErrors: W,
          showRuleDependencies: Z,
        };
      })();
    },
    72810: function (O, T, L) {
      O.exports = function () {
        let O = "parser: ",
          T = L(26979),
          J = T.ids,
          W = new (L(50125))(),
          Y = new (L(6876))(),
          Z = new (L(37177))(),
          X = new T.parser();
        (X.ast = new T.ast()),
          (X.callbacks = W.callbacks),
          (X.ast.callbacks = Y.callbacks);
        let ee = function (O, T, L) {
            if (T < 0 || T >= L) return -1;
            for (let L = 0; L < O.length; L += 1)
              if (T >= O[L].beginChar && T < O[L].beginChar + O[L].length)
                return L;
            return -1;
          },
          et = function (O, T) {
            let L = -1;
            if (T < O.length) {
              for (let J = T; J < O.length; J += 1)
                if (null !== O[J]) {
                  L = O[J];
                  break;
                }
            }
            return L;
          },
          er = function (O) {
            O.forEach((O) => {
              let T = [],
                L = [],
                W = 0;
              O.opcodes.forEach((O) => {
                O.type === J.ALT && 1 === O.children.length
                  ? L.push(null)
                  : O.type === J.CAT && 1 === O.children.length
                  ? L.push(null)
                  : O.type === J.REP && 1 === O.min && 1 === O.max
                  ? L.push(null)
                  : (L.push(W), T.push(O), (W += 1));
              }),
                L.push(W),
                T.forEach((O) => {
                  if (O.type === J.ALT || O.type === J.CAT)
                    for (let T = 0; T < O.children.length; T += 1)
                      O.children[T] = et(L, O.children[T]);
                }),
                (O.opcodes = T);
            });
          };
        (this.syntax = function (T, L, J, W, Y, et) {
          if (et) {
            if ("traceObject" !== et.traceObject)
              throw TypeError(`${O}trace argument is not a trace object`);
            X.trace = et;
          }
          let er = {};
          (er.errors = J),
            (er.strict = !!W),
            (er.lite = !!Y),
            (er.lines = L),
            (er.findLine = ee),
            (er.charsLength = T.length),
            (er.ruleCount = 0),
            X.parse(Z, "file", T, er).success ||
              J.push({
                line: 0,
                char: 0,
                msg: "syntax analysis of input grammar failed",
              });
        }),
          (this.semantic = function (O, T, L) {
            let J = {};
            return ((J.errors = L),
            (J.lines = T),
            (J.findLine = ee),
            (J.charsLength = O.length),
            X.ast.translate(J),
            L.length)
              ? null
              : (er(J.rules),
                { rules: J.rules, udts: J.udts, lineMap: J.rulesLineMap });
          }),
          (this.generateSource = function (O, T, L, W, Y, Z) {
            let X,
              ee,
              et,
              er,
              en = "",
              es = 0,
              ei = 1 / 0,
              ea = 0,
              eo = [],
              ec = [],
              eu = 0,
              eh = 0,
              ed = 0,
              ep = 0,
              eg = 0,
              ey = 0,
              em = 0,
              eb = 0,
              eA = 0,
              ew = 0,
              ev = 0,
              ek = 0,
              eE = 0,
              eS = 0,
              eP = 0;
            return (
              L.forEach((O) => {
                eo.push(O.lower),
                  (es += O.opcodes.length),
                  O.opcodes.forEach((O) => {
                    switch (O.type) {
                      case J.ALT:
                        eu += 1;
                        break;
                      case J.CAT:
                        eh += 1;
                        break;
                      case J.RNM:
                        ed += 1;
                        break;
                      case J.UDT:
                        ep += 1;
                        break;
                      case J.REP:
                        eg += 1;
                        break;
                      case J.AND:
                        ey += 1;
                        break;
                      case J.NOT:
                        em += 1;
                        break;
                      case J.BKA:
                        ek += 1;
                        break;
                      case J.BKN:
                        eE += 1;
                        break;
                      case J.BKR:
                        ev += 1;
                        break;
                      case J.ABG:
                        eS += 1;
                        break;
                      case J.AEN:
                        eP += 1;
                        break;
                      case J.TLS:
                        for (eb += 1, X = 0; X < O.string.length; X += 1)
                          O.string[X] < ei && (ei = O.string[X]),
                            O.string[X] > ea && (ea = O.string[X]);
                        break;
                      case J.TBS:
                        for (eA += 1, X = 0; X < O.string.length; X += 1)
                          O.string[X] < ei && (ei = O.string[X]),
                            O.string[X] > ea && (ea = O.string[X]);
                        break;
                      case J.TRG:
                        (ew += 1),
                          O.min < ei && (ei = O.min),
                          O.max > ea && (ea = O.max);
                        break;
                      default:
                        throw Error("generateSource: unrecognized opcode");
                    }
                  });
              }),
              eo.sort(),
              W.length > 0 &&
                (W.forEach((O) => {
                  ec.push(O.lower);
                }),
                ec.sort()),
              (en +=
                "// copyright: Copyright (c) 2023 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.3.0 [apg-js](https://github.com/ldthomas/apg-js)\n"),
              Z && "string" == typeof Z
                ? (en += `const ${Z} = function grammar(){
`)
                : Y
                ? (en += "export default function grammar(){\n")
                : (en += `module.exports = function grammar(){
`),
              (en += `  // \`\`\`
  // SUMMARY
  //      rules = ${L.length}
  //       udts = ${W.length}
  //    opcodes = ${es}
  //        ---   ABNF original opcodes
  //        ALT = ${eu}
  //        CAT = ${eh}
  //        REP = ${eg}
  //        RNM = ${ed}
  //        TLS = ${eb}
  //        TBS = ${eA}
  //        TRG = ${ew}
  //        ---   SABNF superset opcodes
  //        UDT = ${ep}
  //        AND = ${ey}
  //        NOT = ${em}
`),
              Y ||
                (en += `  //        BKA = ${ek}
  //        BKN = ${eE}
  //        BKR = ${ev}
  //        ABG = ${eS}
  //        AEN = ${eP}
`),
              (en += "  // characters = ["),
              eb + eA + ew === 0
                ? (en += " none defined ]")
                : (en += `${ei} - ${ea}]`),
              ep > 0 && (en += " + user defined"),
              (en += "\n  // ```\n"),
              Y ||
                (en +=
                  "  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n"),
              (en += "\n  /* RULES */\n  this.rules = [];\n"),
              L.forEach((O, T) => {
                let L = "  this.rules[";
                (L +=
                  T +
                  "] = {name: '" +
                  O.name +
                  "', lower: '" +
                  O.lower +
                  "', index: " +
                  O.index +
                  ", isBkr: " +
                  O.isBkr +
                  "};\n"),
                  (en += L);
              }),
              (en += "\n  /* UDTS */\n  this.udts = [];\n"),
              W.length > 0 &&
                W.forEach((O, T) => {
                  let L = "  this.udts[";
                  (L +=
                    T +
                    "] = {name: '" +
                    O.name +
                    "', lower: '" +
                    O.lower +
                    "', index: " +
                    O.index +
                    ", empty: " +
                    O.empty +
                    ", isBkr: " +
                    O.isBkr +
                    "};\n"),
                    (en += L);
                }),
              (en += "\n  /* OPCODES */\n"),
              L.forEach((O, T) => {
                T > 0 && (en += "\n"),
                  (en += `  /* ${O.name} */
  this.rules[${T}].opcodes = [];
`),
                  O.opcodes.forEach((O, Y) => {
                    let Z;
                    switch (O.type) {
                      case J.ALT:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${
                          O.type
                        }, children: [${O.children.toString()}]};// ALT
`;
                        break;
                      case J.CAT:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${
                          O.type
                        }, children: [${O.children.toString()}]};// CAT
`;
                        break;
                      case J.RNM:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${
                          O.type
                        }, index: ${O.index}};// RNM(${L[O.index].name})
`;
                        break;
                      case J.BKR:
                        O.index >= L.length
                          ? ((ee = W[O.index - L.length].name),
                            (et = W[O.index - L.length].lower))
                          : ((ee = L[O.index].name), (et = L[O.index].lower)),
                          (Z = "%i"),
                          O.bkrCase === J.BKR_MODE_CS && (Z = "%s"),
                          O.bkrMode === J.BKR_MODE_UM
                            ? (Z += "%u")
                            : (Z += "%p"),
                          (ee = Z + ee),
                          (en += `  this.rules[${T}].opcodes[${Y}] = {type: ${O.type}, index: ${O.index}, lower: '${et}', bkrCase: ${O.bkrCase}, bkrMode: ${O.bkrMode}};// BKR(\\${ee})
`);
                        break;
                      case J.UDT:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${
                          O.type
                        }, empty: ${O.empty}, index: ${O.index}};// UDT(${
                          W[O.index].name
                        })
`;
                        break;
                      case J.REP:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${O.type}, min: ${O.min}, max: ${O.max}};// REP
`;
                        break;
                      case J.AND:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${O.type}};// AND
`;
                        break;
                      case J.NOT:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${O.type}};// NOT
`;
                        break;
                      case J.ABG:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${O.type}};// ABG(%^)
`;
                        break;
                      case J.AEN:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${O.type}};// AEN(%$)
`;
                        break;
                      case J.BKA:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${O.type}};// BKA
`;
                        break;
                      case J.BKN:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${O.type}};// BKN
`;
                        break;
                      case J.TLS:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${
                          O.type
                        }, string: [${O.string.toString()}]};// TLS
`;
                        break;
                      case J.TBS:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${
                          O.type
                        }, string: [${O.string.toString()}]};// TBS
`;
                        break;
                      case J.TRG:
                        en += `  this.rules[${T}].opcodes[${Y}] = {type: ${O.type}, min: ${O.min}, max: ${O.max}};// TRG
`;
                        break;
                      default:
                        throw Error("parser.js: ~143: unrecognized opcode");
                    }
                  });
              }),
              (en +=
                '\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = "";\n'),
              T.forEach((T) => {
                let L = T.beginChar + T.length;
                (er = ""), (en += '    str += "');
                for (let J = T.beginChar; J < L; J += 1) {
                  switch (O[J]) {
                    case 9:
                      er = " ";
                      break;
                    case 10:
                      er = "\\n";
                      break;
                    case 13:
                      er = "\\r";
                      break;
                    case 34:
                      er = '\\"';
                      break;
                    case 92:
                      er = "\\\\";
                      break;
                    default:
                      er = String.fromCharCode(O[J]);
                  }
                  en += er;
                }
                en += '";\n';
              }),
              (en += "    return str;\n  }\n}\n")
            );
          }),
          (this.generateObject = function (O, T, L) {
            let J = {},
              W = [],
              Y = [],
              Z = O.slice(0);
            return (
              (J.grammarObject = "grammarObject"),
              T.forEach((O) => {
                W.push(O.lower);
              }),
              W.sort(),
              L.length > 0 &&
                (L.forEach((O) => {
                  Y.push(O.lower);
                }),
                Y.sort()),
              (J.callbacks = []),
              W.forEach((O) => {
                J.callbacks[O] = !1;
              }),
              L.length > 0 &&
                Y.forEach((O) => {
                  J.callbacks[O] = !1;
                }),
              (J.rules = T),
              (J.udts = L),
              (J.toString = function () {
                return Z;
              }),
              J
            );
          });
      };
    },
    13017: function (O, T, L) {
      O.exports = (function () {
        let O = L(47351),
          T = "rule-attributes.js",
          J = null;
        function W(O) {
          return !O.left && !O.nested && !O.right && !O.cyclic && O.empty;
        }
        function Y(O) {
          return !!O.left || !!O.nested || !!O.right || !!O.cyclic;
        }
        function Z(O, T) {
          let L = 0,
            J = 0,
            Z = 0;
          for (L = 0; L < T; L += 1) if (O[L].nested) return !0;
          for (L = 0; L < T; L += 1)
            if (O[L].right && !O[L].leaf) {
              for (J = L + 1; J < T; J += 1) if (!W(O[J])) return !0;
            }
          for (L = T - 1; L >= 0; L -= 1)
            if (O[L].left && !O[L].leaf) {
              for (J = L - 1; J >= 0; J -= 1) if (!W(O[J])) return !0;
            }
          for (L = 0; L < T; L += 1)
            if (!O[L].empty && !Y(O[L])) {
              for (J = L + 1; J < T; J += 1)
                if (Y(O[J])) {
                  for (Z = J + 1; Z < T; Z += 1)
                    if (!O[Z].empty && !Y(O[Z])) return !0;
                }
            }
          return !1;
        }
        function X(O, T) {
          for (let L = 0; L < T; L += 1) if (!O[L].cyclic) return !1;
          return !0;
        }
        function ee(O, T) {
          for (let L = 0; L < T; L += 1) {
            if (O[L].left) return !0;
            if (!O[L].empty) break;
          }
          return !1;
        }
        function et(O, T) {
          for (let L = T - 1; L >= 0; L -= 1) {
            if (O[L].right) return !0;
            if (!O[L].empty) break;
          }
          return !1;
        }
        function er(O, T) {
          for (let L = 0; L < T; L += 1) if (!O[L].empty) return !1;
          return !0;
        }
        function en(O, T) {
          for (let L = 0; L < T; L += 1) if (!O[L].finite) return !1;
          return !0;
        }
        function es(O, T, L, J) {
          let W = 0,
            Y = T[L],
            es = Y.children.length,
            ei = [];
          for (W = 0; W < es; W += 1) ei.push(O.attrGen());
          for (W = 0; W < es; W += 1) eo(O, T, Y.children[W], ei[W]);
          (J.left = ee(ei, es)),
            (J.right = et(ei, es)),
            (J.nested = Z(ei, es)),
            (J.empty = er(ei, es)),
            (J.finite = en(ei, es)),
            (J.cyclic = X(ei, es));
        }
        function ei(O, T, L, J) {
          let W = 0,
            Y = T[L],
            Z = Y.children.length,
            X = [];
          for (W = 0; W < Z; W += 1) X.push(O.attrGen());
          for (W = 0; W < Z; W += 1) eo(O, T, Y.children[W], X[W]);
          for (
            W = 0,
              J.left = !1,
              J.right = !1,
              J.nested = !1,
              J.empty = !1,
              J.finite = !1,
              J.cyclic = !1;
            W < Z;
            W += 1
          )
            X[W].left && (J.left = !0),
              X[W].nested && (J.nested = !0),
              X[W].right && (J.right = !0),
              X[W].empty && (J.empty = !0),
              X[W].finite && (J.finite = !0),
              X[W].cyclic && (J.cyclic = !0);
        }
        function ea(O, T, L, J) {
          let W = T[L];
          W.index >= O.ruleCount
            ? ((J.empty = O.udts[W.index - O.ruleCount].empty), (J.finite = !0))
            : (ec(O, W.index, J),
              (J.left = !1),
              (J.nested = !1),
              (J.right = !1),
              (J.cyclic = !1));
        }
        function eo(T, L, J, W) {
          T.attrInit(W);
          let Y = L[J];
          switch (Y.type) {
            case O.ALT:
              ei(T, L, J, W);
              break;
            case O.CAT:
              es(T, L, J, W);
              break;
            case O.REP:
              eo(T, L, J + 1, W),
                0 === Y.min && ((W.empty = !0), (W.finite = !0));
              break;
            case O.RNM:
              ec(T, L[J].index, W);
              break;
            case O.BKR:
              ea(T, L, J, W);
              break;
            case O.AND:
            case O.NOT:
            case O.BKA:
            case O.BKN:
              eo(T, L, J + 1, W), (W.empty = !0);
              break;
            case O.TLS:
              (W.empty = !L[J].string.length), (W.finite = !0), (W.cyclic = !1);
              break;
            case O.TBS:
            case O.TRG:
              (W.empty = !1), (W.finite = !0), (W.cyclic = !1);
              break;
            case O.UDT:
              (W.empty = Y.empty), (W.finite = !0), (W.cyclic = !1);
              break;
            case O.ABG:
            case O.AEN:
              (W.empty = !0), (W.finite = !0), (W.cyclic = !1);
              break;
            default:
              throw Error(`unknown opcode type: ${Y}`);
          }
        }
        function ec(O, T, L) {
          let J = O.attrsWorking[T];
          J.isComplete
            ? O.attrCopy(L, J)
            : J.isOpen
            ? T === O.startRule
              ? T === O.startRule &&
                ((L.left = !0), (L.right = !0), (L.cyclic = !0), (L.leaf = !0))
              : (L.finite = !0)
            : ((J.isOpen = !0),
              eo(O, J.rule.opcodes, 0, L),
              (J.left = L.left),
              (J.right = L.right),
              (J.nested = L.nested),
              (J.empty = L.empty),
              (J.finite = L.finite),
              (J.cyclic = L.cyclic),
              (J.leaf = !1),
              (J.isOpen = !1),
              (J.isComplete = !0));
        }
        let eu = (O) => (O ? "t" : "f"),
          eh = (O) => (O ? "e" : "f"),
          ed = (O) => (O ? "t" : "e"),
          ep = (T, L, W, Y) =>
            `${T}:${L}:` +
            (`${eh(W.left)} ${eu(W.nested)} ${eu(W.right)} ${eh(W.cyclic)} ${ed(
              W.finite
            )} ${eu(W.empty)}:${J.typeToString(Y.recursiveType)}:` +
              (Y.recursiveType === O.ATTR_MR ? Y.groupNumber : "-")) +
            `:${W.rule.name}
`,
          eg = () =>
            "LEGEND - t=true, f=false, e=error\nsequence:rule index:left nested right cyclic finite empty:type:group number:rule name\n",
          ey = (O) => {
            let T = 0,
              L = 0,
              W = null,
              Y = null,
              Z = "",
              { ruleIndexes: X } = J;
            for (
              97 === O
                ? (X = J.ruleAlphaIndexes)
                : 116 === O && (X = J.ruleTypeIndexes),
                T = 0;
              T < J.ruleCount;
              T += 1
            )
              (L = X[T]),
                (W = J.attrs[L]),
                (Y = J.ruleDeps[L]),
                (Z += ep(T, L, W, Y));
            return Z;
          };
        return {
          ruleAttributes: (O) => {
            let T = 0,
              L = 0,
              W = (J = O).attrGen();
            for (T = 0; T < J.ruleCount; T += 1) {
              for (L = 0; L < J.ruleCount; L += 1)
                J.attrInit(J.attrsWorking[L]);
              (J.startRule = T),
                ec(J, T, W),
                J.attrCopy(J.attrs[T], J.attrsWorking[T]);
            }
            J.attributesComplete = !0;
            let Y = null;
            for (T = 0; T < J.ruleCount; T += 1)
              if ((Y = J.attrs[T]).left || !Y.finite || Y.cyclic) {
                let O = J.attrGen(Y.rule);
                J.attrCopy(O, Y),
                  J.attrsErrors.push(O),
                  (J.attrsErrorCount += 1);
              }
          },
          showAttributes: (O = "index") => {
            if (!J.attributesComplete)
              throw Error(`${T}:showAttributes: attributes not available`);
            let L = "",
              W = "RULE ATTRIBUTES\n";
            return (
              97 === O.charCodeAt(0)
                ? (L += "alphabetical by rule name\n" + W + eg() + ey(97))
                : 116 === O.charCodeAt(0)
                ? (L += "ordered by rule type\n" + W + eg() + ey(116))
                : (L += "ordered by rule index\n" + W + eg() + ey()),
              L
            );
          },
          showAttributeErrors: () => {
            let O = null,
              T = null,
              L = "";
            if (
              ((L += "RULE ATTRIBUTES WITH ERRORS\n" + eg()), J.attrsErrorCount)
            )
              for (let W = 0; W < J.attrsErrorCount; W += 1)
                (O = J.attrsErrors[W]),
                  (T = J.ruleDeps[O.rule.index]),
                  (L += ep(W, O.rule.index, O, T));
            else L += "<none>\n";
            return L;
          },
        };
      })();
    },
    80881: function (O, T, L) {
      O.exports = (() => {
        let O = L(47351),
          T = null,
          J = (T, L, W, Y) => {
            let Z = 0,
              X = 0,
              ee = L[W];
            Y[W] = !0;
            let et = ee.rule.opcodes;
            for (Z = 0; Z < et.length; Z += 1) {
              let W = et[Z];
              if (W.type === O.RNM)
                for (
                  ee.refersTo[W.index] = !0,
                    Y[W.index] || J(T, L, W.index, Y),
                    X = 0;
                  X < T;
                  X += 1
                )
                  L[W.index].refersTo[X] && (ee.refersTo[X] = !0);
              else
                W.type === O.UDT
                  ? (ee.refersToUdt[W.index] = !0)
                  : W.type !== O.BKR ||
                    (W.index < T
                      ? ((ee.refersTo[W.index] = !0),
                        Y[W.index] || J(T, L, W.index, Y))
                      : (ee.refersToUdt[T - W.index] = !0));
            }
          },
          W = (O = null) => {
            let L = 0,
              J = 0,
              W = 0,
              Y = 0,
              Z = T.ruleCount - 1,
              X = T.udtCount - 1,
              ee = 100,
              et = "",
              er = "",
              en = "=> ",
              es = "<= ",
              ei = !1,
              ea = null,
              { ruleIndexes: eo } = T,
              { udtIndexes: ec } = T;
            for (
              97 === O
                ? ((eo = T.ruleAlphaIndexes), (ec = T.udtAlphaIndexes))
                : 116 === O &&
                  ((eo = T.ruleTypeIndexes), (ec = T.udtAlphaIndexes)),
                L = 0;
              L < T.ruleCount;
              L += 1
            ) {
              for (
                ea = T.ruleDeps[eo[L]],
                  er = `${eo[L]}:${T.typeToString(ea.recursiveType)}:`,
                  T.isMutuallyRecursive &&
                    (er += (ea.groupNumber > -1 ? ea.groupNumber : "-") + ":"),
                  er += " ",
                  et += `${er + T.rules[eo[L]].name}
`,
                  ei = !0,
                  W = 0,
                  Y = et.length,
                  et += er,
                  J = 0;
                J < T.ruleCount;
                J += 1
              )
                ea.refersTo[eo[J]] &&
                  (ei
                    ? ((ei = !1), (et += en + T.ruleDeps[eo[J]].rule.name))
                    : (et += `, ${T.ruleDeps[eo[J]].rule.name}`),
                  (W += 1)),
                  et.length - Y > ee &&
                    J !== Z &&
                    ((et += `
${er}${en}`),
                    (Y = et.length));
              if (T.udtCount)
                for (J = 0; J < T.udtCount; J += 1)
                  ea.refersToUdt[ec[J]] &&
                    (ei
                      ? ((ei = !1), (et += en + T.udts[ec[J]].name))
                      : (et += `, ${T.udts[ec[J]].name}`),
                    (W += 1)),
                    et.length - Y > ee &&
                      J !== X &&
                      ((et += `
${er}${en}`),
                      (Y = et.length));
              for (
                0 === W && (et += "=> <none>\n"),
                  !1 === ei && (et += "\n"),
                  ei = !0,
                  W = 0,
                  Y = et.length,
                  et += er,
                  J = 0;
                J < T.ruleCount;
                J += 1
              )
                ea.referencedBy[eo[J]] &&
                  (ei
                    ? ((ei = !1), (et += es + T.ruleDeps[eo[J]].rule.name))
                    : (et += `, ${T.ruleDeps[eo[J]].rule.name}`),
                  (W += 1)),
                  et.length - Y > ee &&
                    J !== Z &&
                    ((et += `
${er}${en}`),
                    (Y = et.length));
              0 === W && (et += "<= <none>\n"),
                !1 === ei && (et += "\n"),
                (et += "\n");
            }
            return et;
          };
        return {
          ruleDependencies: (L) => {
            let W = 0,
              Y = 0,
              Z = 0,
              X = null,
              ee = null,
              et = !1;
            (T = L).dependenciesComplete = !1;
            let er = T.falseArray(T.ruleCount);
            for (W = 0; W < T.ruleCount; W += 1)
              T.falsifyArray(er), J(T.ruleCount, T.ruleDeps, W, er);
            for (W = 0; W < T.ruleCount; W += 1)
              for (Y = 0; Y < T.ruleCount; Y += 1)
                W !== Y &&
                  T.ruleDeps[Y].refersTo[W] &&
                  (T.ruleDeps[W].referencedBy[Y] = !0);
            for (W = 0; W < T.ruleCount; W += 1)
              (T.ruleDeps[W].recursiveType = O.ATTR_N),
                T.ruleDeps[W].refersTo[W] &&
                  (T.ruleDeps[W].recursiveType = O.ATTR_R);
            for (W = 0, Z = -1; W < T.ruleCount; W += 1)
              if ((X = T.ruleDeps[W]).recursiveType === O.ATTR_R)
                for (Y = 0, et = !0; Y < T.ruleCount; Y += 1)
                  W !== Y &&
                    (ee = T.ruleDeps[Y]).recursiveType === O.ATTR_R &&
                    X.refersTo[Y] &&
                    ee.refersTo[W] &&
                    (et &&
                      ((Z += 1),
                      (X.recursiveType = O.ATTR_MR),
                      (X.groupNumber = Z),
                      (et = !1)),
                    (ee.recursiveType = O.ATTR_MR),
                    (ee.groupNumber = Z));
            (T.isMutuallyRecursive = Z > -1),
              T.ruleAlphaIndexes.sort(T.compRulesAlpha),
              T.ruleTypeIndexes.sort(T.compRulesAlpha),
              T.ruleTypeIndexes.sort(T.compRulesType),
              T.isMutuallyRecursive && T.ruleTypeIndexes.sort(T.compRulesGroup),
              T.udtCount && T.udtAlphaIndexes.sort(T.compUdtsAlpha),
              (T.dependenciesComplete = !0);
          },
          showRuleDependencies: (O = "index") => {
            let L = "RULE DEPENDENCIES(index:type:[group number:])\n";
            return (
              (L += "=> refers to rule names\n<= referenced by rule names\n"),
              T.dependenciesComplete &&
                (97 === O.charCodeAt(0)
                  ? (L += "alphabetical by rule name\n" + W(97))
                  : 116 === O.charCodeAt(0)
                  ? (L += "ordered by rule type\n" + W(116))
                  : (L += "ordered by rule index\n" + W(null))),
              L
            );
          },
        };
      })();
    },
    37177: function (O) {
      O.exports = function () {
        (this.grammarObject = "grammarObject"),
          (this.rules = []),
          (this.rules[0] = {
            name: "File",
            lower: "file",
            index: 0,
            isBkr: !1,
          }),
          (this.rules[1] = {
            name: "BlankLine",
            lower: "blankline",
            index: 1,
            isBkr: !1,
          }),
          (this.rules[2] = {
            name: "Rule",
            lower: "rule",
            index: 2,
            isBkr: !1,
          }),
          (this.rules[3] = {
            name: "RuleLookup",
            lower: "rulelookup",
            index: 3,
            isBkr: !1,
          }),
          (this.rules[4] = {
            name: "RuleNameTest",
            lower: "rulenametest",
            index: 4,
            isBkr: !1,
          }),
          (this.rules[5] = {
            name: "RuleName",
            lower: "rulename",
            index: 5,
            isBkr: !1,
          }),
          (this.rules[6] = {
            name: "RuleNameError",
            lower: "rulenameerror",
            index: 6,
            isBkr: !1,
          }),
          (this.rules[7] = {
            name: "DefinedAsTest",
            lower: "definedastest",
            index: 7,
            isBkr: !1,
          }),
          (this.rules[8] = {
            name: "DefinedAsError",
            lower: "definedaserror",
            index: 8,
            isBkr: !1,
          }),
          (this.rules[9] = {
            name: "DefinedAs",
            lower: "definedas",
            index: 9,
            isBkr: !1,
          }),
          (this.rules[10] = {
            name: "Defined",
            lower: "defined",
            index: 10,
            isBkr: !1,
          }),
          (this.rules[11] = {
            name: "IncAlt",
            lower: "incalt",
            index: 11,
            isBkr: !1,
          }),
          (this.rules[12] = {
            name: "RuleError",
            lower: "ruleerror",
            index: 12,
            isBkr: !1,
          }),
          (this.rules[13] = {
            name: "LineEndError",
            lower: "lineenderror",
            index: 13,
            isBkr: !1,
          }),
          (this.rules[14] = {
            name: "Alternation",
            lower: "alternation",
            index: 14,
            isBkr: !1,
          }),
          (this.rules[15] = {
            name: "Concatenation",
            lower: "concatenation",
            index: 15,
            isBkr: !1,
          }),
          (this.rules[16] = {
            name: "Repetition",
            lower: "repetition",
            index: 16,
            isBkr: !1,
          }),
          (this.rules[17] = {
            name: "Modifier",
            lower: "modifier",
            index: 17,
            isBkr: !1,
          }),
          (this.rules[18] = {
            name: "Predicate",
            lower: "predicate",
            index: 18,
            isBkr: !1,
          }),
          (this.rules[19] = {
            name: "BasicElement",
            lower: "basicelement",
            index: 19,
            isBkr: !1,
          }),
          (this.rules[20] = {
            name: "BasicElementErr",
            lower: "basicelementerr",
            index: 20,
            isBkr: !1,
          }),
          (this.rules[21] = {
            name: "Group",
            lower: "group",
            index: 21,
            isBkr: !1,
          }),
          (this.rules[22] = {
            name: "GroupError",
            lower: "grouperror",
            index: 22,
            isBkr: !1,
          }),
          (this.rules[23] = {
            name: "GroupOpen",
            lower: "groupopen",
            index: 23,
            isBkr: !1,
          }),
          (this.rules[24] = {
            name: "GroupClose",
            lower: "groupclose",
            index: 24,
            isBkr: !1,
          }),
          (this.rules[25] = {
            name: "Option",
            lower: "option",
            index: 25,
            isBkr: !1,
          }),
          (this.rules[26] = {
            name: "OptionError",
            lower: "optionerror",
            index: 26,
            isBkr: !1,
          }),
          (this.rules[27] = {
            name: "OptionOpen",
            lower: "optionopen",
            index: 27,
            isBkr: !1,
          }),
          (this.rules[28] = {
            name: "OptionClose",
            lower: "optionclose",
            index: 28,
            isBkr: !1,
          }),
          (this.rules[29] = {
            name: "RnmOp",
            lower: "rnmop",
            index: 29,
            isBkr: !1,
          }),
          (this.rules[30] = {
            name: "BkrOp",
            lower: "bkrop",
            index: 30,
            isBkr: !1,
          }),
          (this.rules[31] = {
            name: "bkrModifier",
            lower: "bkrmodifier",
            index: 31,
            isBkr: !1,
          }),
          (this.rules[32] = { name: "cs", lower: "cs", index: 32, isBkr: !1 }),
          (this.rules[33] = { name: "ci", lower: "ci", index: 33, isBkr: !1 }),
          (this.rules[34] = { name: "um", lower: "um", index: 34, isBkr: !1 }),
          (this.rules[35] = { name: "pm", lower: "pm", index: 35, isBkr: !1 }),
          (this.rules[36] = {
            name: "bkr-name",
            lower: "bkr-name",
            index: 36,
            isBkr: !1,
          }),
          (this.rules[37] = {
            name: "rname",
            lower: "rname",
            index: 37,
            isBkr: !1,
          }),
          (this.rules[38] = {
            name: "uname",
            lower: "uname",
            index: 38,
            isBkr: !1,
          }),
          (this.rules[39] = {
            name: "ename",
            lower: "ename",
            index: 39,
            isBkr: !1,
          }),
          (this.rules[40] = {
            name: "UdtOp",
            lower: "udtop",
            index: 40,
            isBkr: !1,
          }),
          (this.rules[41] = {
            name: "udt-non-empty",
            lower: "udt-non-empty",
            index: 41,
            isBkr: !1,
          }),
          (this.rules[42] = {
            name: "udt-empty",
            lower: "udt-empty",
            index: 42,
            isBkr: !1,
          }),
          (this.rules[43] = {
            name: "RepOp",
            lower: "repop",
            index: 43,
            isBkr: !1,
          }),
          (this.rules[44] = {
            name: "AltOp",
            lower: "altop",
            index: 44,
            isBkr: !1,
          }),
          (this.rules[45] = {
            name: "CatOp",
            lower: "catop",
            index: 45,
            isBkr: !1,
          }),
          (this.rules[46] = {
            name: "StarOp",
            lower: "starop",
            index: 46,
            isBkr: !1,
          }),
          (this.rules[47] = {
            name: "AndOp",
            lower: "andop",
            index: 47,
            isBkr: !1,
          }),
          (this.rules[48] = {
            name: "NotOp",
            lower: "notop",
            index: 48,
            isBkr: !1,
          }),
          (this.rules[49] = {
            name: "BkaOp",
            lower: "bkaop",
            index: 49,
            isBkr: !1,
          }),
          (this.rules[50] = {
            name: "BknOp",
            lower: "bknop",
            index: 50,
            isBkr: !1,
          }),
          (this.rules[51] = {
            name: "AbgOp",
            lower: "abgop",
            index: 51,
            isBkr: !1,
          }),
          (this.rules[52] = {
            name: "AenOp",
            lower: "aenop",
            index: 52,
            isBkr: !1,
          }),
          (this.rules[53] = {
            name: "TrgOp",
            lower: "trgop",
            index: 53,
            isBkr: !1,
          }),
          (this.rules[54] = {
            name: "TbsOp",
            lower: "tbsop",
            index: 54,
            isBkr: !1,
          }),
          (this.rules[55] = {
            name: "TlsOp",
            lower: "tlsop",
            index: 55,
            isBkr: !1,
          }),
          (this.rules[56] = {
            name: "TlsCase",
            lower: "tlscase",
            index: 56,
            isBkr: !1,
          }),
          (this.rules[57] = {
            name: "TlsOpen",
            lower: "tlsopen",
            index: 57,
            isBkr: !1,
          }),
          (this.rules[58] = {
            name: "TlsClose",
            lower: "tlsclose",
            index: 58,
            isBkr: !1,
          }),
          (this.rules[59] = {
            name: "TlsString",
            lower: "tlsstring",
            index: 59,
            isBkr: !1,
          }),
          (this.rules[60] = {
            name: "StringTab",
            lower: "stringtab",
            index: 60,
            isBkr: !1,
          }),
          (this.rules[61] = {
            name: "ClsOp",
            lower: "clsop",
            index: 61,
            isBkr: !1,
          }),
          (this.rules[62] = {
            name: "ClsOpen",
            lower: "clsopen",
            index: 62,
            isBkr: !1,
          }),
          (this.rules[63] = {
            name: "ClsClose",
            lower: "clsclose",
            index: 63,
            isBkr: !1,
          }),
          (this.rules[64] = {
            name: "ClsString",
            lower: "clsstring",
            index: 64,
            isBkr: !1,
          }),
          (this.rules[65] = {
            name: "ProsVal",
            lower: "prosval",
            index: 65,
            isBkr: !1,
          }),
          (this.rules[66] = {
            name: "ProsValOpen",
            lower: "prosvalopen",
            index: 66,
            isBkr: !1,
          }),
          (this.rules[67] = {
            name: "ProsValString",
            lower: "prosvalstring",
            index: 67,
            isBkr: !1,
          }),
          (this.rules[68] = {
            name: "ProsValClose",
            lower: "prosvalclose",
            index: 68,
            isBkr: !1,
          }),
          (this.rules[69] = {
            name: "rep-min",
            lower: "rep-min",
            index: 69,
            isBkr: !1,
          }),
          (this.rules[70] = {
            name: "rep-min-max",
            lower: "rep-min-max",
            index: 70,
            isBkr: !1,
          }),
          (this.rules[71] = {
            name: "rep-max",
            lower: "rep-max",
            index: 71,
            isBkr: !1,
          }),
          (this.rules[72] = {
            name: "rep-num",
            lower: "rep-num",
            index: 72,
            isBkr: !1,
          }),
          (this.rules[73] = {
            name: "dString",
            lower: "dstring",
            index: 73,
            isBkr: !1,
          }),
          (this.rules[74] = {
            name: "xString",
            lower: "xstring",
            index: 74,
            isBkr: !1,
          }),
          (this.rules[75] = {
            name: "bString",
            lower: "bstring",
            index: 75,
            isBkr: !1,
          }),
          (this.rules[76] = {
            name: "Dec",
            lower: "dec",
            index: 76,
            isBkr: !1,
          }),
          (this.rules[77] = {
            name: "Hex",
            lower: "hex",
            index: 77,
            isBkr: !1,
          }),
          (this.rules[78] = {
            name: "Bin",
            lower: "bin",
            index: 78,
            isBkr: !1,
          }),
          (this.rules[79] = {
            name: "dmin",
            lower: "dmin",
            index: 79,
            isBkr: !1,
          }),
          (this.rules[80] = {
            name: "dmax",
            lower: "dmax",
            index: 80,
            isBkr: !1,
          }),
          (this.rules[81] = {
            name: "bmin",
            lower: "bmin",
            index: 81,
            isBkr: !1,
          }),
          (this.rules[82] = {
            name: "bmax",
            lower: "bmax",
            index: 82,
            isBkr: !1,
          }),
          (this.rules[83] = {
            name: "xmin",
            lower: "xmin",
            index: 83,
            isBkr: !1,
          }),
          (this.rules[84] = {
            name: "xmax",
            lower: "xmax",
            index: 84,
            isBkr: !1,
          }),
          (this.rules[85] = {
            name: "dnum",
            lower: "dnum",
            index: 85,
            isBkr: !1,
          }),
          (this.rules[86] = {
            name: "bnum",
            lower: "bnum",
            index: 86,
            isBkr: !1,
          }),
          (this.rules[87] = {
            name: "xnum",
            lower: "xnum",
            index: 87,
            isBkr: !1,
          }),
          (this.rules[88] = {
            name: "alphanum",
            lower: "alphanum",
            index: 88,
            isBkr: !1,
          }),
          (this.rules[89] = {
            name: "owsp",
            lower: "owsp",
            index: 89,
            isBkr: !1,
          }),
          (this.rules[90] = {
            name: "wsp",
            lower: "wsp",
            index: 90,
            isBkr: !1,
          }),
          (this.rules[91] = {
            name: "space",
            lower: "space",
            index: 91,
            isBkr: !1,
          }),
          (this.rules[92] = {
            name: "comment",
            lower: "comment",
            index: 92,
            isBkr: !1,
          }),
          (this.rules[93] = {
            name: "LineEnd",
            lower: "lineend",
            index: 93,
            isBkr: !1,
          }),
          (this.rules[94] = {
            name: "LineContinue",
            lower: "linecontinue",
            index: 94,
            isBkr: !1,
          }),
          (this.udts = []),
          (this.rules[0].opcodes = []),
          (this.rules[0].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[0].opcodes[1] = { type: 1, children: [2, 3, 4] }),
          (this.rules[0].opcodes[2] = { type: 4, index: 1 }),
          (this.rules[0].opcodes[3] = { type: 4, index: 2 }),
          (this.rules[0].opcodes[4] = { type: 4, index: 12 }),
          (this.rules[1].opcodes = []),
          (this.rules[1].opcodes[0] = { type: 2, children: [1, 5, 7] }),
          (this.rules[1].opcodes[1] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[1].opcodes[2] = { type: 1, children: [3, 4] }),
          (this.rules[1].opcodes[3] = { type: 6, string: [32] }),
          (this.rules[1].opcodes[4] = { type: 6, string: [9] }),
          (this.rules[1].opcodes[5] = { type: 3, min: 0, max: 1 }),
          (this.rules[1].opcodes[6] = { type: 4, index: 92 }),
          (this.rules[1].opcodes[7] = { type: 4, index: 93 }),
          (this.rules[2].opcodes = []),
          (this.rules[2].opcodes[0] = { type: 2, children: [1, 2, 3, 4] }),
          (this.rules[2].opcodes[1] = { type: 4, index: 3 }),
          (this.rules[2].opcodes[2] = { type: 4, index: 89 }),
          (this.rules[2].opcodes[3] = { type: 4, index: 14 }),
          (this.rules[2].opcodes[4] = { type: 1, children: [5, 8] }),
          (this.rules[2].opcodes[5] = { type: 2, children: [6, 7] }),
          (this.rules[2].opcodes[6] = { type: 4, index: 89 }),
          (this.rules[2].opcodes[7] = { type: 4, index: 93 }),
          (this.rules[2].opcodes[8] = { type: 2, children: [9, 10] }),
          (this.rules[2].opcodes[9] = { type: 4, index: 13 }),
          (this.rules[2].opcodes[10] = { type: 4, index: 93 }),
          (this.rules[3].opcodes = []),
          (this.rules[3].opcodes[0] = { type: 2, children: [1, 2, 3] }),
          (this.rules[3].opcodes[1] = { type: 4, index: 4 }),
          (this.rules[3].opcodes[2] = { type: 4, index: 89 }),
          (this.rules[3].opcodes[3] = { type: 4, index: 7 }),
          (this.rules[4].opcodes = []),
          (this.rules[4].opcodes[0] = { type: 1, children: [1, 2] }),
          (this.rules[4].opcodes[1] = { type: 4, index: 5 }),
          (this.rules[4].opcodes[2] = { type: 4, index: 6 }),
          (this.rules[5].opcodes = []),
          (this.rules[5].opcodes[0] = { type: 4, index: 88 }),
          (this.rules[6].opcodes = []),
          (this.rules[6].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[6].opcodes[1] = { type: 1, children: [2, 3] }),
          (this.rules[6].opcodes[2] = { type: 5, min: 33, max: 60 }),
          (this.rules[6].opcodes[3] = { type: 5, min: 62, max: 126 }),
          (this.rules[7].opcodes = []),
          (this.rules[7].opcodes[0] = { type: 1, children: [1, 2] }),
          (this.rules[7].opcodes[1] = { type: 4, index: 9 }),
          (this.rules[7].opcodes[2] = { type: 4, index: 8 }),
          (this.rules[8].opcodes = []),
          (this.rules[8].opcodes[0] = { type: 3, min: 1, max: 2 }),
          (this.rules[8].opcodes[1] = { type: 5, min: 33, max: 126 }),
          (this.rules[9].opcodes = []),
          (this.rules[9].opcodes[0] = { type: 1, children: [1, 2] }),
          (this.rules[9].opcodes[1] = { type: 4, index: 11 }),
          (this.rules[9].opcodes[2] = { type: 4, index: 10 }),
          (this.rules[10].opcodes = []),
          (this.rules[10].opcodes[0] = { type: 6, string: [61] }),
          (this.rules[11].opcodes = []),
          (this.rules[11].opcodes[0] = { type: 6, string: [61, 47] }),
          (this.rules[12].opcodes = []),
          (this.rules[12].opcodes[0] = { type: 2, children: [1, 6] }),
          (this.rules[12].opcodes[1] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[12].opcodes[2] = { type: 1, children: [3, 4, 5] }),
          (this.rules[12].opcodes[3] = { type: 5, min: 32, max: 126 }),
          (this.rules[12].opcodes[4] = { type: 6, string: [9] }),
          (this.rules[12].opcodes[5] = { type: 4, index: 94 }),
          (this.rules[12].opcodes[6] = { type: 4, index: 93 }),
          (this.rules[13].opcodes = []),
          (this.rules[13].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[13].opcodes[1] = { type: 1, children: [2, 3, 4] }),
          (this.rules[13].opcodes[2] = { type: 5, min: 32, max: 126 }),
          (this.rules[13].opcodes[3] = { type: 6, string: [9] }),
          (this.rules[13].opcodes[4] = { type: 4, index: 94 }),
          (this.rules[14].opcodes = []),
          (this.rules[14].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[14].opcodes[1] = { type: 4, index: 15 }),
          (this.rules[14].opcodes[2] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[14].opcodes[3] = { type: 2, children: [4, 5, 6] }),
          (this.rules[14].opcodes[4] = { type: 4, index: 89 }),
          (this.rules[14].opcodes[5] = { type: 4, index: 44 }),
          (this.rules[14].opcodes[6] = { type: 4, index: 15 }),
          (this.rules[15].opcodes = []),
          (this.rules[15].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[15].opcodes[1] = { type: 4, index: 16 }),
          (this.rules[15].opcodes[2] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[15].opcodes[3] = { type: 2, children: [4, 5] }),
          (this.rules[15].opcodes[4] = { type: 4, index: 45 }),
          (this.rules[15].opcodes[5] = { type: 4, index: 16 }),
          (this.rules[16].opcodes = []),
          (this.rules[16].opcodes[0] = { type: 2, children: [1, 3] }),
          (this.rules[16].opcodes[1] = { type: 3, min: 0, max: 1 }),
          (this.rules[16].opcodes[2] = { type: 4, index: 17 }),
          (this.rules[16].opcodes[3] = { type: 1, children: [4, 5, 6, 7] }),
          (this.rules[16].opcodes[4] = { type: 4, index: 21 }),
          (this.rules[16].opcodes[5] = { type: 4, index: 25 }),
          (this.rules[16].opcodes[6] = { type: 4, index: 19 }),
          (this.rules[16].opcodes[7] = { type: 4, index: 20 }),
          (this.rules[17].opcodes = []),
          (this.rules[17].opcodes[0] = { type: 1, children: [1, 5] }),
          (this.rules[17].opcodes[1] = { type: 2, children: [2, 3] }),
          (this.rules[17].opcodes[2] = { type: 4, index: 18 }),
          (this.rules[17].opcodes[3] = { type: 3, min: 0, max: 1 }),
          (this.rules[17].opcodes[4] = { type: 4, index: 43 }),
          (this.rules[17].opcodes[5] = { type: 4, index: 43 }),
          (this.rules[18].opcodes = []),
          (this.rules[18].opcodes[0] = { type: 1, children: [1, 2, 3, 4] }),
          (this.rules[18].opcodes[1] = { type: 4, index: 49 }),
          (this.rules[18].opcodes[2] = { type: 4, index: 50 }),
          (this.rules[18].opcodes[3] = { type: 4, index: 47 }),
          (this.rules[18].opcodes[4] = { type: 4, index: 48 }),
          (this.rules[19].opcodes = []),
          (this.rules[19].opcodes[0] = {
            type: 1,
            children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
          }),
          (this.rules[19].opcodes[1] = { type: 4, index: 40 }),
          (this.rules[19].opcodes[2] = { type: 4, index: 29 }),
          (this.rules[19].opcodes[3] = { type: 4, index: 53 }),
          (this.rules[19].opcodes[4] = { type: 4, index: 54 }),
          (this.rules[19].opcodes[5] = { type: 4, index: 55 }),
          (this.rules[19].opcodes[6] = { type: 4, index: 61 }),
          (this.rules[19].opcodes[7] = { type: 4, index: 30 }),
          (this.rules[19].opcodes[8] = { type: 4, index: 51 }),
          (this.rules[19].opcodes[9] = { type: 4, index: 52 }),
          (this.rules[19].opcodes[10] = { type: 4, index: 65 }),
          (this.rules[20].opcodes = []),
          (this.rules[20].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[20].opcodes[1] = { type: 1, children: [2, 3, 4, 5] }),
          (this.rules[20].opcodes[2] = { type: 5, min: 33, max: 40 }),
          (this.rules[20].opcodes[3] = { type: 5, min: 42, max: 46 }),
          (this.rules[20].opcodes[4] = { type: 5, min: 48, max: 92 }),
          (this.rules[20].opcodes[5] = { type: 5, min: 94, max: 126 }),
          (this.rules[21].opcodes = []),
          (this.rules[21].opcodes[0] = { type: 2, children: [1, 2, 3] }),
          (this.rules[21].opcodes[1] = { type: 4, index: 23 }),
          (this.rules[21].opcodes[2] = { type: 4, index: 14 }),
          (this.rules[21].opcodes[3] = { type: 1, children: [4, 5] }),
          (this.rules[21].opcodes[4] = { type: 4, index: 24 }),
          (this.rules[21].opcodes[5] = { type: 4, index: 22 }),
          (this.rules[22].opcodes = []),
          (this.rules[22].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[22].opcodes[1] = { type: 1, children: [2, 3, 4, 5] }),
          (this.rules[22].opcodes[2] = { type: 5, min: 33, max: 40 }),
          (this.rules[22].opcodes[3] = { type: 5, min: 42, max: 46 }),
          (this.rules[22].opcodes[4] = { type: 5, min: 48, max: 92 }),
          (this.rules[22].opcodes[5] = { type: 5, min: 94, max: 126 }),
          (this.rules[23].opcodes = []),
          (this.rules[23].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[23].opcodes[1] = { type: 6, string: [40] }),
          (this.rules[23].opcodes[2] = { type: 4, index: 89 }),
          (this.rules[24].opcodes = []),
          (this.rules[24].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[24].opcodes[1] = { type: 4, index: 89 }),
          (this.rules[24].opcodes[2] = { type: 6, string: [41] }),
          (this.rules[25].opcodes = []),
          (this.rules[25].opcodes[0] = { type: 2, children: [1, 2, 3] }),
          (this.rules[25].opcodes[1] = { type: 4, index: 27 }),
          (this.rules[25].opcodes[2] = { type: 4, index: 14 }),
          (this.rules[25].opcodes[3] = { type: 1, children: [4, 5] }),
          (this.rules[25].opcodes[4] = { type: 4, index: 28 }),
          (this.rules[25].opcodes[5] = { type: 4, index: 26 }),
          (this.rules[26].opcodes = []),
          (this.rules[26].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[26].opcodes[1] = { type: 1, children: [2, 3, 4, 5] }),
          (this.rules[26].opcodes[2] = { type: 5, min: 33, max: 40 }),
          (this.rules[26].opcodes[3] = { type: 5, min: 42, max: 46 }),
          (this.rules[26].opcodes[4] = { type: 5, min: 48, max: 92 }),
          (this.rules[26].opcodes[5] = { type: 5, min: 94, max: 126 }),
          (this.rules[27].opcodes = []),
          (this.rules[27].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[27].opcodes[1] = { type: 6, string: [91] }),
          (this.rules[27].opcodes[2] = { type: 4, index: 89 }),
          (this.rules[28].opcodes = []),
          (this.rules[28].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[28].opcodes[1] = { type: 4, index: 89 }),
          (this.rules[28].opcodes[2] = { type: 6, string: [93] }),
          (this.rules[29].opcodes = []),
          (this.rules[29].opcodes[0] = { type: 4, index: 88 }),
          (this.rules[30].opcodes = []),
          (this.rules[30].opcodes[0] = { type: 2, children: [1, 2, 4] }),
          (this.rules[30].opcodes[1] = { type: 6, string: [92] }),
          (this.rules[30].opcodes[2] = { type: 3, min: 0, max: 1 }),
          (this.rules[30].opcodes[3] = { type: 4, index: 31 }),
          (this.rules[30].opcodes[4] = { type: 4, index: 36 }),
          (this.rules[31].opcodes = []),
          (this.rules[31].opcodes[0] = { type: 1, children: [1, 7, 13, 19] }),
          (this.rules[31].opcodes[1] = { type: 2, children: [2, 3] }),
          (this.rules[31].opcodes[2] = { type: 4, index: 32 }),
          (this.rules[31].opcodes[3] = { type: 3, min: 0, max: 1 }),
          (this.rules[31].opcodes[4] = { type: 1, children: [5, 6] }),
          (this.rules[31].opcodes[5] = { type: 4, index: 34 }),
          (this.rules[31].opcodes[6] = { type: 4, index: 35 }),
          (this.rules[31].opcodes[7] = { type: 2, children: [8, 9] }),
          (this.rules[31].opcodes[8] = { type: 4, index: 33 }),
          (this.rules[31].opcodes[9] = { type: 3, min: 0, max: 1 }),
          (this.rules[31].opcodes[10] = { type: 1, children: [11, 12] }),
          (this.rules[31].opcodes[11] = { type: 4, index: 34 }),
          (this.rules[31].opcodes[12] = { type: 4, index: 35 }),
          (this.rules[31].opcodes[13] = { type: 2, children: [14, 15] }),
          (this.rules[31].opcodes[14] = { type: 4, index: 34 }),
          (this.rules[31].opcodes[15] = { type: 3, min: 0, max: 1 }),
          (this.rules[31].opcodes[16] = { type: 1, children: [17, 18] }),
          (this.rules[31].opcodes[17] = { type: 4, index: 32 }),
          (this.rules[31].opcodes[18] = { type: 4, index: 33 }),
          (this.rules[31].opcodes[19] = { type: 2, children: [20, 21] }),
          (this.rules[31].opcodes[20] = { type: 4, index: 35 }),
          (this.rules[31].opcodes[21] = { type: 3, min: 0, max: 1 }),
          (this.rules[31].opcodes[22] = { type: 1, children: [23, 24] }),
          (this.rules[31].opcodes[23] = { type: 4, index: 32 }),
          (this.rules[31].opcodes[24] = { type: 4, index: 33 }),
          (this.rules[32].opcodes = []),
          (this.rules[32].opcodes[0] = { type: 6, string: [37, 115] }),
          (this.rules[33].opcodes = []),
          (this.rules[33].opcodes[0] = { type: 6, string: [37, 105] }),
          (this.rules[34].opcodes = []),
          (this.rules[34].opcodes[0] = { type: 6, string: [37, 117] }),
          (this.rules[35].opcodes = []),
          (this.rules[35].opcodes[0] = { type: 6, string: [37, 112] }),
          (this.rules[36].opcodes = []),
          (this.rules[36].opcodes[0] = { type: 1, children: [1, 2, 3] }),
          (this.rules[36].opcodes[1] = { type: 4, index: 38 }),
          (this.rules[36].opcodes[2] = { type: 4, index: 39 }),
          (this.rules[36].opcodes[3] = { type: 4, index: 37 }),
          (this.rules[37].opcodes = []),
          (this.rules[37].opcodes[0] = { type: 4, index: 88 }),
          (this.rules[38].opcodes = []),
          (this.rules[38].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[38].opcodes[1] = { type: 6, string: [117, 95] }),
          (this.rules[38].opcodes[2] = { type: 4, index: 88 }),
          (this.rules[39].opcodes = []),
          (this.rules[39].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[39].opcodes[1] = { type: 6, string: [101, 95] }),
          (this.rules[39].opcodes[2] = { type: 4, index: 88 }),
          (this.rules[40].opcodes = []),
          (this.rules[40].opcodes[0] = { type: 1, children: [1, 2] }),
          (this.rules[40].opcodes[1] = { type: 4, index: 42 }),
          (this.rules[40].opcodes[2] = { type: 4, index: 41 }),
          (this.rules[41].opcodes = []),
          (this.rules[41].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[41].opcodes[1] = { type: 6, string: [117, 95] }),
          (this.rules[41].opcodes[2] = { type: 4, index: 88 }),
          (this.rules[42].opcodes = []),
          (this.rules[42].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[42].opcodes[1] = { type: 6, string: [101, 95] }),
          (this.rules[42].opcodes[2] = { type: 4, index: 88 }),
          (this.rules[43].opcodes = []),
          (this.rules[43].opcodes[0] = {
            type: 1,
            children: [1, 5, 8, 11, 12],
          }),
          (this.rules[43].opcodes[1] = { type: 2, children: [2, 3, 4] }),
          (this.rules[43].opcodes[2] = { type: 4, index: 69 }),
          (this.rules[43].opcodes[3] = { type: 4, index: 46 }),
          (this.rules[43].opcodes[4] = { type: 4, index: 71 }),
          (this.rules[43].opcodes[5] = { type: 2, children: [6, 7] }),
          (this.rules[43].opcodes[6] = { type: 4, index: 69 }),
          (this.rules[43].opcodes[7] = { type: 4, index: 46 }),
          (this.rules[43].opcodes[8] = { type: 2, children: [9, 10] }),
          (this.rules[43].opcodes[9] = { type: 4, index: 46 }),
          (this.rules[43].opcodes[10] = { type: 4, index: 71 }),
          (this.rules[43].opcodes[11] = { type: 4, index: 46 }),
          (this.rules[43].opcodes[12] = { type: 4, index: 70 }),
          (this.rules[44].opcodes = []),
          (this.rules[44].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[44].opcodes[1] = { type: 6, string: [47] }),
          (this.rules[44].opcodes[2] = { type: 4, index: 89 }),
          (this.rules[45].opcodes = []),
          (this.rules[45].opcodes[0] = { type: 4, index: 90 }),
          (this.rules[46].opcodes = []),
          (this.rules[46].opcodes[0] = { type: 6, string: [42] }),
          (this.rules[47].opcodes = []),
          (this.rules[47].opcodes[0] = { type: 6, string: [38] }),
          (this.rules[48].opcodes = []),
          (this.rules[48].opcodes[0] = { type: 6, string: [33] }),
          (this.rules[49].opcodes = []),
          (this.rules[49].opcodes[0] = { type: 6, string: [38, 38] }),
          (this.rules[50].opcodes = []),
          (this.rules[50].opcodes[0] = { type: 6, string: [33, 33] }),
          (this.rules[51].opcodes = []),
          (this.rules[51].opcodes[0] = { type: 6, string: [37, 94] }),
          (this.rules[52].opcodes = []),
          (this.rules[52].opcodes[0] = { type: 6, string: [37, 36] }),
          (this.rules[53].opcodes = []),
          (this.rules[53].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[53].opcodes[1] = { type: 6, string: [37] }),
          (this.rules[53].opcodes[2] = { type: 1, children: [3, 8, 13] }),
          (this.rules[53].opcodes[3] = { type: 2, children: [4, 5, 6, 7] }),
          (this.rules[53].opcodes[4] = { type: 4, index: 76 }),
          (this.rules[53].opcodes[5] = { type: 4, index: 79 }),
          (this.rules[53].opcodes[6] = { type: 6, string: [45] }),
          (this.rules[53].opcodes[7] = { type: 4, index: 80 }),
          (this.rules[53].opcodes[8] = { type: 2, children: [9, 10, 11, 12] }),
          (this.rules[53].opcodes[9] = { type: 4, index: 77 }),
          (this.rules[53].opcodes[10] = { type: 4, index: 83 }),
          (this.rules[53].opcodes[11] = { type: 6, string: [45] }),
          (this.rules[53].opcodes[12] = { type: 4, index: 84 }),
          (this.rules[53].opcodes[13] = {
            type: 2,
            children: [14, 15, 16, 17],
          }),
          (this.rules[53].opcodes[14] = { type: 4, index: 78 }),
          (this.rules[53].opcodes[15] = { type: 4, index: 81 }),
          (this.rules[53].opcodes[16] = { type: 6, string: [45] }),
          (this.rules[53].opcodes[17] = { type: 4, index: 82 }),
          (this.rules[54].opcodes = []),
          (this.rules[54].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[54].opcodes[1] = { type: 6, string: [37] }),
          (this.rules[54].opcodes[2] = { type: 1, children: [3, 10, 17] }),
          (this.rules[54].opcodes[3] = { type: 2, children: [4, 5, 6] }),
          (this.rules[54].opcodes[4] = { type: 4, index: 76 }),
          (this.rules[54].opcodes[5] = { type: 4, index: 73 }),
          (this.rules[54].opcodes[6] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[54].opcodes[7] = { type: 2, children: [8, 9] }),
          (this.rules[54].opcodes[8] = { type: 6, string: [46] }),
          (this.rules[54].opcodes[9] = { type: 4, index: 73 }),
          (this.rules[54].opcodes[10] = { type: 2, children: [11, 12, 13] }),
          (this.rules[54].opcodes[11] = { type: 4, index: 77 }),
          (this.rules[54].opcodes[12] = { type: 4, index: 74 }),
          (this.rules[54].opcodes[13] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[54].opcodes[14] = { type: 2, children: [15, 16] }),
          (this.rules[54].opcodes[15] = { type: 6, string: [46] }),
          (this.rules[54].opcodes[16] = { type: 4, index: 74 }),
          (this.rules[54].opcodes[17] = { type: 2, children: [18, 19, 20] }),
          (this.rules[54].opcodes[18] = { type: 4, index: 78 }),
          (this.rules[54].opcodes[19] = { type: 4, index: 75 }),
          (this.rules[54].opcodes[20] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[54].opcodes[21] = { type: 2, children: [22, 23] }),
          (this.rules[54].opcodes[22] = { type: 6, string: [46] }),
          (this.rules[54].opcodes[23] = { type: 4, index: 75 }),
          (this.rules[55].opcodes = []),
          (this.rules[55].opcodes[0] = { type: 2, children: [1, 2, 3, 4] }),
          (this.rules[55].opcodes[1] = { type: 4, index: 56 }),
          (this.rules[55].opcodes[2] = { type: 4, index: 57 }),
          (this.rules[55].opcodes[3] = { type: 4, index: 59 }),
          (this.rules[55].opcodes[4] = { type: 4, index: 58 }),
          (this.rules[56].opcodes = []),
          (this.rules[56].opcodes[0] = { type: 3, min: 0, max: 1 }),
          (this.rules[56].opcodes[1] = { type: 1, children: [2, 3] }),
          (this.rules[56].opcodes[2] = { type: 7, string: [37, 105] }),
          (this.rules[56].opcodes[3] = { type: 7, string: [37, 115] }),
          (this.rules[57].opcodes = []),
          (this.rules[57].opcodes[0] = { type: 6, string: [34] }),
          (this.rules[58].opcodes = []),
          (this.rules[58].opcodes[0] = { type: 6, string: [34] }),
          (this.rules[59].opcodes = []),
          (this.rules[59].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[59].opcodes[1] = { type: 1, children: [2, 3, 4] }),
          (this.rules[59].opcodes[2] = { type: 5, min: 32, max: 33 }),
          (this.rules[59].opcodes[3] = { type: 5, min: 35, max: 126 }),
          (this.rules[59].opcodes[4] = { type: 4, index: 60 }),
          (this.rules[60].opcodes = []),
          (this.rules[60].opcodes[0] = { type: 6, string: [9] }),
          (this.rules[61].opcodes = []),
          (this.rules[61].opcodes[0] = { type: 2, children: [1, 2, 3] }),
          (this.rules[61].opcodes[1] = { type: 4, index: 62 }),
          (this.rules[61].opcodes[2] = { type: 4, index: 64 }),
          (this.rules[61].opcodes[3] = { type: 4, index: 63 }),
          (this.rules[62].opcodes = []),
          (this.rules[62].opcodes[0] = { type: 6, string: [39] }),
          (this.rules[63].opcodes = []),
          (this.rules[63].opcodes[0] = { type: 6, string: [39] }),
          (this.rules[64].opcodes = []),
          (this.rules[64].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[64].opcodes[1] = { type: 1, children: [2, 3, 4] }),
          (this.rules[64].opcodes[2] = { type: 5, min: 32, max: 38 }),
          (this.rules[64].opcodes[3] = { type: 5, min: 40, max: 126 }),
          (this.rules[64].opcodes[4] = { type: 4, index: 60 }),
          (this.rules[65].opcodes = []),
          (this.rules[65].opcodes[0] = { type: 2, children: [1, 2, 3] }),
          (this.rules[65].opcodes[1] = { type: 4, index: 66 }),
          (this.rules[65].opcodes[2] = { type: 4, index: 67 }),
          (this.rules[65].opcodes[3] = { type: 4, index: 68 }),
          (this.rules[66].opcodes = []),
          (this.rules[66].opcodes[0] = { type: 6, string: [60] }),
          (this.rules[67].opcodes = []),
          (this.rules[67].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[67].opcodes[1] = { type: 1, children: [2, 3, 4] }),
          (this.rules[67].opcodes[2] = { type: 5, min: 32, max: 61 }),
          (this.rules[67].opcodes[3] = { type: 5, min: 63, max: 126 }),
          (this.rules[67].opcodes[4] = { type: 4, index: 60 }),
          (this.rules[68].opcodes = []),
          (this.rules[68].opcodes[0] = { type: 6, string: [62] }),
          (this.rules[69].opcodes = []),
          (this.rules[69].opcodes[0] = { type: 4, index: 72 }),
          (this.rules[70].opcodes = []),
          (this.rules[70].opcodes[0] = { type: 4, index: 72 }),
          (this.rules[71].opcodes = []),
          (this.rules[71].opcodes[0] = { type: 4, index: 72 }),
          (this.rules[72].opcodes = []),
          (this.rules[72].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[72].opcodes[1] = { type: 5, min: 48, max: 57 }),
          (this.rules[73].opcodes = []),
          (this.rules[73].opcodes[0] = { type: 4, index: 85 }),
          (this.rules[74].opcodes = []),
          (this.rules[74].opcodes[0] = { type: 4, index: 87 }),
          (this.rules[75].opcodes = []),
          (this.rules[75].opcodes[0] = { type: 4, index: 86 }),
          (this.rules[76].opcodes = []),
          (this.rules[76].opcodes[0] = { type: 1, children: [1, 2] }),
          (this.rules[76].opcodes[1] = { type: 6, string: [68] }),
          (this.rules[76].opcodes[2] = { type: 6, string: [100] }),
          (this.rules[77].opcodes = []),
          (this.rules[77].opcodes[0] = { type: 1, children: [1, 2] }),
          (this.rules[77].opcodes[1] = { type: 6, string: [88] }),
          (this.rules[77].opcodes[2] = { type: 6, string: [120] }),
          (this.rules[78].opcodes = []),
          (this.rules[78].opcodes[0] = { type: 1, children: [1, 2] }),
          (this.rules[78].opcodes[1] = { type: 6, string: [66] }),
          (this.rules[78].opcodes[2] = { type: 6, string: [98] }),
          (this.rules[79].opcodes = []),
          (this.rules[79].opcodes[0] = { type: 4, index: 85 }),
          (this.rules[80].opcodes = []),
          (this.rules[80].opcodes[0] = { type: 4, index: 85 }),
          (this.rules[81].opcodes = []),
          (this.rules[81].opcodes[0] = { type: 4, index: 86 }),
          (this.rules[82].opcodes = []),
          (this.rules[82].opcodes[0] = { type: 4, index: 86 }),
          (this.rules[83].opcodes = []),
          (this.rules[83].opcodes[0] = { type: 4, index: 87 }),
          (this.rules[84].opcodes = []),
          (this.rules[84].opcodes[0] = { type: 4, index: 87 }),
          (this.rules[85].opcodes = []),
          (this.rules[85].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[85].opcodes[1] = { type: 5, min: 48, max: 57 }),
          (this.rules[86].opcodes = []),
          (this.rules[86].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[86].opcodes[1] = { type: 5, min: 48, max: 49 }),
          (this.rules[87].opcodes = []),
          (this.rules[87].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[87].opcodes[1] = { type: 1, children: [2, 3, 4] }),
          (this.rules[87].opcodes[2] = { type: 5, min: 48, max: 57 }),
          (this.rules[87].opcodes[3] = { type: 5, min: 65, max: 70 }),
          (this.rules[87].opcodes[4] = { type: 5, min: 97, max: 102 }),
          (this.rules[88].opcodes = []),
          (this.rules[88].opcodes[0] = { type: 2, children: [1, 4] }),
          (this.rules[88].opcodes[1] = { type: 1, children: [2, 3] }),
          (this.rules[88].opcodes[2] = { type: 5, min: 97, max: 122 }),
          (this.rules[88].opcodes[3] = { type: 5, min: 65, max: 90 }),
          (this.rules[88].opcodes[4] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[88].opcodes[5] = { type: 1, children: [6, 7, 8, 9] }),
          (this.rules[88].opcodes[6] = { type: 5, min: 97, max: 122 }),
          (this.rules[88].opcodes[7] = { type: 5, min: 65, max: 90 }),
          (this.rules[88].opcodes[8] = { type: 5, min: 48, max: 57 }),
          (this.rules[88].opcodes[9] = { type: 6, string: [45] }),
          (this.rules[89].opcodes = []),
          (this.rules[89].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[89].opcodes[1] = { type: 4, index: 91 }),
          (this.rules[90].opcodes = []),
          (this.rules[90].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[90].opcodes[1] = { type: 4, index: 91 }),
          (this.rules[91].opcodes = []),
          (this.rules[91].opcodes[0] = { type: 1, children: [1, 2, 3, 4] }),
          (this.rules[91].opcodes[1] = { type: 6, string: [32] }),
          (this.rules[91].opcodes[2] = { type: 6, string: [9] }),
          (this.rules[91].opcodes[3] = { type: 4, index: 92 }),
          (this.rules[91].opcodes[4] = { type: 4, index: 94 }),
          (this.rules[92].opcodes = []),
          (this.rules[92].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[92].opcodes[1] = { type: 6, string: [59] }),
          (this.rules[92].opcodes[2] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[92].opcodes[3] = { type: 1, children: [4, 5] }),
          (this.rules[92].opcodes[4] = { type: 5, min: 32, max: 126 }),
          (this.rules[92].opcodes[5] = { type: 6, string: [9] }),
          (this.rules[93].opcodes = []),
          (this.rules[93].opcodes[0] = { type: 1, children: [1, 2, 3] }),
          (this.rules[93].opcodes[1] = { type: 6, string: [13, 10] }),
          (this.rules[93].opcodes[2] = { type: 6, string: [10] }),
          (this.rules[93].opcodes[3] = { type: 6, string: [13] }),
          (this.rules[94].opcodes = []),
          (this.rules[94].opcodes[0] = { type: 2, children: [1, 5] }),
          (this.rules[94].opcodes[1] = { type: 1, children: [2, 3, 4] }),
          (this.rules[94].opcodes[2] = { type: 6, string: [13, 10] }),
          (this.rules[94].opcodes[3] = { type: 6, string: [10] }),
          (this.rules[94].opcodes[4] = { type: 6, string: [13] }),
          (this.rules[94].opcodes[5] = { type: 1, children: [6, 7] }),
          (this.rules[94].opcodes[6] = { type: 6, string: [32] }),
          (this.rules[94].opcodes[7] = { type: 6, string: [9] }),
          (this.toString = function () {
            return ";\n; ABNF for JavaScript APG 2.0 SABNF\n; RFC 5234 with some restrictions and additions.\n; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\n;  - accepts %s\"string\" as a case-sensitive string\n;  - accepts %i\"string\" as a case-insensitive string\n;  - accepts \"string\" as a case-insensitive string\n;\n; Some restrictions:\n;   1. Rules must begin at first character of each line.\n;      Indentations on first rule and rules thereafter are not allowed.\n;   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\n;   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\n;      However, a working parser cannot be generated from them.\n;\n; Super set (SABNF) additions:\n;   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\n;      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\n;      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\n;      e.g. &%d13 or &rule or !(A / B)\n;   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\n;      'name' is alpha followed by alpha/num/hyphen just like a rule name.\n;      u_name may be used as an element but no rule definition is given.\n;      e.g. rule = A / u_myUdt\n;           A = \"a\"\n;      would be a valid grammar.\n;   3. Case-sensitive, single-quoted strings are accepted.\n;      e.g. 'abc' would be equivalent to %d97.98.99\n;      (kept for backward compatibility, but superseded by %s\"abc\")  \n; New 12/26/2015\n;   4. Look-behind operators are accepted as element prefixes.\n;      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\n;      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\n;      e.g. &&%d13 or &&rule or !!(A / B)\n;   5. Back reference operators, i.e. \\rulename, are accepted.\n;      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\n;      to match is a phrase previously matched by the rule 'rulename'.\n;      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\n;      In universal mode, \\rulename matches the last match to 'rulename' regardless of where it was found.\n;      In parent-frame mode, \\rulename matches only the last match found on the parent's frame or parse tree level.\n;      Back reference modifiers can be used to specify case and mode.\n;      \\A defaults to case-insensitive and universal mode, e.g. \\A === \\%i%uA\n;      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\n;      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\n;      Case and mode modifiers can appear in any order, e.g. \\%s%pA === \\%p%sA. \n;   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\n;      Returns EMPTY or NOMATCH. Never consumes any characters.\n;   8. String end anchor, AEN(%$) matches the end of the input string location.\n;      Returns EMPTY or NOMATCH. Never consumes any characters.\n;\nFile            = *(BlankLine / Rule / RuleError)\nBlankLine       = *(%d32/%d9) [comment] LineEnd\nRule            = RuleLookup owsp Alternation ((owsp LineEnd)\n                / (LineEndError LineEnd))\nRuleLookup      = RuleNameTest owsp DefinedAsTest\nRuleNameTest    = RuleName/RuleNameError\nRuleName        = alphanum\nRuleNameError   = 1*(%d33-60/%d62-126)\nDefinedAsTest   = DefinedAs / DefinedAsError\nDefinedAsError  = 1*2%d33-126\nDefinedAs       = IncAlt / Defined\nDefined         = %d61\nIncAlt          = %d61.47\nRuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\nLineEndError    = 1*(%d32-126 / %d9  / LineContinue)\nAlternation     = Concatenation *(owsp AltOp Concatenation)\nConcatenation   = Repetition *(CatOp Repetition)\nRepetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\nModifier        = (Predicate [RepOp])\n                / RepOp\nPredicate       = BkaOp\n                / BknOp\n                / AndOp\n                / NotOp\nBasicElement    = UdtOp\n                / RnmOp\n                / TrgOp\n                / TbsOp\n                / TlsOp\n                / ClsOp\n                / BkrOp\n                / AbgOp\n                / AenOp\n                / ProsVal\nBasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\nGroup           = GroupOpen  Alternation (GroupClose / GroupError)\nGroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\nGroupOpen       = %d40 owsp\nGroupClose      = owsp %d41\nOption          = OptionOpen Alternation (OptionClose / OptionError)\nOptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\nOptionOpen      = %d91 owsp\nOptionClose     = owsp %d93\nRnmOp           = alphanum\nBkrOp           = %d92 [bkrModifier] bkr-name\nbkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\ncs              = '%s'\nci              = '%i'\num              = '%u'\npm              = '%p'\nbkr-name        = uname / ename / rname\nrname           = alphanum\nuname           = %d117.95 alphanum\nename           = %d101.95 alphanum\nUdtOp           = udt-empty\n                / udt-non-empty\nudt-non-empty   = %d117.95 alphanum\nudt-empty       = %d101.95 alphanum\nRepOp           = (rep-min StarOp rep-max)\n                / (rep-min StarOp)\n                / (StarOp rep-max)\n                / StarOp\n                / rep-min-max\nAltOp           = %d47 owsp\nCatOp           = wsp\nStarOp          = %d42\nAndOp           = %d38\nNotOp           = %d33\nBkaOp           = %d38.38\nBknOp           = %d33.33\nAbgOp           = %d37.94\nAenOp           = %d37.36\nTrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\nTbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\nTlsOp           = TlsCase TlsOpen TlsString TlsClose\nTlsCase         = [\"%i\" / \"%s\"]\nTlsOpen         = %d34\nTlsClose        = %d34\nTlsString       = *(%d32-33/%d35-126/StringTab)\nStringTab       = %d9\nClsOp           = ClsOpen ClsString ClsClose\nClsOpen         = %d39\nClsClose        = %d39\nClsString       = *(%d32-38/%d40-126/StringTab)\nProsVal         = ProsValOpen ProsValString ProsValClose\nProsValOpen     = %d60\nProsValString   = *(%d32-61/%d63-126/StringTab)\nProsValClose    = %d62\nrep-min         = rep-num\nrep-min-max     = rep-num\nrep-max         = rep-num\nrep-num         = 1*(%d48-57)\ndString         = dnum\nxString         = xnum\nbString         = bnum\nDec             = (%d68/%d100)\nHex             = (%d88/%d120)\nBin             = (%d66/%d98)\ndmin            = dnum\ndmax            = dnum\nbmin            = bnum\nbmax            = bnum\nxmin            = xnum\nxmax            = xnum\ndnum            = 1*(%d48-57)\nbnum            = 1*%d48-49\nxnum            = 1*(%d48-57 / %d65-70 / %d97-102)\n;\n; Basics\nalphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\nowsp            = *space\nwsp             = 1*space\nspace           = %d32\n                / %d9\n                / comment\n                / LineContinue\ncomment         = %d59 *(%d32-126 / %d9)\nLineEnd         = %d13.10\n                / %d10\n                / %d13\nLineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\n";
          });
      };
    },
    74650: function (O, T, L) {
      let J = L(47351),
        W = L(51708);
      function Y(O, T, L, W, Y) {
        return (
          O === J.SEM_PRE
            ? ((Y.endLength = 0), (Y.textLength = 0), (Y.invalidCount = 0))
            : Y.lines.push({
                lineNo: Y.lines.length,
                beginChar: L,
                length: W,
                textLength: Y.textLength,
                endType: Y.endType,
                invalidChars: Y.invalidCount,
              }),
          J.SEM_OK
        );
      }
      function Z(O, T, L, W, Y) {
        return O === J.SEM_PRE && (Y.textLength = W), J.SEM_OK;
      }
      function X(O, T, L, W, Y) {
        return (
          O === J.SEM_PRE
            ? ((Y.endLength = 0), (Y.textLength = 0), (Y.invalidCount = 0))
            : Y.strict
            ? (Y.lines.push({
                lineNo: Y.lines.length,
                beginChar: L,
                length: W,
                textLength: W,
                endType: "none",
                invalidChars: Y.invalidCount,
              }),
              Y.errors.push({
                line: Y.lineNo,
                char: L + W,
                msg: "no line end on last line - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)",
              }))
            : (T.push(10),
              Y.lines.push({
                lineNo: Y.lines.length,
                beginChar: L,
                length: W + 1,
                textLength: W,
                endType: "LF",
                invalidChars: Y.invalidCount,
              })),
          J.SEM_OK
        );
      }
      function ee(O, T, L, Y, Z) {
        return (
          O === J.SEM_PRE &&
            Z.errors.push({
              line: Z.lineNo,
              char: L,
              msg: `invalid character found '\\x${W.charToHex(T[L])}'`,
            }),
          J.SEM_OK
        );
      }
      function et(O, T, L, W, Y) {
        return O === J.SEM_POST && (Y.lineNo += 1), J.SEM_OK;
      }
      function er(O, T, L, W, Y) {
        return (
          O === J.SEM_PRE &&
            ((Y.endType = "LF"),
            Y.strict &&
              Y.errors.push({
                line: Y.lineNo,
                char: L,
                msg: "line end character LF(\\n, \\x0A) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)",
              })),
          J.SEM_OK
        );
      }
      function en(O, T, L, W, Y) {
        return (
          O === J.SEM_PRE &&
            ((Y.endType = "CR"),
            Y.strict &&
              Y.errors.push({
                line: Y.lineNo,
                char: L,
                msg: "line end character CR(\\r, \\x0D) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)",
              })),
          J.SEM_OK
        );
      }
      function es(O, T, L, W, Y) {
        return O === J.SEM_PRE && (Y.endType = "CRLF"), J.SEM_OK;
      }
      let ei = [];
      (ei.line = Y),
        (ei["line-text"] = Z),
        (ei["last-line"] = X),
        (ei.invalid = ee),
        (ei.end = et),
        (ei.lf = er),
        (ei.cr = en),
        (ei.crlf = es),
        (T.callbacks = ei);
    },
    50944: function (O) {
      O.exports = function () {
        (this.grammarObject = "grammarObject"),
          (this.rules = []),
          (this.rules[0] = {
            name: "file",
            lower: "file",
            index: 0,
            isBkr: !1,
          }),
          (this.rules[1] = {
            name: "line",
            lower: "line",
            index: 1,
            isBkr: !1,
          }),
          (this.rules[2] = {
            name: "line-text",
            lower: "line-text",
            index: 2,
            isBkr: !1,
          }),
          (this.rules[3] = {
            name: "last-line",
            lower: "last-line",
            index: 3,
            isBkr: !1,
          }),
          (this.rules[4] = {
            name: "valid",
            lower: "valid",
            index: 4,
            isBkr: !1,
          }),
          (this.rules[5] = {
            name: "invalid",
            lower: "invalid",
            index: 5,
            isBkr: !1,
          }),
          (this.rules[6] = { name: "end", lower: "end", index: 6, isBkr: !1 }),
          (this.rules[7] = {
            name: "CRLF",
            lower: "crlf",
            index: 7,
            isBkr: !1,
          }),
          (this.rules[8] = { name: "LF", lower: "lf", index: 8, isBkr: !1 }),
          (this.rules[9] = { name: "CR", lower: "cr", index: 9, isBkr: !1 }),
          (this.udts = []),
          (this.rules[0].opcodes = []),
          (this.rules[0].opcodes[0] = { type: 2, children: [1, 3] }),
          (this.rules[0].opcodes[1] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[0].opcodes[2] = { type: 4, index: 1 }),
          (this.rules[0].opcodes[3] = { type: 3, min: 0, max: 1 }),
          (this.rules[0].opcodes[4] = { type: 4, index: 3 }),
          (this.rules[1].opcodes = []),
          (this.rules[1].opcodes[0] = { type: 2, children: [1, 2] }),
          (this.rules[1].opcodes[1] = { type: 4, index: 2 }),
          (this.rules[1].opcodes[2] = { type: 4, index: 6 }),
          (this.rules[2].opcodes = []),
          (this.rules[2].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
          (this.rules[2].opcodes[1] = { type: 1, children: [2, 3] }),
          (this.rules[2].opcodes[2] = { type: 4, index: 4 }),
          (this.rules[2].opcodes[3] = { type: 4, index: 5 }),
          (this.rules[3].opcodes = []),
          (this.rules[3].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
          (this.rules[3].opcodes[1] = { type: 1, children: [2, 3] }),
          (this.rules[3].opcodes[2] = { type: 4, index: 4 }),
          (this.rules[3].opcodes[3] = { type: 4, index: 5 }),
          (this.rules[4].opcodes = []),
          (this.rules[4].opcodes[0] = { type: 1, children: [1, 2] }),
          (this.rules[4].opcodes[1] = { type: 5, min: 32, max: 126 }),
          (this.rules[4].opcodes[2] = { type: 6, string: [9] }),
          (this.rules[5].opcodes = []),
          (this.rules[5].opcodes[0] = { type: 1, children: [1, 2, 3, 4] }),
          (this.rules[5].opcodes[1] = { type: 5, min: 0, max: 8 }),
          (this.rules[5].opcodes[2] = { type: 5, min: 11, max: 12 }),
          (this.rules[5].opcodes[3] = { type: 5, min: 14, max: 31 }),
          (this.rules[5].opcodes[4] = { type: 5, min: 127, max: 4294967295 }),
          (this.rules[6].opcodes = []),
          (this.rules[6].opcodes[0] = { type: 1, children: [1, 2, 3] }),
          (this.rules[6].opcodes[1] = { type: 4, index: 7 }),
          (this.rules[6].opcodes[2] = { type: 4, index: 8 }),
          (this.rules[6].opcodes[3] = { type: 4, index: 9 }),
          (this.rules[7].opcodes = []),
          (this.rules[7].opcodes[0] = { type: 6, string: [13, 10] }),
          (this.rules[8].opcodes = []),
          (this.rules[8].opcodes[0] = { type: 6, string: [10] }),
          (this.rules[9].opcodes = []),
          (this.rules[9].opcodes[0] = { type: 6, string: [13] }),
          (this.toString = function () {
            return "file = *line [last-line]\nline = line-text end\nline-text = *(valid/invalid)\nlast-line = 1*(valid/invalid)\nvalid = %d32-126 / %d9\ninvalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\nend = CRLF / LF / CR\nCRLF = %d13.10\nLF = %d10\nCR = %d13\n";
          });
      };
    },
    90103: function (O, T, L) {
      O.exports = function (O, T, J, W) {
        let Y = "scanner.js: ",
          Z = L(26979),
          X = new (L(50944))(),
          { callbacks: ee } = L(74650),
          et = [],
          er = new Z.parser();
        if (((er.ast = new Z.ast()), (er.ast.callbacks = ee), W)) {
          if ("traceObject" !== W.traceObject)
            throw TypeError(`${Y}trace argument is not a trace object`);
          er.trace = W;
        }
        if (!0 !== er.parse(X, "file", O).success) {
          T.push({
            line: 0,
            char: 0,
            msg: "syntax analysis error analyzing input SABNF grammar",
          });
          return;
        }
        let en = { lines: et, lineNo: 0, errors: T, strict: !!J };
        return er.ast.translate(en), et;
      };
    },
    6876: function (O, T, L) {
      O.exports = function () {
        let O = L(26979),
          T = O.ids,
          J = function () {
            (this.names = []),
              (this.add = function (O) {
                let T = -1;
                return (
                  -1 === this.get(O) &&
                    ((T = {
                      name: O,
                      lower: O.toLowerCase(),
                      index: this.names.length,
                    }),
                    this.names.push(T)),
                  T
                );
              }),
              (this.get = function (O) {
                let T = -1,
                  L = O.toLowerCase();
                for (let O = 0; O < this.names.length; O += 1)
                  if (this.names[O].lower === L) {
                    T = this.names[O];
                    break;
                  }
                return T;
              });
          },
          W = function (O, T, L) {
            let J = 0;
            for (let W = T; W < T + L; W += 1) J = 10 * J + O[W] - 48;
            return J;
          },
          Y = function (O, T, L) {
            let J = 0;
            for (let W = T; W < T + L; W += 1) J = 2 * J + O[W] - 48;
            return J;
          },
          Z = function (O, T, L) {
            let J = 0;
            for (let W = T; W < T + L; W += 1) {
              let T = O[W];
              if (T >= 48 && T <= 57) T -= 48;
              else if (T >= 65 && T <= 70) T -= 55;
              else if (T >= 97 && T <= 102) T -= 87;
              else throw Error("hexnum out of range");
              J = 16 * J + T;
            }
            return J;
          };
        function X(O, L, W, Y, Z) {
          let X = T.SEM_OK;
          if (O === T.SEM_PRE)
            (Z.ruleNames = new J()),
              (Z.udtNames = new J()),
              (Z.rules = []),
              (Z.udts = []),
              (Z.rulesLineMap = []),
              (Z.opcodes = []),
              (Z.altStack = []),
              (Z.topStack = null),
              (Z.topRule = null);
          else if (O === T.SEM_POST) {
            let O;
            Z.rules.forEach((L) => {
              (L.isBkr = !1),
                L.opcodes.forEach((L) => {
                  L.type === T.RNM &&
                    (-1 === (O = Z.ruleNames.get(L.index.name))
                      ? (Z.errors.push({
                          line: Z.findLine(
                            Z.lines,
                            L.index.phraseIndex,
                            Z.charsLength
                          ),
                          char: L.index.phraseIndex,
                          msg: `Rule name '${L.index.name}' used but not defined.`,
                        }),
                        (L.index = -1))
                      : (L.index = O.index));
                });
            }),
              Z.udts.forEach((O) => {
                O.isBkr = !1;
              }),
              Z.rules.forEach((L) => {
                L.opcodes.forEach((J) => {
                  J.type === T.BKR &&
                    ((L.hasBkr = !0),
                    -1 !== (O = Z.ruleNames.get(J.index.name))
                      ? ((Z.rules[O.index].isBkr = !0), (J.index = O.index))
                      : -1 !== (O = Z.udtNames.get(J.index.name))
                      ? ((Z.udts[O.index].isBkr = !0),
                        (J.index = Z.rules.length + O.index))
                      : (Z.errors.push({
                          line: Z.findLine(
                            Z.lines,
                            J.index.phraseIndex,
                            Z.charsLength
                          ),
                          char: J.index.phraseIndex,
                          msg: `Back reference name '${J.index.name}' refers to undefined rule or unamed UDT.`,
                        }),
                        (J.index = -1)));
                });
              });
          }
          return X;
        }
        function ee(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_PRE &&
              ((Y.altStack.length = 0),
              (Y.topStack = null),
              Y.rulesLineMap.push({
                line: Y.findLine(Y.lines, J, Y.charsLength),
                char: J,
              })),
            Z
          );
        }
        function et(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          if (O === T.SEM_PRE) (Y.ruleName = ""), (Y.definedas = "");
          else if (O === T.SEM_POST) {
            let O;
            "=" === Y.definedas
              ? -1 === (O = Y.ruleNames.add(Y.ruleName))
                ? ((Y.definedas = null),
                  Y.errors.push({
                    line: Y.findLine(Y.lines, J, Y.charsLength),
                    char: J,
                    msg: `Rule name '${Y.ruleName}' previously defined.`,
                  }))
                : ((Y.topRule = {
                    name: O.name,
                    lower: O.lower,
                    opcodes: [],
                    index: O.index,
                  }),
                  Y.rules.push(Y.topRule),
                  (Y.opcodes = Y.topRule.opcodes))
              : -1 === (O = Y.ruleNames.get(Y.ruleName))
              ? ((Y.definedas = null),
                Y.errors.push({
                  line: Y.findLine(Y.lines, J, Y.charsLength),
                  char: J,
                  msg: `Rule name '${Y.ruleName}' for incremental alternate not previously defined.`,
                }))
              : ((Y.topRule = Y.rules[O.index]),
                (Y.opcodes = Y.topRule.opcodes));
          }
          return Z;
        }
        function er(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          if (O === T.SEM_PRE) {
            let O = !0;
            for (; O; ) {
              if (null === Y.definedas) {
                Z = T.SEM_SKIP;
                break;
              }
              if (null === Y.topStack) {
                if ("=" === Y.definedas) {
                  (Y.topStack = {
                    alt: { type: T.ALT, children: [] },
                    cat: null,
                  }),
                    Y.altStack.push(Y.topStack),
                    Y.opcodes.push(Y.topStack.alt);
                  break;
                }
                (Y.topStack = { alt: Y.opcodes[0], cat: null }),
                  Y.altStack.push(Y.topStack);
                break;
              }
              (Y.topStack = { alt: { type: T.ALT, children: [] }, cat: null }),
                Y.altStack.push(Y.topStack),
                Y.opcodes.push(Y.topStack.alt);
              break;
            }
          } else
            O === T.SEM_POST &&
              (Y.altStack.pop(),
              Y.altStack.length > 0
                ? (Y.topStack = Y.altStack[Y.altStack.length - 1])
                : (Y.topStack = null));
          return Z;
        }
        function en(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_PRE
              ? (Y.topStack.alt.children.push(Y.opcodes.length),
                (Y.topStack.cat = { type: T.CAT, children: [] }),
                Y.opcodes.push(Y.topStack.cat))
              : O === T.SEM_POST && (Y.topStack.cat = null),
            Z
          );
        }
        function es(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_PRE && Y.topStack.cat.children.push(Y.opcodes.length), Z
          );
        }
        function ei(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_POST &&
              Y.opcodes.push({ type: T.REP, min: 0, max: 1, char: J }),
            Z
          );
        }
        function ea(L, J, W, Y, Z) {
          let X = T.SEM_OK;
          return (
            L === T.SEM_PRE && (Z.ruleName = O.utils.charsToString(J, W, Y)), X
          );
        }
        function eo(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && (Y.definedas = "="), Z;
        }
        function ec(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && (Y.definedas = "=/"), Z;
        }
        function eu(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_PRE
              ? ((Y.min = 0),
                (Y.max = 1 / 0),
                (Y.topRep = { type: T.REP, min: 0, max: 1 / 0 }),
                Y.opcodes.push(Y.topRep))
              : O === T.SEM_POST &&
                (Y.min > Y.max &&
                  Y.errors.push({
                    line: Y.findLine(Y.lines, J, Y.charsLength),
                    char: J,
                    msg: `repetition min cannot be greater than max: min: ${Y.min}: max: ${Y.max}`,
                  }),
                (Y.topRep.min = Y.min),
                (Y.topRep.max = Y.max)),
            Z
          );
        }
        function eh(O, L, J, Y, Z) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && (Z.min = W(L, J, Y)), X;
        }
        function ed(O, L, J, Y, Z) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && (Z.max = W(L, J, Y)), X;
        }
        function ep(O, L, J, Y, Z) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && ((Z.max = W(L, J, Y)), (Z.min = Z.max)), X;
        }
        function eg(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && Y.opcodes.push({ type: T.AND }), Z;
        }
        function ey(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && Y.opcodes.push({ type: T.NOT }), Z;
        }
        function em(L, J, W, Y, Z) {
          let X = T.SEM_OK;
          return (
            L === T.SEM_POST &&
              Z.opcodes.push({
                type: T.RNM,
                index: { phraseIndex: W, name: O.utils.charsToString(J, W, Y) },
              }),
            X
          );
        }
        function eb(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && Y.opcodes.push({ type: T.ABG }), Z;
        }
        function eA(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && Y.opcodes.push({ type: T.AEN }), Z;
        }
        function ew(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && Y.opcodes.push({ type: T.BKA }), Z;
        }
        function ev(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && Y.opcodes.push({ type: T.BKN }), Z;
        }
        function ek(L, J, W, Y, Z) {
          let X = T.SEM_OK;
          return (
            L === T.SEM_PRE
              ? ((Z.ci = !0), (Z.cs = !1), (Z.um = !0), (Z.pm = !1))
              : L === T.SEM_POST &&
                Z.opcodes.push({
                  type: T.BKR,
                  bkrCase: !0 === Z.cs ? T.BKR_MODE_CS : T.BKR_MODE_CI,
                  bkrMode: !0 === Z.pm ? T.BKR_MODE_PM : T.BKR_MODE_UM,
                  index: {
                    phraseIndex: Z.bkrname.phraseIndex,
                    name: O.utils.charsToString(
                      J,
                      Z.bkrname.phraseIndex,
                      Z.bkrname.phraseLength
                    ),
                  },
                }),
            X
          );
        }
        function eE(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && (Y.ci = !0), Z;
        }
        function eS(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && (Y.cs = !0), Z;
        }
        function eP(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && (Y.um = !0), Z;
        }
        function eC(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_POST && (Y.pm = !0), Z;
        }
        function eB(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_POST &&
              (Y.bkrname = { phraseIndex: J, phraseLength: W }),
            Z
          );
        }
        function eO(L, J, W, Y, Z) {
          let X = T.SEM_OK;
          if (L === T.SEM_POST) {
            let L = O.utils.charsToString(J, W, Y),
              X = Z.udtNames.add(L);
            if (-1 === X) {
              if (-1 === (X = Z.udtNames.get(L)))
                throw Error("semUdtEmpty: name look up error");
            } else
              Z.udts.push({
                name: X.name,
                lower: X.lower,
                index: X.index,
                empty: !0,
              });
            Z.opcodes.push({ type: T.UDT, empty: !0, index: X.index });
          }
          return X;
        }
        function eT(L, J, W, Y, Z) {
          let X = T.SEM_OK;
          if (L === T.SEM_POST) {
            let L = O.utils.charsToString(J, W, Y),
              X = Z.udtNames.add(L);
            if (-1 === X) {
              if (-1 === (X = Z.udtNames.get(L)))
                throw Error("semUdtNonEmpty: name look up error");
            } else
              Z.udts.push({
                name: X.name,
                lower: X.lower,
                index: X.index,
                empty: !1,
              });
            Z.opcodes.push({
              type: T.UDT,
              empty: !1,
              index: X.index,
              syntax: null,
              semantic: null,
            });
          }
          return X;
        }
        function eN(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return O === T.SEM_PRE && (Y.tlscase = !0), Z;
        }
        function eR(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_POST &&
              W > 0 &&
              (83 === L[J + 1] || 115 === L[J + 1]) &&
              (Y.tlscase = !1),
            Z
          );
        }
        function eI(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          if (O === T.SEM_POST) {
            if (Y.tlscase) {
              let O = L.slice(J, J + W);
              for (let T = 0; T < O.length; T += 1)
                O[T] >= 65 && O[T] <= 90 && (O[T] += 32);
              Y.opcodes.push({ type: T.TLS, string: O });
            } else Y.opcodes.push({ type: T.TBS, string: L.slice(J, J + W) });
          }
          return Z;
        }
        function eM(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_POST &&
              (W <= 2
                ? Y.opcodes.push({ type: T.TLS, string: [] })
                : Y.opcodes.push({
                    type: T.TBS,
                    string: L.slice(J + 1, J + W - 1),
                  })),
            Z
          );
        }
        function eU(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_PRE
              ? (Y.tbsstr = [])
              : O === T.SEM_POST &&
                Y.opcodes.push({ type: T.TBS, string: Y.tbsstr }),
            Z
          );
        }
        function eL(O, L, J, W, Y) {
          let Z = T.SEM_OK;
          return (
            O === T.SEM_PRE
              ? ((Y.min = 0), (Y.max = 0))
              : O === T.SEM_POST &&
                (Y.min > Y.max &&
                  Y.errors.push({
                    line: Y.findLine(Y.lines, J, Y.charsLength),
                    char: J,
                    msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${Y.min}: max: ${Y.max}`,
                  }),
                Y.opcodes.push({ type: T.TRG, min: Y.min, max: Y.max })),
            Z
          );
        }
        function eD(O, L, J, Y, Z) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && (Z.min = W(L, J, Y)), X;
        }
        function e_(O, L, J, Y, Z) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && (Z.max = W(L, J, Y)), X;
        }
        function eF(O, L, J, W, Z) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && (Z.min = Y(L, J, W)), X;
        }
        function eK(O, L, J, W, Z) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && (Z.max = Y(L, J, W)), X;
        }
        function ej(O, L, J, W, Y) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && (Y.min = Z(L, J, W)), X;
        }
        function eH(O, L, J, W, Y) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && (Y.max = Z(L, J, W)), X;
        }
        function e$(O, L, J, Y, Z) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && Z.tbsstr.push(W(L, J, Y)), X;
        }
        function eV(O, L, J, W, Z) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && Z.tbsstr.push(Y(L, J, W)), X;
        }
        function eG(O, L, J, W, Y) {
          let X = T.SEM_OK;
          return O === T.SEM_POST && Y.tbsstr.push(Z(L, J, W)), X;
        }
        (this.callbacks = []),
          (this.callbacks.abgop = eb),
          (this.callbacks.aenop = eA),
          (this.callbacks.alternation = er),
          (this.callbacks.andop = eg),
          (this.callbacks.bmax = eK),
          (this.callbacks.bmin = eF),
          (this.callbacks.bkaop = ew),
          (this.callbacks.bknop = ev),
          (this.callbacks.bkrop = ek),
          (this.callbacks["bkr-name"] = eB),
          (this.callbacks.bstring = eV),
          (this.callbacks.clsop = eM),
          (this.callbacks.ci = eE),
          (this.callbacks.cs = eS),
          (this.callbacks.um = eP),
          (this.callbacks.pm = eC),
          (this.callbacks.concatenation = en),
          (this.callbacks.defined = eo),
          (this.callbacks.dmax = e_),
          (this.callbacks.dmin = eD),
          (this.callbacks.dstring = e$),
          (this.callbacks.file = X),
          (this.callbacks.incalt = ec),
          (this.callbacks.notop = ey),
          (this.callbacks.optionopen = ei),
          (this.callbacks["rep-max"] = ed),
          (this.callbacks["rep-min"] = eh),
          (this.callbacks["rep-min-max"] = ep),
          (this.callbacks.repetition = es),
          (this.callbacks.repop = eu),
          (this.callbacks.rnmop = em),
          (this.callbacks.rule = ee),
          (this.callbacks.rulelookup = et),
          (this.callbacks.rulename = ea),
          (this.callbacks.tbsop = eU),
          (this.callbacks.tlscase = eR),
          (this.callbacks.tlsstring = eI),
          (this.callbacks.tlsop = eN),
          (this.callbacks.trgop = eL),
          (this.callbacks["udt-empty"] = eO),
          (this.callbacks["udt-non-empty"] = eT),
          (this.callbacks.xmax = eH),
          (this.callbacks.xmin = ej),
          (this.callbacks.xstring = eG);
      };
    },
    23906: function (O) {
      O.exports = (function () {
        let O = "show-rules.js";
        return function (T = [], L = [], J = "index") {
          let W;
          let Y = "showRules",
            Z = [],
            X = [],
            ee = [],
            et = [],
            er = T,
            en = L,
            es = T.length,
            ei = L.length,
            ea = "RULE/UDT NAMES";
          function eo(O, T) {
            return er[O].lower < er[T].lower
              ? -1
              : er[O].lower > er[T].lower
              ? 1
              : 0;
          }
          function ec(O, T) {
            return en[O].lower < en[T].lower
              ? -1
              : en[O].lower > en[T].lower
              ? 1
              : 0;
          }
          if (!(Array.isArray(T) && T.length))
            throw Error(`${O}:${Y}: rules arg must be array with length > 0`);
          if (!Array.isArray(L))
            throw Error(`${O}:${Y}: udts arg must be array`);
          for (W = 0; W < es; W += 1) ee.push(W);
          if (((Z = ee.slice(0)).sort(eo), ei)) {
            for (W = 0; W < ei; W += 1) et.push(W);
            (X = et.slice(0)).sort(ec);
          }
          if (97 === J.charCodeAt(0)) {
            for (
              ea += " - alphabetical by rule/UDT name\n", W = 0;
              W < es;
              W += 1
            )
              ea += `${W}: ${Z[W]}: ${er[Z[W]].name}
`;
            if (ei)
              for (W = 0; W < ei; W += 1)
                ea += `${W}: ${X[W]}: ${en[X[W]].name}
`;
          } else {
            for (ea += " - ordered by rule/UDT index\n", W = 0; W < es; W += 1)
              ea += `${W}: ${er[W].name}
`;
            if (ei)
              for (W = 0; W < ei; W += 1)
                ea += `${W}: ${en[W].name}
`;
          }
          return ea;
        };
      })();
    },
    50125: function (O, T, L) {
      O.exports = function () {
        let O;
        let T = "syntax-callbacks.js: ",
          J = L(26979),
          W = J.ids,
          Y = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
                (Y.altStack = []), (Y.repCount = 0);
                break;
              case W.EMPTY:
                Y.errors.push({
                  line: 0,
                  char: 0,
                  msg: "grammar file is empty",
                });
                break;
              case W.MATCH:
                0 === Y.ruleCount &&
                  Y.errors.push({ line: 0, char: 0, msg: "no rules defined" });
                break;
              case W.NOMATCH:
                throw Error(
                  `${T}synFile: grammar file NOMATCH: design error: should never happen.`
                );
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          Z = function (L, J, Y, Z) {
            switch (L.state) {
              case W.ACTIVE:
                (Z.altStack.length = 0),
                  (O = {
                    groupOpen: null,
                    groupError: !1,
                    optionOpen: null,
                    optionError: !1,
                    tlsOpen: null,
                    clsOpen: null,
                    prosValOpen: null,
                    basicError: !1,
                  }),
                  Z.altStack.push(O);
                break;
              case W.EMPTY:
                throw Error(`${T}synRule: EMPTY: rule cannot be empty`);
              case W.NOMATCH:
                break;
              case W.MATCH:
                Z.ruleCount += 1;
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          X = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.errors.push({
                  line: Y.findLine(Y.lines, J, Y.charsLength),
                  char: J,
                  msg: "Unrecognized SABNF line. Invalid rule, comment or blank line.",
                });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ee = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.errors.push({
                  line: Y.findLine(Y.lines, J, Y.charsLength),
                  char: J,
                  msg: "Rule names must be alphanum and begin with alphabetic character.",
                });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          et = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.errors.push({
                  line: Y.findLine(Y.lines, J, Y.charsLength),
                  char: J,
                  msg: "Expected '=' or '=/'. Not found.",
                });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          er = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.strict &&
                  Y.errors.push({
                    line: Y.findLine(Y.lines, J, Y.charsLength),
                    char: J,
                    msg: "AND operator(&) found - strict ABNF specified.",
                  });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          en = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.strict &&
                  Y.errors.push({
                    line: Y.findLine(Y.lines, J, Y.charsLength),
                    char: J,
                    msg: "NOT operator(!) found - strict ABNF specified.",
                  });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          es = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.strict
                  ? Y.errors.push({
                      line: Y.findLine(Y.lines, J, Y.charsLength),
                      char: J,
                      msg: "Positive look-behind operator(&&) found - strict ABNF specified.",
                    })
                  : Y.lite &&
                    Y.errors.push({
                      line: Y.findLine(Y.lines, J, Y.charsLength),
                      char: J,
                      msg: "Positive look-behind operator(&&) found - apg-lite specified.",
                    });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ei = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.strict
                  ? Y.errors.push({
                      line: Y.findLine(Y.lines, J, Y.charsLength),
                      char: J,
                      msg: "Negative look-behind operator(!!) found - strict ABNF specified.",
                    })
                  : Y.lite &&
                    Y.errors.push({
                      line: Y.findLine(Y.lines, J, Y.charsLength),
                      char: J,
                      msg: "Negative look-behind operator(!!) found - apg-lite specified.",
                    });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ea = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.strict
                  ? Y.errors.push({
                      line: Y.findLine(Y.lines, J, Y.charsLength),
                      char: J,
                      msg: "Beginning of string anchor(%^) found - strict ABNF specified.",
                    })
                  : Y.lite &&
                    Y.errors.push({
                      line: Y.findLine(Y.lines, J, Y.charsLength),
                      char: J,
                      msg: "Beginning of string anchor(%^) found - apg-lite specified.",
                    });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eo = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.strict
                  ? Y.errors.push({
                      line: Y.findLine(Y.lines, J, Y.charsLength),
                      char: J,
                      msg: "End of string anchor(%$) found - strict ABNF specified.",
                    })
                  : Y.lite &&
                    Y.errors.push({
                      line: Y.findLine(Y.lines, J, Y.charsLength),
                      char: J,
                      msg: "End of string anchor(%$) found - apg-lite specified.",
                    });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ec = function (O, L, Y, Z) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                if (Z.strict) {
                  let T = J.utils.charsToString(L, Y, O.phraseLength);
                  Z.errors.push({
                    line: Z.findLine(Z.lines, Y, Z.charsLength),
                    char: Y,
                    msg: `Back reference operator(${T}) found - strict ABNF specified.`,
                  });
                } else if (Z.lite) {
                  let T = J.utils.charsToString(L, Y, O.phraseLength);
                  Z.errors.push({
                    line: Z.findLine(Z.lines, Y, Z.charsLength),
                    char: Y,
                    msg: `Back reference operator(${T}) found - apg-lite specified.`,
                  });
                }
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eu = function (O, L, Y, Z) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                if (Z.strict) {
                  let T = J.utils.charsToString(L, Y, O.phraseLength);
                  Z.errors.push({
                    line: Z.findLine(Z.lines, Y, Z.charsLength),
                    char: Y,
                    msg: `UDT operator found(${T}) - strict ABNF specified.`,
                  });
                }
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eh = function (L, J, Y) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                O.tlsOpen = Y;
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ed = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
                Y.stringTabChar = !1;
                break;
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                !1 !== Y.stringTabChar &&
                  Y.errors.push({
                    line: Y.findLine(Y.lines, Y.stringTabChar),
                    char: Y.stringTabChar,
                    msg: "Tab character (\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)",
                  });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ep = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.stringTabChar = J;
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eg = function (L, J, Y, Z) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
                break;
              case W.NOMATCH:
                Z.errors.push({
                  line: Z.findLine(Z.lines, O.tlsOpen),
                  char: O.tlsOpen,
                  msg: 'Case-insensitive literal string("...") opened but not closed.',
                }),
                  (O.basicError = !0),
                  (O.tlsOpen = null);
                break;
              case W.MATCH:
                O.tlsOpen = null;
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ey = function (L, J, Y) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                O.clsOpen = Y;
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          em = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
                Y.stringTabChar = !1;
                break;
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                !1 !== Y.stringTabChar &&
                  Y.errors.push({
                    line: Y.findLine(Y.lines, Y.stringTabChar),
                    char: Y.stringTabChar,
                    msg: "Tab character (\\t, x09) not allowed in literal string.",
                  });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eb = function (L, J, Y, Z) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
                break;
              case W.NOMATCH:
                Z.errors.push({
                  line: Z.findLine(Z.lines, O.clsOpen),
                  char: O.clsOpen,
                  msg: "Case-sensitive literal string('...') opened but not closed.",
                }),
                  (O.clsOpen = null),
                  (O.basicError = !0);
                break;
              case W.MATCH:
                Z.strict &&
                  Z.errors.push({
                    line: Z.findLine(Z.lines, O.clsOpen),
                    char: O.clsOpen,
                    msg: "Case-sensitive string operator('...') found - strict ABNF specified.",
                  }),
                  (O.clsOpen = null);
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eA = function (L, J, Y) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                O.prosValOpen = Y;
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ew = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
                Y.stringTabChar = !1;
                break;
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                !1 !== Y.stringTabChar &&
                  Y.errors.push({
                    line: Y.findLine(Y.lines, Y.stringTabChar),
                    char: Y.stringTabChar,
                    msg: "Tab character (\\t, x09) not allowed in prose value string.",
                  });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ev = function (L, J, Y, Z) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
                break;
              case W.NOMATCH:
                Z.errors.push({
                  line: Z.findLine(Z.lines, O.prosValOpen),
                  char: O.prosValOpen,
                  msg: "Prose value operator(<...>) opened but not closed.",
                }),
                  (O.basicError = !0),
                  (O.prosValOpen = null);
                break;
              case W.MATCH:
                Z.errors.push({
                  line: Z.findLine(Z.lines, O.prosValOpen),
                  char: O.prosValOpen,
                  msg: "Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar.",
                }),
                  (O.prosValOpen = null);
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          ek = function (L, J, Y, Z) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                (O = {
                  groupOpen: Y,
                  groupError: !1,
                  optionOpen: null,
                  optionError: !1,
                  tlsOpen: null,
                  clsOpen: null,
                  prosValOpen: null,
                  basicError: !1,
                }),
                  Z.altStack.push(O);
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eE = function (L, J, Y, Z) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
                break;
              case W.NOMATCH:
                Z.errors.push({
                  line: Z.findLine(Z.lines, O.groupOpen),
                  char: O.groupOpen,
                  msg: 'Group "(...)" opened but not closed.',
                }),
                  ((O = Z.altStack.pop()).groupError = !0);
                break;
              case W.MATCH:
                O = Z.altStack.pop();
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eS = function (L, J, Y, Z) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                (O = {
                  groupOpen: null,
                  groupError: !1,
                  optionOpen: Y,
                  optionError: !1,
                  tlsOpen: null,
                  clsOpen: null,
                  prosValOpen: null,
                  basicError: !1,
                }),
                  Z.altStack.push(O);
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eP = function (L, J, Y, Z) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
                break;
              case W.NOMATCH:
                Z.errors.push({
                  line: Z.findLine(Z.lines, O.optionOpen),
                  char: O.optionOpen,
                  msg: 'Option "[...]" opened but not closed.',
                }),
                  ((O = Z.altStack.pop()).optionError = !0);
                break;
              case W.MATCH:
                O = Z.altStack.pop();
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eC = function (L, J, Y, Z) {
            switch (L.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                !1 === O.basicError &&
                  Z.errors.push({
                    line: Z.findLine(Z.lines, Y, Z.charsLength),
                    char: Y,
                    msg: "Unrecognized SABNF element.",
                  });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eB = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                if (1 === O.phraseLength && Y.strict) {
                  let O = 13 === L[J] ? "CR" : "LF";
                  Y.errors.push({
                    line: Y.findLine(Y.lines, J, Y.charsLength),
                    char: J,
                    msg: `Line end '${O}' found - strict ABNF specified, only CRLF allowed.`,
                  });
                }
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eO = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
              case W.NOMATCH:
                break;
              case W.MATCH:
                Y.errors.push({
                  line: Y.findLine(Y.lines, J, Y.charsLength),
                  char: J,
                  msg: "Unrecognized grammar element or characters.",
                });
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          },
          eT = function (O, L, J, Y) {
            switch (O.state) {
              case W.ACTIVE:
              case W.EMPTY:
                break;
              case W.NOMATCH:
              case W.MATCH:
                Y.repCount += 1;
                break;
              default:
                throw Error(`${T}synFile: unrecognized case.`);
            }
          };
        (this.callbacks = []),
          (this.callbacks.andop = er),
          (this.callbacks.basicelementerr = eC),
          (this.callbacks.clsclose = eb),
          (this.callbacks.clsopen = ey),
          (this.callbacks.clsstring = em),
          (this.callbacks.definedaserror = et),
          (this.callbacks.file = Y),
          (this.callbacks.groupclose = eE),
          (this.callbacks.groupopen = ek),
          (this.callbacks.lineenderror = eO),
          (this.callbacks.lineend = eB),
          (this.callbacks.notop = en),
          (this.callbacks.optionclose = eP),
          (this.callbacks.optionopen = eS),
          (this.callbacks.prosvalclose = ev),
          (this.callbacks.prosvalopen = eA),
          (this.callbacks.prosvalstring = ew),
          (this.callbacks.repetition = eT),
          (this.callbacks.rule = Z),
          (this.callbacks.ruleerror = X),
          (this.callbacks.rulenameerror = ee),
          (this.callbacks.stringtab = ep),
          (this.callbacks.tlsclose = eg),
          (this.callbacks.tlsopen = eh),
          (this.callbacks.tlsstring = ed),
          (this.callbacks.udtop = eu),
          (this.callbacks.bkaop = es),
          (this.callbacks.bknop = ei),
          (this.callbacks.bkrop = ec),
          (this.callbacks.abgop = ea),
          (this.callbacks.aenop = eo);
      };
    },
    80407: function (O, T, L) {
      let { Buffer: J } = L(30410),
        W = L(98199),
        Y = "UTF8",
        Z = "UTF16",
        X = "UTF16BE",
        ee = "UTF16LE",
        et = "UTF32",
        er = "UTF32BE",
        en = "UTF32LE",
        es = "UINT7",
        ei = "ASCII",
        ea = "BINARY",
        eo = "UINT8",
        ec = "UINT16",
        eu = "UINT16LE",
        eh = "UINT16BE",
        ed = "UINT32",
        ep = "UINT32LE",
        eg = "UINT32BE",
        ey = "ESCAPED",
        em = "STRING",
        eb = function (O) {
          O.type = Y;
          let T = O.data;
          (O.bom = 0),
            T.length >= 3 &&
              239 === T[0] &&
              187 === T[1] &&
              191 === T[2] &&
              (O.bom = 3);
        },
        eA = function (O) {
          let T = O.data;
          switch (((O.bom = 0), O.type)) {
            case Z:
              (O.type = X),
                T.length >= 2 &&
                  (254 === T[0] && 255 === T[1]
                    ? (O.bom = 2)
                    : 255 === T[0] &&
                      254 === T[1] &&
                      ((O.type = ee), (O.bom = 2)));
              break;
            case X:
              if (((O.type = X), T.length >= 2)) {
                if (254 === T[0] && 255 === T[1]) O.bom = 2;
                else if (255 === T[0] && 254 === T[1])
                  throw TypeError(
                    `src type: "${X}" specified but BOM is for "${ee}"`
                  );
              }
              break;
            case ee:
              if (((O.type = ee), T.length >= 0)) {
                if (254 === T[0] && 255 === T[1])
                  throw TypeError(
                    `src type: "${ee}" specified but BOM is for "${X}"`
                  );
                255 === T[0] && 254 === T[1] && (O.bom = 2);
              }
              break;
            default:
              throw TypeError(`UTF16 BOM: src type "${O.type}" unrecognized`);
          }
        },
        ew = function (O) {
          let T = O.data;
          switch (((O.bom = 0), O.type)) {
            case et:
              (O.type = er),
                T.length >= 4 &&
                  (0 === T[0] &&
                    0 === T[1] &&
                    254 === T[2] &&
                    255 === T[3] &&
                    (O.bom = 4),
                  255 === T[0] &&
                    254 === T[1] &&
                    0 === T[2] &&
                    0 === T[3] &&
                    ((O.type = en), (O.bom = 4)));
              break;
            case er:
              if (
                ((O.type = er),
                T.length >= 4 &&
                  (0 === T[0] &&
                    0 === T[1] &&
                    254 === T[2] &&
                    255 === T[3] &&
                    (O.bom = 4),
                  255 === T[0] && 254 === T[1] && 0 === T[2] && 0 === T[3]))
              )
                throw TypeError(
                  `src type: ${er} specified but BOM is for ${en}"`
                );
              break;
            case en:
              if (((O.type = en), T.length >= 4)) {
                if (0 === T[0] && 0 === T[1] && 254 === T[2] && 255 === T[3])
                  throw TypeError(
                    `src type: "${en}" specified but BOM is for "${er}"`
                  );
                255 === T[0] &&
                  254 === T[1] &&
                  0 === T[2] &&
                  0 === T[3] &&
                  (O.bom = 4);
              }
              break;
            default:
              throw TypeError(`UTF32 BOM: src type "${O.type}" unrecognized`);
          }
        },
        ev = function (O, T) {
          let L = (function (O) {
            let T = { type: "", base64: !1 },
              L = /^(base64:)?([a-zA-Z0-9]+)$/i.exec(O);
            return (
              L &&
                (L[2] && (T.type = L[2].toUpperCase()),
                L[1] && (T.base64 = !0)),
              T
            );
          })(O.toUpperCase());
          if (L.base64) {
            if (L.type === em)
              throw TypeError(
                `type: "${O} "BASE64:" prefix not allowed with type ${em}`
              );
            if (J.isBuffer(T)) L.data = W.base64.decode(T);
            else if ("string" == typeof T) {
              let O = J.from(T, "ascii");
              L.data = W.base64.decode(O);
            } else
              throw TypeError(
                `type: "${O} unrecognized data type: typeof(data): ${typeof T}`
              );
          } else L.data = T;
          switch (L.type) {
            case Y:
              eb(L);
              break;
            case Z:
            case X:
            case ee:
              eA(L);
              break;
            case et:
            case er:
            case en:
              ew(L);
              break;
            case ec:
              L.type = eh;
              break;
            case ed:
              L.type = eg;
              break;
            case ei:
              L.type = es;
              break;
            case ea:
              L.type = eo;
              break;
            case es:
            case eo:
            case eu:
            case eh:
            case ep:
            case eg:
            case em:
            case ey:
              break;
            default:
              throw TypeError(`type: "${O}" not recognized`);
          }
          if (L.type === em) {
            if ("string" != typeof L.data)
              throw TypeError(`type: "${O}" but data is not a string`);
          } else if (!J.isBuffer(L.data))
            throw TypeError(`type: "${O}" but data is not a Buffer`);
          return L;
        },
        ek = function (O, T) {
          function L(O) {
            let T, L;
            let J = { crlf: !1, lf: !1, base64: !1, type: "" },
              W = !0;
            for (; W; ) {
              if (((L = O), "CRLF:" === (T = O.slice(0, 5)))) {
                (J.crlf = !0), (L = O.slice(5));
                break;
              }
              "LF:" === (T = O.slice(0, 3)) && ((J.lf = !0), (L = O.slice(3)));
              break;
            }
            return (
              1 === (T = L.split(":")).length
                ? (J.type = T[0])
                : 2 === T.length &&
                  "BASE64" === T[1] &&
                  ((J.base64 = !0), (J.type = T[0])),
              J
            );
          }
          if (!Array.isArray(T))
            throw TypeError(`dst chars: not array: "${typeof T}`);
          if ("string" != typeof O)
            throw TypeError(`dst type: not string: "${typeof O}`);
          let J = L(O.toUpperCase());
          switch (J.type) {
            case Y:
            case X:
            case ee:
            case er:
            case en:
            case es:
            case eo:
            case eu:
            case eh:
            case ep:
            case eg:
            case ey:
              break;
            case em:
              if (J.base64)
                throw TypeError(`":BASE64" suffix not allowed with type ${em}`);
              break;
            case ei:
              J.type = es;
              break;
            case ea:
              J.type = eo;
              break;
            case Z:
              J.type = X;
              break;
            case et:
              J.type = er;
              break;
            case ec:
              J.type = eh;
              break;
            case ed:
              J.type = eg;
              break;
            default:
              throw TypeError(
                `dst type unrecognized: "${O}" : must have form [crlf:|lf:]type[:base64]`
              );
          }
          return J;
        },
        eE = function (O, T) {
          switch (O) {
            case Y:
              return W.utf8.encode(T);
            case X:
              return W.utf16be.encode(T);
            case ee:
              return W.utf16le.encode(T);
            case er:
              return W.utf32be.encode(T);
            case en:
              return W.utf32le.encode(T);
            case es:
              return W.uint7.encode(T);
            case eo:
              return W.uint8.encode(T);
            case eh:
              return W.uint16be.encode(T);
            case eu:
              return W.uint16le.encode(T);
            case eg:
              return W.uint32be.encode(T);
            case ep:
              return W.uint32le.encode(T);
            case em:
              return W.string.encode(T);
            case ey:
              return W.escaped.encode(T);
            default:
              throw TypeError(`encode type "${O}" not recognized`);
          }
        },
        eS = function (O) {
          switch (O.type) {
            case Y:
              return W.utf8.decode(O.data, O.bom);
            case ee:
              return W.utf16le.decode(O.data, O.bom);
            case X:
              return W.utf16be.decode(O.data, O.bom);
            case er:
              return W.utf32be.decode(O.data, O.bom);
            case en:
              return W.utf32le.decode(O.data, O.bom);
            case es:
              return W.uint7.decode(O.data);
            case eo:
              return W.uint8.decode(O.data);
            case eh:
              return W.uint16be.decode(O.data);
            case eu:
              return W.uint16le.decode(O.data);
            case eg:
              return W.uint32be.decode(O.data);
            case ep:
              return W.uint32le.decode(O.data);
            case em:
              return W.string.decode(O.data);
            case ey:
              return W.escaped.decode(O.data);
            default:
              throw TypeError(`decode type "${O.type}" not recognized`);
          }
        };
      (T.decode = function (O, T) {
        return eS(ev(O, T));
      }),
        (T.encode = function (O, T) {
          let L, J;
          let Y = ek(O, T);
          return (
            Y.crlf
              ? ((L = W.lineEnds.crlf(T)), (J = eE(Y.type, L)))
              : Y.lf
              ? ((L = W.lineEnds.lf(T)), (J = eE(Y.type, L)))
              : (J = eE(Y.type, T)),
            Y.base64 && (J = W.base64.encode(J)),
            J
          );
        });
      let eP = function (O, L, J) {
        return T.encode(J, T.decode(O, L));
      };
      T.convert = eP;
    },
    98199: function (O, T, L) {
      let { Buffer: J } = L(30410),
        W = 4294967292,
        Y = 4294967293,
        Z = 4294967294,
        X = 4294967295,
        ee = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023],
        et = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0A",
          "0B",
          "0C",
          "0D",
          "0E",
          "0F",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1A",
          "1B",
          "1C",
          "1D",
          "1E",
          "1F",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2A",
          "2B",
          "2C",
          "2D",
          "2E",
          "2F",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3A",
          "3B",
          "3C",
          "3D",
          "3E",
          "3F",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4A",
          "4B",
          "4C",
          "4D",
          "4E",
          "4F",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5A",
          "5B",
          "5C",
          "5D",
          "5E",
          "5F",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6A",
          "6B",
          "6C",
          "6D",
          "6E",
          "6F",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7A",
          "7B",
          "7C",
          "7D",
          "7E",
          "7F",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8A",
          "8B",
          "8C",
          "8D",
          "8E",
          "8F",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9A",
          "9B",
          "9C",
          "9D",
          "9E",
          "9F",
          "A0",
          "A1",
          "A2",
          "A3",
          "A4",
          "A5",
          "A6",
          "A7",
          "A8",
          "A9",
          "AA",
          "AB",
          "AC",
          "AD",
          "AE",
          "AF",
          "B0",
          "B1",
          "B2",
          "B3",
          "B4",
          "B5",
          "B6",
          "B7",
          "B8",
          "B9",
          "BA",
          "BB",
          "BC",
          "BD",
          "BE",
          "BF",
          "C0",
          "C1",
          "C2",
          "C3",
          "C4",
          "C5",
          "C6",
          "C7",
          "C8",
          "C9",
          "CA",
          "CB",
          "CC",
          "CD",
          "CE",
          "CF",
          "D0",
          "D1",
          "D2",
          "D3",
          "D4",
          "D5",
          "D6",
          "D7",
          "D8",
          "D9",
          "DA",
          "DB",
          "DC",
          "DD",
          "DE",
          "DF",
          "E0",
          "E1",
          "E2",
          "E3",
          "E4",
          "E5",
          "E6",
          "E7",
          "E8",
          "E9",
          "EA",
          "EB",
          "EC",
          "ED",
          "EE",
          "EF",
          "F0",
          "F1",
          "F2",
          "F3",
          "F4",
          "F5",
          "F6",
          "F7",
          "F8",
          "F9",
          "FA",
          "FB",
          "FC",
          "FD",
          "FE",
          "FF",
        ],
        er =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split(
            ""
          ),
        en = [];
      er.forEach((O) => {
        en.push(O.charCodeAt(0));
      }),
        (T.utf8 = {
          encode(O) {
            let T = [];
            return (
              O.forEach((O) => {
                if (O >= 0 && O <= 127) T.push(O);
                else if (O <= 2047)
                  T.push(192 + ((O >> 6) & ee[5])), T.push(128 + (O & ee[6]));
                else if (O < 55296 || (O > 57343 && O <= 65535))
                  T.push(224 + ((O >> 12) & ee[4])),
                    T.push(128 + ((O >> 6) & ee[6])),
                    T.push(128 + (O & ee[6]));
                else if (O >= 65536 && O <= 1114111) {
                  let L = (O >> 16) & ee[5];
                  T.push(240 + (L >> 2)),
                    T.push(128 + ((L & ee[2]) << 4) + ((O >> 12) & ee[4])),
                    T.push(128 + ((O >> 6) & ee[6])),
                    T.push(128 + (O & ee[6]));
                } else
                  throw RangeError(
                    `utf8.encode: character out of range: char: ${O}`
                  );
              }),
              J.from(T)
            );
          },
          decode(O, T) {
            let L, J, et, er, en, es;
            function ei(O, T) {
              if ((192 & T) != 128) return Y;
              let L = ((O & ee[5]) << 6) + (T & ee[6]);
              return L < 128 ? W : L;
            }
            function ea(O, T, L) {
              if ((192 & L) != 128 || (192 & T) != 128) return Y;
              let J = ((O & ee[4]) << 12) + ((T & ee[6]) << 6) + (L & ee[6]);
              return J < 2048 ? W : J >= 55296 && J <= 57343 ? Z : J;
            }
            function eo(O, T, L, J) {
              if ((192 & J) != 128 || (192 & L) != 128 || (192 & T) != 128)
                return Y;
              let X =
                ((((O & ee[3]) << 2) + ((T >> 4) & ee[2])) << 16) +
                ((T & ee[4]) << 12) +
                ((L & ee[6]) << 6) +
                (J & ee[6]);
              return X < 65536 ? W : X > 1114111 ? Z : X;
            }
            let ec = O.length,
              eu = T ? 3 : 0,
              eh = [];
            for (; eu < ec; ) {
              (J = O[eu]), (L = X);
              let T = !0;
              for (; T; ) {
                if (J >= 0 && J <= 127) {
                  (L = J), (es = 1);
                  break;
                }
                if ((et = eu + 1) < ec && J >= 194 && J <= 223) {
                  (L = ei(J, O[et])), (es = 2);
                  break;
                }
                if ((er = eu + 2) < ec && J >= 224 && J <= 239) {
                  (L = ea(J, O[et], O[er])), (es = 3);
                  break;
                }
                (en = eu + 3) < ec &&
                  J >= 240 &&
                  J <= 244 &&
                  ((L = eo(J, O[et], O[er], O[en])), (es = 4));
                break;
              }
              if (L > 1114111) {
                let O = `byte[${eu}]`;
                if (L === X)
                  throw RangeError(
                    `utf8.decode: ill-formed UTF8 byte sequence found at: ${O}`
                  );
                if (L === Y)
                  throw RangeError(
                    `utf8.decode: illegal trailing byte found at: ${O}`
                  );
                if (L === Z)
                  throw RangeError(
                    `utf8.decode: code point out of range found at: ${O}`
                  );
                if (L === W)
                  throw RangeError(
                    `utf8.decode: non-shortest form found at: ${O}`
                  );
                throw RangeError(
                  `utf8.decode: unrecognized error found at: ${O}`
                );
              }
              eh.push(L), (eu += es);
            }
            return eh;
          },
        }),
        (T.utf16be = {
          encode(O) {
            let T, L, W;
            let Y = [];
            for (let J = 0; J < O.length; J += 1)
              if (((T = O[J]) >= 0 && T <= 55295) || (T >= 57344 && T <= 65535))
                Y.push((T >> 8) & ee[8]), Y.push(T & ee[8]);
              else if (T >= 65536 && T <= 1114111)
                (L = 55296 + ((W = T - 65536) >> 10)),
                  (W = 56320 + (W & ee[10])),
                  Y.push((L >> 8) & ee[8]),
                  Y.push(L & ee[8]),
                  Y.push((W >> 8) & ee[8]),
                  Y.push(W & ee[8]);
              else
                throw RangeError(
                  `utf16be.encode: UTF16BE value out of range: char[${J}]: ${T}`
                );
            return J.from(Y);
          },
          decode(O, T) {
            let L, J, W, Y, Z, X;
            if (O.length % 2 > 0)
              throw RangeError(
                `utf16be.decode: data length must be even multiple of 2: length: ${O.length}`
              );
            let ee = [],
              et = O.length,
              er = T ? 2 : 0,
              en = 0;
            for (; er < et; ) {
              let T = !0;
              for (; T; ) {
                if ((W = er + 1) < et) {
                  if ((Z = (O[er] << 8) + O[W]) < 55296 || Z > 57343) {
                    (L = Z), (J = 2);
                    break;
                  }
                  if (
                    (Y = er + 3) < et &&
                    ((X = (O[er + 2] << 8) + O[Y]),
                    Z <= 56319 && X >= 56320 && X <= 57343)
                  ) {
                    (L = 65536 + ((Z - 55296) << 10) + (X - 56320)), (J = 4);
                    break;
                  }
                }
                throw RangeError(
                  `utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${er}]`
                );
              }
              (ee[en++] = L), (er += J);
            }
            return ee;
          },
        }),
        (T.utf16le = {
          encode(O) {
            let T, L, W;
            let Y = [];
            for (let J = 0; J < O.length; J += 1)
              if (((T = O[J]) >= 0 && T <= 55295) || (T >= 57344 && T <= 65535))
                Y.push(T & ee[8]), Y.push((T >> 8) & ee[8]);
              else if (T >= 65536 && T <= 1114111)
                (L = 55296 + ((W = T - 65536) >> 10)),
                  (W = 56320 + (W & ee[10])),
                  Y.push(L & ee[8]),
                  Y.push((L >> 8) & ee[8]),
                  Y.push(W & ee[8]),
                  Y.push((W >> 8) & ee[8]);
              else
                throw RangeError(
                  `utf16le.encode: UTF16LE value out of range: char[${J}]: ${T}`
                );
            return J.from(Y);
          },
          decode(O, T) {
            let L, J, W, Y, Z, X;
            if (O.length % 2 > 0)
              throw RangeError(
                `utf16le.decode: data length must be even multiple of 2: length: ${O.length}`
              );
            let ee = [],
              et = O.length,
              er = T ? 2 : 0,
              en = 0;
            for (; er < et; ) {
              let T = !0;
              for (; T; ) {
                if ((W = er + 1) < et) {
                  if ((Z = (O[W] << 8) + O[er]) < 55296 || Z > 57343) {
                    (L = Z), (J = 2);
                    break;
                  }
                  if (
                    (Y = er + 3) < et &&
                    ((X = (O[Y] << 8) + O[er + 2]),
                    Z <= 56319 && X >= 56320 && X <= 57343)
                  ) {
                    (L = 65536 + ((Z - 55296) << 10) + (X - 56320)), (J = 4);
                    break;
                  }
                }
                throw RangeError(
                  `utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${er}]`
                );
              }
              (ee[en++] = L), (er += J);
            }
            return ee;
          },
        }),
        (T.utf32be = {
          encode(O) {
            let T = J.alloc(4 * O.length),
              L = 0;
            return (
              O.forEach((O) => {
                if ((O >= 55296 && O <= 57343) || O > 1114111)
                  throw RangeError(
                    `utf32be.encode: UTF32BE character code out of range: char[${
                      L / 4
                    }]: ${O}`
                  );
                (T[L++] = (O >> 24) & ee[8]),
                  (T[L++] = (O >> 16) & ee[8]),
                  (T[L++] = (O >> 8) & ee[8]),
                  (T[L++] = O & ee[8]);
              }),
              T
            );
          },
          decode(O, T) {
            if (O.length % 4 > 0)
              throw RangeError(
                `utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${O.length}`
              );
            let L = [],
              J = T ? 4 : 0;
            for (; J < O.length; J += 4) {
              let T =
                (O[J] << 24) + (O[J + 1] << 16) + (O[J + 2] << 8) + O[J + 3];
              if ((T >= 55296 && T <= 57343) || T > 1114111)
                throw RangeError(
                  `utf32be.decode: UTF32BE character code out of range: char[${
                    J / 4
                  }]: ${T}`
                );
              L.push(T);
            }
            return L;
          },
        }),
        (T.utf32le = {
          encode(O) {
            let T = J.alloc(4 * O.length),
              L = 0;
            return (
              O.forEach((O) => {
                if ((O >= 55296 && O <= 57343) || O > 1114111)
                  throw RangeError(
                    `utf32le.encode: UTF32LE character code out of range: char[${
                      L / 4
                    }]: ${O}`
                  );
                (T[L++] = O & ee[8]),
                  (T[L++] = (O >> 8) & ee[8]),
                  (T[L++] = (O >> 16) & ee[8]),
                  (T[L++] = (O >> 24) & ee[8]);
              }),
              T
            );
          },
          decode(O, T) {
            if (O.length % 4 > 0)
              throw RangeError(
                `utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${O.length}`
              );
            let L = [],
              J = T ? 4 : 0;
            for (; J < O.length; J += 4) {
              let T =
                (O[J + 3] << 24) + (O[J + 2] << 16) + (O[J + 1] << 8) + O[J];
              if ((T >= 55296 && T <= 57343) || T > 1114111)
                throw RangeError(
                  `utf32le.encode: UTF32LE character code out of range: char[${
                    J / 4
                  }]: ${T}`
                );
              L.push(T);
            }
            return L;
          },
        }),
        (T.uint7 = {
          encode(O) {
            let T = J.alloc(O.length);
            for (let L = 0; L < O.length; L += 1) {
              if (O[L] > 127)
                throw RangeError(
                  `uint7.encode: UINT7 character code out of range: char[${L}]: ${O[L]}`
                );
              T[L] = O[L];
            }
            return T;
          },
          decode(O) {
            let T = [];
            for (let L = 0; L < O.length; L += 1) {
              if (O[L] > 127)
                throw RangeError(
                  `uint7.decode: UINT7 character code out of range: byte[${L}]: ${O[L]}`
                );
              T[L] = O[L];
            }
            return T;
          },
        }),
        (T.uint8 = {
          encode(O) {
            let T = J.alloc(O.length);
            for (let L = 0; L < O.length; L += 1) {
              if (O[L] > 255)
                throw RangeError(
                  `uint8.encode: UINT8 character code out of range: char[${L}]: ${O[L]}`
                );
              T[L] = O[L];
            }
            return T;
          },
          decode(O) {
            let T = [];
            for (let L = 0; L < O.length; L += 1) T[L] = O[L];
            return T;
          },
        }),
        (T.uint16be = {
          encode(O) {
            let T = J.alloc(2 * O.length),
              L = 0;
            return (
              O.forEach((O) => {
                if (O > 65535)
                  throw RangeError(
                    `uint16be.encode: UINT16BE character code out of range: char[${
                      L / 2
                    }]: ${O}`
                  );
                (T[L++] = (O >> 8) & ee[8]), (T[L++] = O & ee[8]);
              }),
              T
            );
          },
          decode(O) {
            if (O.length % 2 > 0)
              throw RangeError(
                `uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${O.length}`
              );
            let T = [];
            for (let L = 0; L < O.length; L += 2)
              T.push((O[L] << 8) + O[L + 1]);
            return T;
          },
        }),
        (T.uint16le = {
          encode(O) {
            let T = J.alloc(2 * O.length),
              L = 0;
            return (
              O.forEach((O) => {
                if (O > 65535)
                  throw RangeError(
                    `uint16le.encode: UINT16LE character code out of range: char[${
                      L / 2
                    }]: ${O}`
                  );
                (T[L++] = O & ee[8]), (T[L++] = (O >> 8) & ee[8]);
              }),
              T
            );
          },
          decode(O) {
            if (O.length % 2 > 0)
              throw RangeError(
                `uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${O.length}`
              );
            let T = [];
            for (let L = 0; L < O.length; L += 2)
              T.push((O[L + 1] << 8) + O[L]);
            return T;
          },
        }),
        (T.uint32be = {
          encode(O) {
            let T = J.alloc(4 * O.length),
              L = 0;
            return (
              O.forEach((O) => {
                (T[L++] = (O >> 24) & ee[8]),
                  (T[L++] = (O >> 16) & ee[8]),
                  (T[L++] = (O >> 8) & ee[8]),
                  (T[L++] = O & ee[8]);
              }),
              T
            );
          },
          decode(O) {
            if (O.length % 4 > 0)
              throw RangeError(
                `uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${O.length}`
              );
            let T = [];
            for (let L = 0; L < O.length; L += 4)
              T.push(
                (O[L] << 24) + (O[L + 1] << 16) + (O[L + 2] << 8) + O[L + 3]
              );
            return T;
          },
        }),
        (T.uint32le = {
          encode(O) {
            let T = J.alloc(4 * O.length),
              L = 0;
            return (
              O.forEach((O) => {
                (T[L++] = O & ee[8]),
                  (T[L++] = (O >> 8) & ee[8]),
                  (T[L++] = (O >> 16) & ee[8]),
                  (T[L++] = (O >> 24) & ee[8]);
              }),
              T
            );
          },
          decode(O) {
            if (O.length % 4 > 0)
              throw RangeError(
                `uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${O.length}`
              );
            let T = [];
            for (let L = 0; L < O.length; L += 4)
              T.push(
                (O[L + 3] << 24) + (O[L + 2] << 16) + (O[L + 1] << 8) + O[L]
              );
            return T;
          },
        }),
        (T.string = {
          encode: (O) => T.utf16le.encode(O).toString("utf16le"),
          decode: (O) => T.utf16le.decode(J.from(O, "utf16le"), 0),
        }),
        (T.escaped = {
          encode(O) {
            let T = [];
            for (let L = 0; L < O.length; L += 1) {
              let W = O[L];
              if (96 === W) T.push(W), T.push(W);
              else if (10 === W) T.push(W);
              else if (W >= 32 && W <= 126) T.push(W);
              else {
                let O = "";
                if (W >= 0 && W <= 31) O += `\`x${et[W]}`;
                else if (W >= 127 && W <= 255) O += `\`x${et[W]}`;
                else if (W >= 256 && W <= 65535)
                  O += `\`u${et[(W >> 8) & ee[8]]}${et[W & ee[8]]}`;
                else if (W >= 65536 && W <= 4294967295) {
                  O += "`u{";
                  let T = (W >> 24) & ee[8];
                  T > 0 && (O += et[T]),
                    (O += `${
                      et[(W >> 16) & ee[8]] +
                      et[(W >> 8) & ee[8]] +
                      et[W & ee[8]]
                    }}`);
                } else
                  throw Error(
                    "escape.encode(char): char > 0xffffffff not allowed"
                  );
                J.from(O).forEach((O) => {
                  T.push(O);
                });
              }
            }
            return J.from(T);
          },
          decode(O) {
            let T, L, J;
            function W(O) {
              return (
                (O >= 48 && O <= 57) ||
                (O >= 65 && O <= 70) ||
                (O >= 97 && O <= 102)
              );
            }
            function Y(O, T, L) {
              let J = { char: null, nexti: O + 2, error: !0 };
              if (O + 1 < T && W(L[O]) && W(L[O + 1])) {
                let T = String.fromCodePoint(L[O], L[O + 1]);
                (J.char = parseInt(T, 16)),
                  Number.isNaN(J.char) || (J.error = !1);
              }
              return J;
            }
            function Z(O, T, L) {
              let J = { char: null, nexti: O + 4, error: !0 };
              if (
                O + 3 < T &&
                W(L[O]) &&
                W(L[O + 1]) &&
                W(L[O + 2]) &&
                W(L[O + 3])
              ) {
                let T = String.fromCodePoint(
                  L[O],
                  L[O + 1],
                  L[O + 2],
                  L[O + 3]
                );
                (J.char = parseInt(T, 16)),
                  Number.isNaN(J.char) || (J.error = !1);
              }
              return J;
            }
            function X(O, T, L) {
              let J = { char: null, nexti: O + 4, error: !0 },
                Y = "";
              for (; O < T && W(L[O]); )
                (Y += String.fromCodePoint(L[O])), (O += 1);
              return (
                (J.char = parseInt(Y, 16)),
                125 !== L[O] || Number.isNaN(J.char) || (J.error = !1),
                (J.nexti = O + 1),
                J
              );
            }
            let ee = [],
              et = O.length,
              er = 0;
            for (; er < et; ) {
              let W = !0;
              for (; W; ) {
                if (((J = !0), 96 !== O[er])) {
                  ee.push(O[er]), (er += 1), (J = !1);
                  break;
                }
                if ((T = er + 1) >= et) break;
                if (96 === O[T]) {
                  ee.push(96), (er += 2), (J = !1);
                  break;
                }
                if (120 === O[T]) {
                  if ((L = Y(T + 1, et, O)).error) break;
                  ee.push(L.char), (er = L.nexti), (J = !1);
                  break;
                }
                if (117 === O[T]) {
                  if (123 === O[T + 1]) {
                    if ((L = X(T + 2, et, O)).error) break;
                    ee.push(L.char), (er = L.nexti), (J = !1);
                    break;
                  }
                  if ((L = Z(T + 1, et, O)).error) break;
                  ee.push(L.char), (er = L.nexti), (J = !1);
                }
                break;
              }
              if (J)
                throw Error(
                  `escaped.decode: ill-formed escape sequence at buf[${er}]`
                );
            }
            return ee;
          },
        });
      let es = 13,
        ei = 10;
      (T.lineEnds = {
        crlf(O) {
          let T = [],
            L = 0;
          for (; L < O.length; )
            switch (O[L]) {
              case es:
                L + 1 < O.length && O[L + 1] === ei ? (L += 2) : (L += 1),
                  T.push(es),
                  T.push(ei);
                break;
              case ei:
                T.push(es), T.push(ei), (L += 1);
                break;
              default:
                T.push(O[L]), (L += 1);
            }
          return (
            T.length > 0 && T[T.length - 1] !== ei && (T.push(es), T.push(ei)),
            T
          );
        },
        lf(O) {
          let T = [],
            L = 0;
          for (; L < O.length; )
            switch (O[L]) {
              case es:
                L + 1 < O.length && O[L + 1] === ei ? (L += 2) : (L += 1),
                  T.push(ei);
                break;
              case ei:
                T.push(ei), (L += 1);
                break;
              default:
                T.push(O[L]), (L += 1);
            }
          return T.length > 0 && T[T.length - 1] !== ei && T.push(ei), T;
        },
      }),
        (T.base64 = {
          encode(O) {
            let T, L, W;
            if (0 === O.length) return J.alloc(0);
            let Y = O.length % 3;
            Y = Y > 0 ? 3 - Y : 0;
            let Z = (O.length + Y) / 3,
              X = J.alloc(4 * Z);
            Y > 0 && (Z -= 1), (T = 0), (L = 0);
            for (let J = 0; J < Z; J += 1)
              (W = (O[T++] << 16) + (O[T++] << 8) + O[T++]),
                (X[L++] = en[(W >> 18) & ee[6]]),
                (X[L++] = en[(W >> 12) & ee[6]]),
                (X[L++] = en[(W >> 6) & ee[6]]),
                (X[L++] = en[W & ee[6]]);
            return 0 === Y
              ? X
              : 1 === Y
              ? ((W = (O[T++] << 16) + (O[T] << 8)),
                (X[L++] = en[(W >> 18) & ee[6]]),
                (X[L++] = en[(W >> 12) & ee[6]]),
                (X[L++] = en[(W >> 6) & ee[6]]),
                (X[L] = en[64]),
                X)
              : 2 === Y
              ? ((W = O[T] << 16),
                (X[L++] = en[(W >> 18) & ee[6]]),
                (X[L++] = en[(W >> 12) & ee[6]]),
                (X[L++] = en[64]),
                (X[L] = en[64]),
                X)
              : void 0;
          },
          decode(O) {
            let T, L, W;
            function Y(O) {
              let T = [],
                L = 0;
              for (let J = 0; J < O.length; J += 1) {
                let W = O[J],
                  Y = !0;
                for (; Y && 32 !== W && 9 !== W && 10 !== W && 13 !== W; ) {
                  if (W >= 65 && W <= 90) {
                    T.push(W - 65);
                    break;
                  }
                  if (W >= 97 && W <= 122) {
                    T.push(W - 71);
                    break;
                  }
                  if (W >= 48 && W <= 57) {
                    T.push(W + 4);
                    break;
                  }
                  if (43 === W) {
                    T.push(62);
                    break;
                  }
                  if (47 === W) {
                    T.push(63);
                    break;
                  }
                  if (61 === W) {
                    T.push(64), (L += 1);
                    break;
                  }
                  throw RangeError(
                    `base64.decode: invalid character buf[${J}]: ${W}`
                  );
                }
              }
              if (T.length % 4 > 0)
                throw RangeError(
                  `base64.decode: string length not integral multiple of 4: ${T.length}`
                );
              switch (L) {
                case 0:
                  break;
                case 1:
                  if (64 !== T[T.length - 1])
                    throw RangeError(
                      "base64.decode: one tail character found: not last character"
                    );
                  break;
                case 2:
                  if (64 !== T[T.length - 1] || 64 !== T[T.length - 2])
                    throw RangeError(
                      "base64.decode: two tail characters found: not last characters"
                    );
                  break;
                default:
                  throw RangeError(
                    `base64.decode: more than two tail characters found: ${L}`
                  );
              }
              return { tail: L, buf: J.from(T) };
            }
            if (0 === O.length) return J.alloc(0);
            let Z = Y(O),
              { tail: X } = Z,
              et = Z.buf,
              er = et.length / 4,
              en = J.alloc(3 * er - X);
            X > 0 && (er -= 1), (L = 0), (T = 0);
            for (let O = 0; O < er; O += 1)
              (W =
                (et[T++] << 18) + (et[T++] << 12) + (et[T++] << 6) + et[T++]),
                (en[L++] = (W >> 16) & ee[8]),
                (en[L++] = (W >> 8) & ee[8]),
                (en[L++] = W & ee[8]);
            return (
              1 === X &&
                ((W = (et[T++] << 18) + (et[T++] << 12) + (et[T] << 6)),
                (en[L++] = (W >> 16) & ee[8]),
                (en[L] = (W >> 8) & ee[8])),
              2 === X &&
                ((W = (et[T++] << 18) + (et[T++] << 12)),
                (en[L] = (W >> 16) & ee[8])),
              en
            );
          },
          toString(O) {
            if (O.length % 4 > 0)
              throw RangeError(
                `base64.toString: input buffer length not multiple of 4: ${O.length}`
              );
            let T = "",
              L = 0;
            function J(O, J, W, Y) {
              switch (L) {
                case 76:
                  (T += `\r
${O}${J}${W}${Y}`),
                    (L = 4);
                  break;
                case 75:
                  (T += `${O}\r
${J}${W}${Y}`),
                    (L = 3);
                  break;
                case 74:
                  (T += `${O + J}\r
${W}${Y}`),
                    (L = 2);
                  break;
                case 73:
                  (T += `${O + J + W}\r
${Y}`),
                    (L = 1);
                  break;
                default:
                  (T += O + J + W + Y), (L += 4);
              }
            }
            function W(O) {
              return (
                (O >= 65 && O <= 90) ||
                (O >= 97 && O <= 122) ||
                (O >= 48 && O <= 57) ||
                43 === O ||
                47 === O ||
                61 === O
              );
            }
            for (let T = 0; T < O.length; T += 4) {
              for (let L = T; L < T + 4; L += 1)
                if (!W(O[L]))
                  throw RangeError(
                    `base64.toString: buf[${L}]: ${O[L]} : not valid base64 character code`
                  );
              J(
                String.fromCharCode(O[T]),
                String.fromCharCode(O[T + 1]),
                String.fromCharCode(O[T + 2]),
                String.fromCharCode(O[T + 3])
              );
            }
            return T;
          },
        });
    },
    14749: function (O, T, L) {
      O.exports = function () {
        let O = L(47351),
          T = L(51708),
          J = "ast.js: ",
          W = this,
          Y = null,
          Z = null,
          X = null,
          ee = 0,
          et = [],
          er = [],
          en = [],
          es = [];
        function ei(O) {
          let T = "";
          for (let L = 0; L < O; L += 1) T += " ";
          return T;
        }
        (this.callbacks = []),
          (this.astObject = "astObject"),
          (this.init = function (O, T, L) {
            let ei;
            (en.length = 0),
              (es.length = 0),
              (et.length = 0),
              (ee = 0),
              (Y = O),
              (Z = T),
              (X = L);
            let ea = [];
            for (ei = 0; ei < Y.length; ei += 1) ea.push(Y[ei].lower);
            for (ei = 0; ei < Z.length; ei += 1) ea.push(Z[ei].lower);
            for (ei = 0, ee = Y.length + Z.length; ei < ee; ei += 1)
              (et[ei] = !1), (er[ei] = null);
            for (let O in W.callbacks) {
              let T = O.toLowerCase();
              if ((ei = ea.indexOf(T)) < 0)
                throw Error(`${J}init: node '${O}' not a rule or udt name`);
              "function" == typeof W.callbacks[O] &&
                ((et[ei] = !0), (er[ei] = W.callbacks[O])),
                !0 === W.callbacks[O] && (et[ei] = !0);
            }
          }),
          (this.ruleDefined = function (O) {
            return !1 !== et[O];
          }),
          (this.udtDefined = function (O) {
            return !1 !== et[Y.length + O];
          }),
          (this.down = function (T, L) {
            let J = es.length;
            return (
              en.push(J),
              es.push({
                name: L,
                thisIndex: J,
                thatIndex: null,
                state: O.SEM_PRE,
                callbackIndex: T,
                phraseIndex: null,
                phraseLength: null,
                stack: en.length,
              }),
              J
            );
          }),
          (this.up = function (T, L, J, W) {
            let Y = es.length,
              Z = en.pop();
            return (
              es.push({
                name: L,
                thisIndex: Y,
                thatIndex: Z,
                state: O.SEM_POST,
                callbackIndex: T,
                phraseIndex: J,
                phraseLength: W,
                stack: en.length,
              }),
              (es[Z].thatIndex = Y),
              (es[Z].phraseIndex = J),
              (es[Z].phraseLength = W),
              Y
            );
          }),
          (this.translate = function (T) {
            let L, J;
            for (let W = 0; W < es.length; W += 1)
              (L = er[(J = es[W]).callbackIndex]),
                J.state === O.SEM_PRE
                  ? null !== L &&
                    L(O.SEM_PRE, X, J.phraseIndex, J.phraseLength, T) ===
                      O.SEM_SKIP &&
                    (W = J.thatIndex)
                  : null !== L &&
                    L(O.SEM_POST, X, J.phraseIndex, J.phraseLength, T);
          }),
          (this.setLength = function (O) {
            (es.length = O),
              O > 0 ? (en.length = es[O - 1].stack) : (en.length = 0);
          }),
          (this.getLength = function () {
            return es.length;
          }),
          (this.toXml = function (L) {
            let J = T.charsToDec,
              W = "decimal integer character codes";
            if ("string" == typeof L && L.length >= 3) {
              let O = L.slice(0, 3).toLowerCase();
              "asc" === O
                ? ((J = T.charsToAscii),
                  (W = "ASCII for printing characters, hex for non-printing"))
                : "hex" === O
                ? ((J = T.charsToHex),
                  (W = "hexadecimal integer character codes"))
                : "uni" === O &&
                  ((J = T.charsToUnicode),
                  (W = "Unicode UTF-32 integer character codes"));
            }
            let Y = "",
              Z = 0;
            return (
              (Y +=
                `<?xml version="1.0" encoding="utf-8"?>
<root nodes="${es.length / 2}" characters="${X.length}">
<!-- input string, ${W} -->
` +
                ei(Z + 2) +
                J(X) +
                "\n"),
              es.forEach((T) => {
                T.state === O.SEM_PRE
                  ? ((Z += 1),
                    (Y +=
                      ei(Z) +
                      `<node name="${T.name}" index="${T.phraseIndex}" length="${T.phraseLength}">
` +
                      ei(Z + 2) +
                      J(X, T.phraseIndex, T.phraseLength) +
                      "\n"))
                  : ((Y +=
                      ei(Z) +
                      `</node><!-- name="${T.name}" -->
`),
                    (Z -= 1));
              }),
              (Y += "</root>\n")
            );
          }),
          (this.phrases = function () {
            let T, L;
            let J = {};
            for (T = 0; T < es.length; T += 1)
              (L = es[T]).state === O.SEM_PRE &&
                (Array.isArray(J[L.name]) || (J[L.name] = []),
                J[L.name].push({
                  index: L.phraseIndex,
                  length: L.phraseLength,
                }));
            return J;
          });
      };
    },
    24349: function (O) {
      O.exports = function () {
        let O = "circular-buffer.js: ",
          T = -1,
          L = 0;
        (this.init = function (J) {
          if ("number" != typeof J || J <= 0)
            throw Error(`${O}init: circular buffer size must an integer > 0`);
          (L = Math.ceil(J)), (T = -1);
        }),
          (this.increment = function () {
            return ((T += 1) + L) % L;
          }),
          (this.maxSize = function () {
            return L;
          }),
          (this.items = function () {
            return T + 1;
          }),
          (this.getListIndex = function (O) {
            return -1 === T || O < 0 || O > T || T - O >= L ? -1 : (O + L) % L;
          }),
          (this.forEach = function (O) {
            if (-1 !== T) {
              if (T < L) {
                for (let L = 0; L <= T; L += 1) O(L, L);
                return;
              }
              for (let J = T - L + 1; J <= T; J += 1) O((J + L) % L, J);
            }
          });
      };
    },
    41451: function (O) {
      O.exports = function () {
        return "/* This file automatically generated by jsonToless() and LESS. */\n.apg-mono {\n  font-family: monospace;\n}\n.apg-active {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-match {\n  font-weight: bold;\n  color: #264BFF;\n}\n.apg-empty {\n  font-weight: bold;\n  color: #0fbd0f;\n}\n.apg-nomatch {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-lh-match {\n  font-weight: bold;\n  color: #1A97BA;\n}\n.apg-lb-match {\n  font-weight: bold;\n  color: #5F1687;\n}\n.apg-remainder {\n  font-weight: bold;\n  color: #999999;\n}\n.apg-ctrl-char {\n  font-weight: bolder;\n  font-style: italic;\n  font-size: 0.6em;\n}\n.apg-line-end {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-error {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-phrase {\n  color: #000000;\n  background-color: #8caae6;\n}\n.apg-empty-phrase {\n  color: #0fbd0f;\n}\ntable.apg-state {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th,\ntable.apg-state td {\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th:nth-last-child(2),\ntable.apg-state td:nth-last-child(2) {\n  text-align: right;\n}\ntable.apg-state caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-stats {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats th,\ntable.apg-stats td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace th,\ntable.apg-trace td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace th:last-child,\ntable.apg-trace th:nth-last-child(2),\ntable.apg-trace td:last-child,\ntable.apg-trace td:nth-last-child(2) {\n  text-align: left;\n}\ntable.apg-grammar {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-grammar th,\ntable.apg-grammar td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar th:last-child,\ntable.apg-grammar td:last-child {\n  text-align: left;\n}\ntable.apg-rules {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-rules th,\ntable.apg-rules td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules a {\n  color: #003399 !important;\n}\ntable.apg-rules a:hover {\n  color: #8caae6 !important;\n}\ntable.apg-attrs {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-attrs th,\ntable.apg-attrs td {\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs th:nth-child(1),\ntable.apg-attrs th:nth-child(2),\ntable.apg-attrs th:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs td:nth-child(1),\ntable.apg-attrs td:nth-child(2),\ntable.apg-attrs td:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs a {\n  color: #003399 !important;\n}\ntable.apg-attrs a:hover {\n  color: #8caae6 !important;\n}\n";
      };
    },
    47351: function (O) {
      O.exports = {
        ALT: 1,
        CAT: 2,
        REP: 3,
        RNM: 4,
        TRG: 5,
        TBS: 6,
        TLS: 7,
        UDT: 11,
        AND: 12,
        NOT: 13,
        BKR: 14,
        BKA: 15,
        BKN: 16,
        ABG: 17,
        AEN: 18,
        ACTIVE: 100,
        MATCH: 101,
        EMPTY: 102,
        NOMATCH: 103,
        SEM_PRE: 200,
        SEM_POST: 201,
        SEM_OK: 300,
        SEM_SKIP: 301,
        ATTR_N: 400,
        ATTR_R: 401,
        ATTR_MR: 402,
        LOOKAROUND_NONE: 500,
        LOOKAROUND_AHEAD: 501,
        LOOKAROUND_BEHIND: 502,
        BKR_MODE_UM: 601,
        BKR_MODE_PM: 602,
        BKR_MODE_CS: 603,
        BKR_MODE_CI: 604,
      };
    },
    26979: function (O, T, L) {
      O.exports = {
        ast: L(14749),
        circular: L(24349),
        ids: L(47351),
        parser: L(61054),
        stats: L(66453),
        trace: L(86196),
        utils: L(51708),
        emitcss: L(41451),
        style: L(24568),
      };
    },
    61054: function (O, T, L) {
      O.exports = function () {
        let O, T, J, W, Y;
        let Z = L(47351),
          X = L(51708),
          ee = "parser.js: ",
          et = this;
        (this.ast = null),
          (this.stats = null),
          (this.trace = null),
          (this.callbacks = []);
        let er = null,
          en = null,
          es = 0,
          ei = 0,
          ea = 0,
          eo = null,
          ec = null,
          eu = null,
          eh = null,
          ed = null,
          ep = 0,
          eg = 1 / 0,
          ey = 1 / 0,
          em = function (T, L, J) {
            let Y = `${ee}evaluateRule(): `;
            if (T >= eu.length)
              throw Error(`${Y}rule index: ${T} out of range`);
            if (L >= W) throw Error(`${Y}phrase index: ${L} out of range`);
            let { length: X } = er;
            er.push({ type: Z.RNM, index: T }), O(X, L, J), er.pop();
          },
          eb = function (T, L, J) {
            let Y = `${ee}evaluateUdt(): `;
            if (T >= eh.length) throw Error(`${Y}udt index: ${T} out of range`);
            if (L >= W) throw Error(`${Y}phrase index: ${L} out of range`);
            let { length: X } = er;
            er.push({ type: Z.UDT, empty: eh[T].empty, index: T }),
              O(X, L, J),
              er.pop();
          },
          eA = function () {
            (es = 0),
              (ei = 0),
              (ea = 0),
              (ep = 0),
              (Y = [
                {
                  lookAround: Z.LOOKAROUND_NONE,
                  anchor: 0,
                  charsEnd: 0,
                  charsLength: 0,
                },
              ]),
              (eu = null),
              (eh = null),
              (en = null),
              (T = 0),
              (J = 0),
              (W = 0),
              (eo = null),
              (ec = null),
              (ed = null),
              (er = null);
          },
          ew = function () {
            let O = [],
              T = function () {
                let T = {};
                eu.forEach((O) => {
                  O.isBkr && (T[O.lower] = null);
                }),
                  eh.length > 0 &&
                    eh.forEach((O) => {
                      O.isBkr && (T[O.lower] = null);
                    }),
                  O.push(T);
              },
              L = function () {
                let T = O[O.length - 1],
                  L = {};
                for (let O in T) L[O] = T[O];
                return L;
              };
            (this.push = function () {
              O.push(L());
            }),
              (this.pop = function (T) {
                let L = T;
                if ((L || (L = O.length - 1), L < 1 || L > O.length))
                  throw Error(`${ee}backRef.pop(): bad length: ${L}`);
                return (O.length = L), O[O.length - 1];
              }),
              (this.length = function () {
                return O.length;
              }),
              (this.savePhrase = function (T, L, J) {
                O[O.length - 1][T] = { phraseIndex: L, phraseLength: J };
              }),
              (this.getPhrase = function (T) {
                return O[O.length - 1][T];
              }),
              T();
          },
          ev = function () {
            let O = this;
            (this.state = Z.ACTIVE),
              (this.phraseLength = 0),
              (this.ruleIndex = 0),
              (this.udtIndex = 0),
              (this.lookAround = Y[Y.length - 1]),
              (this.uFrame = new ew()),
              (this.pFrame = new ew()),
              (this.evaluateRule = em),
              (this.evaluateUdt = eb),
              (this.refresh = function () {
                (O.state = Z.ACTIVE),
                  (O.phraseLength = 0),
                  (O.lookAround = Y[Y.length - 1]);
              });
          },
          ek = function () {
            return Y[Y.length - 1];
          },
          eE = function () {
            return Y.length > 1;
          },
          eS = function () {
            return Y[Y.length - 1].lookAround === Z.LOOKAROUND_BEHIND;
          },
          eP = function () {
            let O = `${ee}initializeAst(): `,
              T = !0;
            for (; T; ) {
              if (void 0 === et.ast) {
                et.ast = null;
                break;
              }
              if (null === et.ast) break;
              if ("astObject" !== et.ast.astObject)
                throw Error(`${O}ast object not recognized`);
              break;
            }
            null !== et.ast && et.ast.init(eu, eh, en);
          },
          eC = function () {
            let O = `${ee}initializeTrace(): `,
              T = !0;
            for (; T; ) {
              if (void 0 === et.trace) {
                et.trace = null;
                break;
              }
              if (null === et.trace) break;
              if ("traceObject" !== et.trace.traceObject)
                throw Error(`${O}trace object not recognized`);
              break;
            }
            null !== et.trace && et.trace.init(eu, eh, en);
          },
          eB = function () {
            let O = `${ee}initializeStats(): `,
              T = !0;
            for (; T; ) {
              if (void 0 === et.stats) {
                et.stats = null;
                break;
              }
              if (null === et.stats) break;
              if ("statsObject" !== et.stats.statsObject)
                throw Error(`${O}stats object not recognized`);
              break;
            }
            null !== et.stats && et.stats.init(eu, eh);
          },
          eO = function (O) {
            let T = `${ee}initializeGrammar(): `;
            if (!O) throw Error(`${T}grammar object undefined`);
            if ("grammarObject" !== O.grammarObject)
              throw Error(`${T}bad grammar object`);
            (eu = O.rules), (eh = O.udts);
          },
          eT = function (O) {
            let T = `${ee}initializeStartRule(): `,
              L = null;
            if ("number" == typeof O) {
              if (O >= eu.length)
                throw Error(
                  `${T}start rule index too large: max: ${eu.length}: index: ${O}`
                );
              L = O;
            } else if ("string" == typeof O) {
              let J = O.toLowerCase();
              for (let O = 0; O < eu.length; O += 1)
                if (J === eu[O].lower) {
                  L = eu[O].index;
                  break;
                }
              if (null === L)
                throw Error(`${T}start rule name '${O}' not recognized`);
            } else
              throw Error(
                `${T}type of start rule '${typeof O}' not recognized`
              );
            return L;
          },
          eN = function (O, L, Y) {
            let Z = `${ee}initializeInputChars(): `,
              et = O,
              er = L,
              es = Y;
            if (void 0 === et) throw Error(`${Z}input string is undefined`);
            if (null === et) throw Error(`${Z}input string is null`);
            if ("string" == typeof et) et = X.stringToChars(et);
            else if (!Array.isArray(et))
              throw Error(`${Z}input string is not a string or array`);
            if (et.length > 0 && "number" != typeof et[0])
              throw Error(`${Z}input string not an array of integers`);
            if ("number" != typeof er) er = 0;
            else if ((er = Math.floor(er)) < 0 || er > et.length)
              throw Error(`${Z}input beginning index out of range: ${er}`);
            if ("number" != typeof es) es = et.length - er;
            else if ((es = Math.floor(es)) < 0 || es > et.length - er)
              throw Error(`${Z}input length out of range: ${es}`);
            (en = et), (W = (T = er) + (J = es));
          },
          eR = function () {
            let O, T;
            let L = `${ee}initializeCallbacks(): `;
            for (O = 0, eo = [], ec = []; O < eu.length; O += 1) eo[O] = null;
            for (O = 0; O < eh.length; O += 1) ec[O] = null;
            let J = [];
            for (O = 0; O < eu.length; O += 1) J.push(eu[O].lower);
            for (O = 0; O < eh.length; O += 1) J.push(eh[O].lower);
            for (let W in et.callbacks) {
              if ((O = J.indexOf(W.toLowerCase())) < 0)
                throw Error(
                  `${L}syntax callback '${W}' not a rule or udt name`
                );
              if (
                ((T = et.callbacks[W]) || (T = null),
                "function" == typeof T || null === T)
              )
                O < eu.length ? (eo[O] = T) : (ec[O - eu.length] = T);
              else
                throw Error(
                  `${L}syntax callback[${W}] must be function reference or 'false' (false/null/undefined/etc.)`
                );
            }
            for (O = 0; O < eh.length; O += 1)
              if (null === ec[O])
                throw Error(
                  `${L}all UDT callbacks must be defined. UDT callback[${eh[O].lower}] not a function reference`
                );
          };
        (this.setMaxTreeDepth = function (O) {
          if ("number" != typeof O || (eg = Math.floor(O)) <= 0)
            throw Error(`parser: max tree depth must be integer > 0: ${O}`);
        }),
          (this.setMaxNodeHits = function (O) {
            if ("number" != typeof O || (ey = Math.floor(O)) <= 0)
              throw Error(`parser: max node hits must be integer > 0: ${O}`);
          });
        let eI = function (L, Y, X) {
          let et;
          let es = `${ee}parse(): `;
          eO(L);
          let eo = eT(Y);
          eR(), eC(), eB(), eP();
          let ec = new ev();
          switch (
            (null != X && (ed = X),
            (er = [{ type: Z.RNM, index: eo }]),
            O(0, T, ec),
            (er = null),
            ec.state)
          ) {
            case Z.ACTIVE:
              throw Error(`${es}final state should never be 'ACTIVE'`);
            case Z.NOMATCH:
              et = !1;
              break;
            case Z.EMPTY:
            case Z.MATCH:
              et = ec.phraseLength === J;
              break;
            default:
              throw Error("unrecognized state");
          }
          return {
            success: et,
            state: ec.state,
            length: J,
            matched: ec.phraseLength,
            maxMatched: ep,
            maxTreeDepth: ei,
            nodeHits: ea,
            inputLength: en.length,
            subBegin: T,
            subEnd: W,
            subLength: J,
          };
        };
        (this.parseSubstring = function (O, T, L, J, W, Y) {
          return eA(), eN(L, J, W), eI(O, T, Y);
        }),
          (this.parse = function (O, T, L, J) {
            return eA(), eN(L, 0, L.length), eI(O, T, J);
          });
        let eM = function (T, L, J) {
            let W = er[T];
            for (
              let T = 0;
              T < W.children.length &&
              (O(W.children[T], L, J), J.state === Z.NOMATCH);
              T += 1
            );
          },
          eU = function (T, L, J) {
            let W, Y, X, ee;
            let en = er[T],
              es = J.uFrame.length(),
              ei = J.pFrame.length();
            et.ast && (Y = et.ast.getLength()), (W = !0), (X = L), (ee = 0);
            for (let T = 0; T < en.children.length; T += 1) {
              if ((O(en.children[T], X, J), J.state === Z.NOMATCH)) {
                W = !1;
                break;
              }
              (X += J.phraseLength), (ee += J.phraseLength);
            }
            W
              ? ((J.state = 0 === ee ? Z.EMPTY : Z.MATCH),
                (J.phraseLength = ee))
              : ((J.state = Z.NOMATCH),
                (J.phraseLength = 0),
                J.uFrame.pop(es),
                J.pFrame.pop(ei),
                et.ast && et.ast.setLength(Y));
          },
          eL = function (T, L, J) {
            let Y, X, ee, en;
            let es = er[T];
            if (0 === es.max) {
              (J.state = Z.EMPTY), (J.phraseLength = 0);
              return;
            }
            (X = L), (ee = 0), (en = 0);
            let ei = J.uFrame.length(),
              ea = J.pFrame.length();
            et.ast && (Y = et.ast.getLength());
            let eo = !0;
            for (
              ;
              eo &&
              !(X >= W) &&
              (O(T + 1, X, J),
              J.state !== Z.NOMATCH &&
                J.state !== Z.EMPTY &&
                ((en += 1),
                (ee += J.phraseLength),
                (X += J.phraseLength),
                en !== es.max));

            );
            J.state === Z.EMPTY
              ? ((J.state = 0 === ee ? Z.EMPTY : Z.MATCH),
                (J.phraseLength = ee))
              : en >= es.min
              ? ((J.state = 0 === ee ? Z.EMPTY : Z.MATCH),
                (J.phraseLength = ee))
              : ((J.state = Z.NOMATCH),
                (J.phraseLength = 0),
                J.uFrame.pop(ei),
                J.pFrame.pop(ea),
                et.ast && et.ast.setLength(Y));
          },
          eD = function (O, T, L, J) {
            if (T.phraseLength > L) {
              let J = `${ee}opRNM(${O.name}): callback function error: `;
              throw Error(
                (J += `sysData.phraseLength: ${T.phraseLength} must be <= remaining chars: ${L}`)
              );
            }
            switch (T.state) {
              case Z.ACTIVE:
                if (!0 !== J)
                  throw Error(
                    `${ee}opRNM(${O.name}): callback function return error. ACTIVE state not allowed.`
                  );
                break;
              case Z.EMPTY:
                T.phraseLength = 0;
                break;
              case Z.MATCH:
                0 === T.phraseLength && (T.state = Z.EMPTY);
                break;
              case Z.NOMATCH:
                T.phraseLength = 0;
                break;
              default:
                throw Error(
                  `${ee}opRNM(${O.name}): callback function return error. Unrecognized return state: ${T.state}`
                );
            }
          },
          e_ = function (T, L, J) {
            let Y, X, ee, es, ei, ea;
            let ec = er[T],
              eh = eu[ec.index],
              ep = eo[eh.index],
              eg = !eE();
            if (
              (eg &&
                ((X = et.ast && et.ast.ruleDefined(ec.index)) &&
                  ((Y = et.ast.getLength()),
                  et.ast.down(ec.index, eu[ec.index].name)),
                (es = J.uFrame.length()),
                (ei = J.pFrame.length()),
                J.uFrame.push(),
                J.pFrame.push(),
                (ea = J.pFrame),
                (J.pFrame = new ew())),
              null === ep)
            )
              (ee = er), (er = eh.opcodes), O(0, L, J), (er = ee);
            else {
              let T = W - L;
              (J.ruleIndex = eh.index),
                ep(J, en, L, ed),
                eD(eh, J, T, !0),
                J.state === Z.ACTIVE &&
                  ((ee = er),
                  (er = eh.opcodes),
                  O(0, L, J),
                  (er = ee),
                  (J.ruleIndex = eh.index),
                  ep(J, en, L, ed),
                  eD(eh, J, T, !1));
            }
            eg &&
              (X &&
                (J.state === Z.NOMATCH
                  ? et.ast.setLength(Y)
                  : et.ast.up(ec.index, eh.name, L, J.phraseLength)),
              (J.pFrame = ea),
              J.state === Z.NOMATCH
                ? (J.uFrame.pop(es), J.pFrame.pop(ei))
                : eh.isBkr &&
                  (J.pFrame.savePhrase(eh.lower, L, J.phraseLength),
                  J.uFrame.savePhrase(eh.lower, L, J.phraseLength)));
          },
          eF = function (O, T, L) {
            if (T.phraseLength > L) {
              let J = `${ee}opUDT(${O.name}): callback function error: `;
              throw Error(
                (J += `sysData.phraseLength: ${T.phraseLength} must be <= remaining chars: ${L}`)
              );
            }
            switch (T.state) {
              case Z.ACTIVE:
                throw Error(
                  `${ee}opUDT(${O.name}): callback function return error. ACTIVE state not allowed.`
                );
              case Z.EMPTY:
                if (!1 === O.empty)
                  throw Error(
                    `${ee}opUDT(${O.name}): callback function return error. May not return EMPTY.`
                  );
                T.phraseLength = 0;
                break;
              case Z.MATCH:
                if (0 === T.phraseLength) {
                  if (!1 === O.empty)
                    throw Error(
                      `${ee}opUDT(${O.name}): callback function return error. May not return EMPTY.`
                    );
                  T.state = Z.EMPTY;
                }
                break;
              case Z.NOMATCH:
                T.phraseLength = 0;
                break;
              default:
                throw Error(
                  `${ee}opUDT(${O.name}): callback function return error. Unrecognized return state: ${T.state}`
                );
            }
          },
          eK = function (O, T, L) {
            let J, Y, X, ee, es, ei;
            let ea = er[O],
              eo = eh[ea.index];
            L.UdtIndex = eo.index;
            let ep = !eE();
            ep &&
              ((X = et.ast && et.ast.udtDefined(ea.index)) &&
                ((Y = eu.length + ea.index),
                (J = et.ast.getLength()),
                et.ast.down(Y, eo.name)),
              (ee = L.uFrame.length()),
              (es = L.pFrame.length()),
              L.uFrame.push(),
              L.pFrame.push(),
              (ei = L.pFrame),
              (L.pFrame = new ew()));
            let eg = W - T;
            ec[ea.index](L, en, T, ed),
              eF(eo, L, eg),
              ep &&
                (X &&
                  (L.state === Z.NOMATCH
                    ? et.ast.setLength(J)
                    : et.ast.up(Y, eo.name, T, L.phraseLength)),
                (L.pFrame = ei),
                L.state === Z.NOMATCH
                  ? (L.uFrame.pop(ee), L.pFrame.pop(es))
                  : eo.isBkr &&
                    (L.pFrame.savePhrase(eo.lower, T, L.phraseLength),
                    L.uFrame.savePhrase(eo.lower, T, L.phraseLength)));
          },
          ej = function (L, X, ee) {
            Y.push({
              lookAround: Z.LOOKAROUND_AHEAD,
              anchor: X,
              charsEnd: W,
              charsLength: J,
            }),
              (W = en.length),
              (J = en.length - T),
              O(L + 1, X, ee);
            let et = Y.pop();
            switch (
              ((W = et.charsEnd),
              (J = et.charsLength),
              (ee.phraseLength = 0),
              ee.state)
            ) {
              case Z.EMPTY:
              case Z.MATCH:
                ee.state = Z.EMPTY;
                break;
              case Z.NOMATCH:
                ee.state = Z.NOMATCH;
                break;
              default:
                throw Error(`opAND: invalid state ${ee.state}`);
            }
          },
          eH = function (L, X, ee) {
            Y.push({
              lookAround: Z.LOOKAROUND_AHEAD,
              anchor: X,
              charsEnd: W,
              charsLength: J,
            }),
              (W = en.length),
              (J = en.length - T),
              O(L + 1, X, ee);
            let et = Y.pop();
            switch (
              ((W = et.charsEnd),
              (J = et.charsLength),
              (ee.phraseLength = 0),
              ee.state)
            ) {
              case Z.EMPTY:
              case Z.MATCH:
                ee.state = Z.NOMATCH;
                break;
              case Z.NOMATCH:
                ee.state = Z.EMPTY;
                break;
              default:
                throw Error(`opNOT: invalid state ${ee.state}`);
            }
          },
          e$ = function (O, T, L) {
            let J = er[O];
            (L.state = Z.NOMATCH),
              T < W &&
                J.min <= en[T] &&
                en[T] <= J.max &&
                ((L.state = Z.MATCH), (L.phraseLength = 1));
          },
          eV = function (O, T, L) {
            let J;
            let Y = er[O],
              X = Y.string.length;
            if (((L.state = Z.NOMATCH), T + X <= W)) {
              for (J = 0; J < X; J += 1) if (en[T + J] !== Y.string[J]) return;
              (L.state = Z.MATCH), (L.phraseLength = X);
            }
          },
          eG = function (O, T, L) {
            let J, Y;
            let X = er[O];
            L.state = Z.NOMATCH;
            let ee = X.string.length;
            if (0 === ee) {
              L.state = Z.EMPTY;
              return;
            }
            if (T + ee <= W) {
              for (J = 0; J < ee; J += 1)
                if (
                  ((Y = en[T + J]) >= 65 && Y <= 90 && (Y += 32),
                  Y !== X.string[J])
                )
                  return;
              (L.state = Z.MATCH), (L.phraseLength = ee);
            }
          },
          eJ = function (O, T, L) {
            (L.state = Z.NOMATCH),
              (L.phraseLength = 0),
              (L.state = 0 === T ? Z.EMPTY : Z.NOMATCH);
          },
          ez = function (O, T, L) {
            (L.state = Z.NOMATCH),
              (L.phraseLength = 0),
              (L.state = T === en.length ? Z.EMPTY : Z.NOMATCH);
          },
          eQ = function (O, T, L) {
            let J, Y, X, ee;
            let et = er[O];
            (L.state = Z.NOMATCH),
              (ee =
                et.index < eu.length
                  ? eu[et.index].lower
                  : eh[et.index - eu.length].lower);
            let es =
                et.bkrMode === Z.BKR_MODE_PM
                  ? L.pFrame.getPhrase(ee)
                  : L.uFrame.getPhrase(ee),
              ei = et.bkrCase === Z.BKR_MODE_CI;
            if (null === es) return;
            let ea = es.phraseIndex,
              eo = es.phraseLength;
            if (0 === eo) {
              L.state = Z.EMPTY;
              return;
            }
            if (T + eo <= W) {
              if (ei) {
                for (J = 0; J < eo; J += 1)
                  if (
                    ((Y = en[T + J]),
                    (X = en[ea + J]),
                    Y >= 65 && Y <= 90 && (Y += 32),
                    X >= 65 && X <= 90 && (X += 32),
                    Y !== X)
                  )
                    return;
                (L.state = Z.MATCH), (L.phraseLength = eo);
              } else
                for (J = 0; J < eo; J += 1)
                  if ((Y = en[T + J]) !== (X = en[ea + J])) return;
              (L.state = Z.MATCH), (L.phraseLength = eo);
            }
          },
          eq = function (T, L, J) {
            switch (
              (Y.push({ lookAround: Z.LOOKAROUND_BEHIND, anchor: L }),
              O(T + 1, L, J),
              Y.pop(),
              (J.phraseLength = 0),
              J.state)
            ) {
              case Z.EMPTY:
              case Z.MATCH:
                J.state = Z.EMPTY;
                break;
              case Z.NOMATCH:
                J.state = Z.NOMATCH;
                break;
              default:
                throw Error(`opBKA: invalid state ${J.state}`);
            }
          },
          eW = function (T, L, J) {
            switch (
              (Y.push({ lookAround: Z.LOOKAROUND_BEHIND, anchor: L }),
              O(T + 1, L, J),
              Y.pop(),
              (J.phraseLength = 0),
              J.state)
            ) {
              case Z.EMPTY:
              case Z.MATCH:
                J.state = Z.NOMATCH;
                break;
              case Z.NOMATCH:
                J.state = Z.EMPTY;
                break;
              default:
                throw Error(`opBKN: invalid state ${J.state}`);
            }
          },
          eY = function (T, L, J) {
            let W, Y, X, ee;
            let en = er[T],
              es = J.uFrame.length(),
              ei = J.pFrame.length();
            et.ast && (Y = et.ast.getLength()), (W = !0), (X = L), (ee = 0);
            for (let T = en.children.length - 1; T >= 0; T -= 1)
              if (
                (O(en.children[T], X, J),
                (X -= J.phraseLength),
                (ee += J.phraseLength),
                J.state === Z.NOMATCH)
              ) {
                W = !1;
                break;
              }
            W
              ? ((J.state = 0 === ee ? Z.EMPTY : Z.MATCH),
                (J.phraseLength = ee))
              : ((J.state = Z.NOMATCH),
                (J.phraseLength = 0),
                J.uFrame.pop(es),
                J.pFrame.pop(ei),
                et.ast && et.ast.setLength(Y));
          },
          eZ = function (T, L, J) {
            let W, Y, X, ee;
            let en = er[T];
            (Y = L), (X = 0), (ee = 0);
            let es = J.uFrame.length(),
              ei = J.pFrame.length();
            et.ast && (W = et.ast.getLength());
            let ea = !0;
            for (
              ;
              ea &&
              !(Y <= 0) &&
              (O(T + 1, Y, J),
              J.state !== Z.NOMATCH &&
                J.state !== Z.EMPTY &&
                ((ee += 1),
                (X += J.phraseLength),
                (Y -= J.phraseLength),
                ee !== en.max));

            );
            J.state === Z.EMPTY
              ? ((J.state = 0 === X ? Z.EMPTY : Z.MATCH), (J.phraseLength = X))
              : ee >= en.min
              ? ((J.state = 0 === X ? Z.EMPTY : Z.MATCH), (J.phraseLength = X))
              : ((J.state = Z.NOMATCH),
                (J.phraseLength = 0),
                J.uFrame.pop(es),
                J.pFrame.pop(ei),
                et.ast && et.ast.setLength(W));
          },
          eX = function (O, T, L) {
            let J = er[O];
            if (((L.state = Z.NOMATCH), (L.phraseLength = 0), T > 0)) {
              let O = en[T - 1];
              J.min <= O &&
                O <= J.max &&
                ((L.state = Z.MATCH), (L.phraseLength = 1));
            }
          },
          e0 = function (O, T, L) {
            let J;
            let W = er[O];
            L.state = Z.NOMATCH;
            let Y = W.string.length,
              X = T - Y;
            if (X >= 0) {
              for (J = 0; J < Y; J += 1) if (en[X + J] !== W.string[J]) return;
              (L.state = Z.MATCH), (L.phraseLength = Y);
            }
          },
          e1 = function (O, T, L) {
            let J;
            let W = er[O];
            L.state = Z.NOMATCH;
            let Y = W.string.length;
            if (0 === Y) {
              L.state = Z.EMPTY;
              return;
            }
            let X = T - Y;
            if (X >= 0) {
              for (let O = 0; O < Y; O += 1)
                if (
                  ((J = en[X + O]) >= 65 && J <= 90 && (J += 32),
                  J !== W.string[O])
                )
                  return;
              (L.state = Z.MATCH), (L.phraseLength = Y);
            }
          },
          e2 = function (O, T, L) {
            let J, W, Y, X;
            let ee = er[O];
            (L.state = Z.NOMATCH),
              (L.phraseLength = 0),
              (X =
                ee.index < eu.length
                  ? eu[ee.index].lower
                  : eh[ee.index - eu.length].lower);
            let et =
                ee.bkrMode === Z.BKR_MODE_PM
                  ? L.pFrame.getPhrase(X)
                  : L.uFrame.getPhrase(X),
              es = ee.bkrCase === Z.BKR_MODE_CI;
            if (null === et) return;
            let ei = et.phraseIndex,
              ea = et.phraseLength;
            if (0 === ea) {
              (L.state = Z.EMPTY), (L.phraseLength = 0);
              return;
            }
            let eo = T - ea;
            if (eo >= 0) {
              if (es) {
                for (J = 0; J < ea; J += 1)
                  if (
                    ((W = en[eo + J]),
                    (Y = en[ei + J]),
                    W >= 65 && W <= 90 && (W += 32),
                    Y >= 65 && Y <= 90 && (Y += 32),
                    W !== Y)
                  )
                    return;
                (L.state = Z.MATCH), (L.phraseLength = ea);
              } else
                for (J = 0; J < ea; J += 1)
                  if ((W = en[eo + J]) !== (Y = en[ei + J])) return;
              (L.state = Z.MATCH), (L.phraseLength = ea);
            }
          };
        O = function (O, T, L) {
          let J = !0,
            W = er[O];
          if ((ea += 1) > ey)
            throw Error(`parser: maximum number of node hits exceeded: ${ey}`);
          if ((es += 1) > ei && (ei = es) > eg)
            throw Error(`parser: maximum parse tree depth exceeded: ${eg}`);
          if ((L.refresh(), null !== et.trace)) {
            let O = ek();
            et.trace.down(
              W,
              L.state,
              T,
              L.phraseLength,
              O.anchor,
              O.lookAround
            );
          }
          if (eS())
            switch (W.type) {
              case Z.ALT:
                eM(O, T, L);
                break;
              case Z.CAT:
                eY(O, T, L);
                break;
              case Z.REP:
                eZ(O, T, L);
                break;
              case Z.RNM:
                e_(O, T, L);
                break;
              case Z.UDT:
                eK(O, T, L);
                break;
              case Z.AND:
                ej(O, T, L);
                break;
              case Z.NOT:
                eH(O, T, L);
                break;
              case Z.TRG:
                eX(O, T, L);
                break;
              case Z.TBS:
                e0(O, T, L);
                break;
              case Z.TLS:
                e1(O, T, L);
                break;
              case Z.BKR:
                e2(O, T, L);
                break;
              case Z.BKA:
                eq(O, T, L);
                break;
              case Z.BKN:
                eW(O, T, L);
                break;
              case Z.ABG:
                eJ(O, T, L);
                break;
              case Z.AEN:
                ez(O, T, L);
                break;
              default:
                J = !1;
            }
          else
            switch (W.type) {
              case Z.ALT:
                eM(O, T, L);
                break;
              case Z.CAT:
                eU(O, T, L);
                break;
              case Z.REP:
                eL(O, T, L);
                break;
              case Z.RNM:
                e_(O, T, L);
                break;
              case Z.UDT:
                eK(O, T, L);
                break;
              case Z.AND:
                ej(O, T, L);
                break;
              case Z.NOT:
                eH(O, T, L);
                break;
              case Z.TRG:
                e$(O, T, L);
                break;
              case Z.TBS:
                eV(O, T, L);
                break;
              case Z.TLS:
                eG(O, T, L);
                break;
              case Z.BKR:
                eQ(O, T, L);
                break;
              case Z.BKA:
                eq(O, T, L);
                break;
              case Z.BKN:
                eW(O, T, L);
                break;
              case Z.ABG:
                eJ(O, T, L);
                break;
              case Z.AEN:
                ez(O, T, L);
                break;
              default:
                J = !1;
            }
          if (
            (!eE() && T + L.phraseLength > ep && (ep = T + L.phraseLength),
            null !== et.stats && et.stats.collect(W, L),
            null !== et.trace)
          ) {
            let O = ek();
            et.trace.up(W, L.state, T, L.phraseLength, O.anchor, O.lookAround);
          }
          return (es -= 1), J;
        };
      };
    },
    66453: function (O, T, L) {
      O.exports = function () {
        let O;
        let T = L(47351),
          J = L(51708),
          W = L(24568),
          Y = "stats.js: ",
          Z = [],
          X = [],
          ee = [],
          et = [],
          er = [];
        this.statsObject = "statsObject";
        let en = "stats",
          es = function (O, T) {
            return O.lower < T.lower ? -1 : O.lower > T.lower ? 1 : 0;
          },
          ei = function (O, T) {
            return O.total < T.total ? 1 : O.total > T.total ? -1 : es(O, T);
          },
          ea = function (O, T) {
            return O.index < T.index ? -1 : O.index > T.index ? 1 : 0;
          },
          eo = function () {
            (this.empty = 0),
              (this.match = 0),
              (this.nomatch = 0),
              (this.total = 0);
          },
          ec = function () {
            (ee.length = 0),
              (O = new eo()),
              (ee[T.ALT] = new eo()),
              (ee[T.CAT] = new eo()),
              (ee[T.REP] = new eo()),
              (ee[T.RNM] = new eo()),
              (ee[T.TRG] = new eo()),
              (ee[T.TBS] = new eo()),
              (ee[T.TLS] = new eo()),
              (ee[T.UDT] = new eo()),
              (ee[T.AND] = new eo()),
              (ee[T.NOT] = new eo()),
              (ee[T.BKR] = new eo()),
              (ee[T.BKA] = new eo()),
              (ee[T.BKN] = new eo()),
              (ee[T.ABG] = new eo()),
              (ee[T.AEN] = new eo()),
              (et.length = 0);
            for (let O = 0; O < Z.length; O += 1)
              et.push({
                empty: 0,
                match: 0,
                nomatch: 0,
                total: 0,
                name: Z[O].name,
                lower: Z[O].lower,
                index: Z[O].index,
              });
            if (X.length > 0) {
              er.length = 0;
              for (let O = 0; O < X.length; O += 1)
                er.push({
                  empty: 0,
                  match: 0,
                  nomatch: 0,
                  total: 0,
                  name: X[O].name,
                  lower: X[O].lower,
                  index: X[O].index,
                });
            }
          },
          eu = function (O, L) {
            switch (((O.total += 1), L)) {
              case T.EMPTY:
                O.empty += 1;
                break;
              case T.MATCH:
                O.match += 1;
                break;
              case T.NOMATCH:
                O.nomatch += 1;
                break;
              default:
                throw Error(
                  `${Y}collect(): incStat(): unrecognized state: ${L}`
                );
            }
          },
          eh = function (O, T) {
            return `<tr><td class="${W.CLASS_ACTIVE}">${O}</td><td class="${W.CLASS_EMPTY}">${T.empty}</td><td class="${W.CLASS_MATCH}">${T.match}</td><td class="${W.CLASS_NOMATCH}">${T.nomatch}</td><td class="${W.CLASS_ACTIVE}">${T.total}</td></tr>
`;
          },
          ed = function () {
            return (
              "" +
              (eh("ALT", ee[T.ALT]) +
                eh("CAT", ee[T.CAT]) +
                eh("REP", ee[T.REP]) +
                eh("RNM", ee[T.RNM]) +
                eh("TRG", ee[T.TRG]) +
                eh("TBS", ee[T.TBS]) +
                eh("TLS", ee[T.TLS]) +
                eh("UDT", ee[T.UDT]) +
                eh("AND", ee[T.AND]) +
                eh("NOT", ee[T.NOT]) +
                eh("BKR", ee[T.BKR]) +
                eh("BKA", ee[T.BKA]) +
                eh("BKN", ee[T.BKN]) +
                eh("ABG", ee[T.ABG]) +
                eh("AEN", ee[T.AEN]) +
                eh("totals", O))
            );
          },
          ep = function () {
            let O = "";
            O +=
              "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\n";
            for (let T = 0; T < Z.length; T += 1)
              et[T].total > 0 &&
                (O += `<tr><td class="${W.CLASS_ACTIVE}">${et[T].name}</td><td class="${W.CLASS_EMPTY}">${et[T].empty}</td><td class="${W.CLASS_MATCH}">${et[T].match}</td><td class="${W.CLASS_NOMATCH}">${et[T].nomatch}</td><td class="${W.CLASS_ACTIVE}">${et[T].total}</td></tr>
`);
            if (X.length > 0) {
              O +=
                "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\n";
              for (let T = 0; T < X.length; T += 1)
                er[T].total > 0 &&
                  (O += `<tr><td class="${W.CLASS_ACTIVE}">${er[T].name}</td><td class="${W.CLASS_EMPTY}">${er[T].empty}</td><td class="${W.CLASS_MATCH}">${er[T].match}</td><td class="${W.CLASS_NOMATCH}">${er[T].nomatch}</td><td class="${W.CLASS_ACTIVE}">${er[T].total}</td></tr>
`);
            }
            return O;
          };
        (this.validate = function (O) {
          let T = !1;
          return "string" == typeof O && en === O && (T = !0), T;
        }),
          (this.init = function (O, T) {
            (Z = O), (X = T), ec();
          }),
          (this.collect = function (L, J) {
            eu(O, J.state, J.phraseLength),
              eu(ee[L.type], J.state, J.phraseLength),
              L.type === T.RNM && eu(et[L.index], J.state, J.phraseLength),
              L.type === T.UDT && eu(er[L.index], J.state, J.phraseLength);
          }),
          (this.toHtml = function (O, T) {
            let L = "";
            (L += `<table class="${W.CLASS_STATS}">
`),
              "string" == typeof T &&
                (L += `<caption>${T}</caption>
`),
              (L += `<tr><th class="${W.CLASS_ACTIVE}">ops</th>
<th class="${W.CLASS_EMPTY}">EMPTY</th>
<th class="${W.CLASS_MATCH}">MATCH</th>
<th class="${W.CLASS_NOMATCH}">NOMATCH</th>
<th class="${W.CLASS_ACTIVE}">totals</th></tr>
`);
            let J = !0;
            for (; J; ) {
              if (null == O || "ops" === O) {
                L += ed();
                break;
              }
              if ("index" === O) {
                et.sort(ea), er.length > 0 && er.sort(ea), (L += ed() + ep());
                break;
              }
              if ("hits" === O) {
                et.sort(ei), er.length > 0 && er.sort(ea), (L += ed() + ep());
                break;
              }
              "alpha" === O &&
                (et.sort(es), er.length > 0 && er.sort(es), (L += ed() + ep()));
              break;
            }
            return L + "</table>\n";
          }),
          (this.toHtmlPage = function (O, T, L) {
            return J.htmlToPage(this.toHtml(O, T), L);
          });
      };
    },
    24568: function (O) {
      O.exports = {
        CLASS_MONOSPACE: "apg-mono",
        CLASS_ACTIVE: "apg-active",
        CLASS_EMPTY: "apg-empty",
        CLASS_MATCH: "apg-match",
        CLASS_NOMATCH: "apg-nomatch",
        CLASS_LOOKAHEAD: "apg-lh-match",
        CLASS_LOOKBEHIND: "apg-lb-match",
        CLASS_REMAINDER: "apg-remainder",
        CLASS_CTRLCHAR: "apg-ctrl-char",
        CLASS_LINEEND: "apg-line-end",
        CLASS_ERROR: "apg-error",
        CLASS_PHRASE: "apg-phrase",
        CLASS_EMPTYPHRASE: "apg-empty-phrase",
        CLASS_STATE: "apg-state",
        CLASS_STATS: "apg-stats",
        CLASS_TRACE: "apg-trace",
        CLASS_GRAMMAR: "apg-grammar",
        CLASS_RULES: "apg-rules",
        CLASS_RULESLINK: "apg-rules-link",
        CLASS_ATTRIBUTES: "apg-attrs",
      };
    },
    86196: function (O, T, L) {
      O.exports = function () {
        let O = L(51708),
          T = L(24568),
          J = new (L(24349))(),
          W = L(47351),
          Y = "trace.js: ",
          Z = this,
          X = 16,
          ee = 10,
          et = 8,
          er = 32,
          en = 80,
          es = 5,
          ei = [],
          ea = 5e3,
          eo = -1,
          ec = 0,
          eu = 0,
          eh = [],
          ed = null,
          ep = null,
          eg = null,
          ey = [],
          em = [],
          eb = `<span class="${T.CLASS_LINEEND}">&bull;</span>`,
          eA = `<span class="${T.CLASS_LINEEND}">&hellip;</span>`,
          ew = `<span class="${T.CLASS_EMPTY}">&#120634;</span>`,
          ev = function () {
            let O = function (O) {
                (ey[W.ALT] = O),
                  (ey[W.CAT] = O),
                  (ey[W.REP] = O),
                  (ey[W.TLS] = O),
                  (ey[W.TBS] = O),
                  (ey[W.TRG] = O),
                  (ey[W.AND] = O),
                  (ey[W.NOT] = O),
                  (ey[W.BKR] = O),
                  (ey[W.BKA] = O),
                  (ey[W.BKN] = O),
                  (ey[W.ABG] = O),
                  (ey[W.AEN] = O);
              },
              T = 0;
            for (let O in Z.filter.operators) T += 1;
            if (0 === T) {
              O(!1);
              return;
            }
            for (let T in Z.filter.operators) {
              let L = T.toUpperCase();
              if ("<ALL>" === L) {
                O(!0);
                return;
              }
              if ("<NONE>" === L) {
                O(!1);
                return;
              }
            }
            for (let T in (O(!1), Z.filter.operators)) {
              let O = T.toUpperCase();
              if ("ALT" === O) ey[W.ALT] = !0 === Z.filter.operators[T];
              else if ("CAT" === O) ey[W.CAT] = !0 === Z.filter.operators[T];
              else if ("REP" === O) ey[W.REP] = !0 === Z.filter.operators[T];
              else if ("AND" === O) ey[W.AND] = !0 === Z.filter.operators[T];
              else if ("NOT" === O) ey[W.NOT] = !0 === Z.filter.operators[T];
              else if ("TLS" === O) ey[W.TLS] = !0 === Z.filter.operators[T];
              else if ("TBS" === O) ey[W.TBS] = !0 === Z.filter.operators[T];
              else if ("TRG" === O) ey[W.TRG] = !0 === Z.filter.operators[T];
              else if ("BKR" === O) ey[W.BKR] = !0 === Z.filter.operators[T];
              else if ("BKA" === O) ey[W.BKA] = !0 === Z.filter.operators[T];
              else if ("BKN" === O) ey[W.BKN] = !0 === Z.filter.operators[T];
              else if ("ABG" === O) ey[W.ABG] = !0 === Z.filter.operators[T];
              else if ("AEN" === O) ey[W.AEN] = !0 === Z.filter.operators[T];
              else
                throw Error(
                  `${Y}initOpratorFilter: '${T}' not a valid operator name. Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`
                );
            }
          },
          ek = function () {
            let O, T;
            let L = function (O) {
                (ey[W.RNM] = O), (ey[W.UDT] = O);
                let T = ep.length + eg.length;
                em.length = 0;
                for (let L = 0; L < T; L += 1) em.push(O);
              },
              J = [];
            for (T = 0; T < ep.length; T += 1) J.push(ep[T].lower);
            for (T = 0; T < eg.length; T += 1) J.push(eg[T].lower);
            for (let T in ((em.length = 0), (O = 0), Z.filter.rules)) O += 1;
            if (0 === O) {
              L(!0);
              return;
            }
            for (let O in Z.filter.rules) {
              let T = O.toLowerCase();
              if ("<all>" === T) {
                L(!0);
                return;
              }
              if ("<none>" === T) {
                L(!1);
                return;
              }
            }
            for (let O in (L(!1),
            (ey[W.RNM] = !0),
            (ey[W.UDT] = !0),
            Z.filter.rules)) {
              let L = O.toLowerCase();
              if ((T = J.indexOf(L)) < 0)
                throw Error(
                  `${Y}initRuleFilter: '${O}' not a valid rule or udt name`
                );
              em[T] = !0 === Z.filter.rules[O];
            }
          };
        (this.traceObject = "traceObject"),
          (this.filter = { operators: [], rules: [] }),
          (this.setMaxRecords = function (O, T) {
            if (((eo = -1), "number" == typeof O && O > 0)) ea = Math.ceil(O);
            else {
              ea = 0;
              return;
            }
            "number" == typeof T && (eo = Math.floor(T)) < 0 && (eo = -1);
          }),
          (this.getMaxRecords = function () {
            return ea;
          }),
          (this.getLastRecord = function () {
            return eo;
          }),
          (this.init = function (O, T, L) {
            (ei.length = 0),
              (eh.length = 0),
              (ec = 0),
              (eu = 0),
              (ed = L),
              (ep = O),
              (eg = T),
              ev(),
              ek(),
              J.init(ea);
          });
        let eE = function (O) {
            return O.type === W.RNM
              ? !!ey[O.type] && !!em[O.index]
              : O.type === W.UDT
              ? !!ey[O.type] && !!em[ep.length + O.index]
              : ey[O.type];
          },
          eS = function (O) {
            return -1 === eo || O <= eo;
          };
        (this.down = function (O, T, L, W, Y, Z) {
          eS(ec) &&
            eE(O) &&
            (eh.push(ec),
            (ei[J.increment()] = {
              dirUp: !1,
              depth: eu,
              thisLine: ec,
              thatLine: void 0,
              opcode: O,
              state: T,
              phraseIndex: L,
              phraseLength: W,
              lookAnchor: Y,
              lookAround: Z,
            }),
            (ec += 1),
            (eu += 1));
        }),
          (this.up = function (O, T, L, W, Y, Z) {
            if (eS(ec) && eE(O)) {
              let X = ec,
                ee = eh.pop(),
                et = J.getListIndex(ee);
              -1 !== et && (ei[et].thatLine = X),
                (eu -= 1),
                (ei[J.increment()] = {
                  dirUp: !0,
                  depth: eu,
                  thisLine: X,
                  thatLine: ee,
                  opcode: O,
                  state: T,
                  phraseIndex: L,
                  phraseLength: W,
                  lookAnchor: Y,
                  lookAround: Z,
                }),
                (ec += 1);
            }
          });
        let eP = function () {
          let T, L, Y, Z, X;
          function ee(T, L) {
            let J, Y, Z;
            if (L)
              switch (
                ((T.op = { id: L.type, name: O.opcodeToString(L.type) }),
                (T.opData = void 0),
                L.type)
              ) {
                case W.RNM:
                  T.opData = ep[L.index].name;
                  break;
                case W.UDT:
                  T.opData = eg[L.index].name;
                  break;
                case W.BKR:
                  (J =
                    L.index < ep.length
                      ? ep[L.index].name
                      : eg[L.index - ep.length].name),
                    (Y = L.bkrCase === W.BKR_MODE_CI ? "%i" : "%s"),
                    (Z = L.bkrMode === W.BKR_MODE_UM ? "%u" : "%p"),
                    (T.opData = `\\\\${Y}${Z}${J}`);
                  break;
                case W.TLS:
                  T.opData = [];
                  for (let O = 0; O < L.string.length; O += 1)
                    T.opData.push(L.string[O]);
                  break;
                case W.TBS:
                  T.opData = [];
                  for (let O = 0; O < L.string.length; O += 1)
                    T.opData.push(L.string[O]);
                  break;
                case W.TRG:
                case W.REP:
                  T.opData = [L.min, L.max];
                  break;
                default:
                  throw Error("unrecognized opcode");
              }
            else (T.op = { id: void 0, name: void 0 }), (T.opData = void 0);
          }
          function et(O, T, L) {
            return O === W.MATCH
              ? { index: T, length: L }
              : O === W.NOMATCH || O === W.EMPTY
              ? { index: T, length: 0 }
              : null;
          }
          let er = -1;
          function en(T, L, J) {
            let W = {
              id: er++,
              branch: -1,
              parent: T,
              up: !1,
              down: !1,
              depth: J,
              children: [],
            };
            return (
              L
                ? ((W.down = !0),
                  (W.state = { id: L.state, name: O.stateToString(L.state) }),
                  (W.phrase = null),
                  ee(W, L.opcode))
                : ((W.state = { id: void 0, name: void 0 }),
                  (W.phrase = et()),
                  ee(W, void 0)),
              W
            );
          }
          function es(T, L) {
            L &&
              ((T.up = !0),
              (T.state = { id: L.state, name: O.stateToString(L.state) }),
              (T.phrase = et(L.state, L.phraseIndex, L.phraseLength)),
              T.down || ee(T, L.opcode));
          }
          let ea = 0,
            eo = -1,
            ec = 1;
          function eh(O) {
            if (
              ((eo += 1),
              (O.branch = ec),
              eo > eu && (eu = eo),
              0 === O.children.length)
            )
              ea += 1;
            else
              for (let T = 0; T < O.children.length; T += 1)
                T > 0 && (ec += 1),
                  (O.children[T].leftMost = !1),
                  (O.children[T].rightMost = !1),
                  O.leftMost && (O.children[T].leftMost = 0 === T),
                  O.rightMost &&
                    (O.children[T].rightMost = T === O.children.length - 1),
                  eh(O.children[T]);
            eo -= 1;
          }
          function ey(O, T) {
            let L;
            let J = {};
            if (
              ((J.id = O.id),
              (J.branch = O.branch),
              (J.leftMost = O.leftMost),
              (J.rightMost = O.rightMost),
              (L = O.state.name ? O.state.name : "ACTIVE"),
              (J.state = { id: O.state.id, name: L }),
              (L = O.op.name ? O.op.name : "?"),
              (J.op = { id: O.op.id, name: L }),
              "string" == typeof O.opData)
            )
              J.opData = O.opData;
            else if (Array.isArray(O.opData)) {
              J.opData = [];
              for (let T = 0; T < O.opData.length; T += 1)
                J.opData[T] = O.opData[T];
            } else J.opData = void 0;
            O.phrase
              ? (J.phrase = { index: O.phrase.index, length: O.phrase.length })
              : (J.phrase = null),
              (J.depth = O.depth),
              (J.children = []);
            for (let L = 0; L < O.children.length; L += 1) {
              let W = L !== O.children.length - 1;
              J.children[L] = ey(O.children[L], T, W);
            }
            return J;
          }
          let em = [],
            eb = !0,
            eA = en(null, null, -1);
          for (
            em.push(eA),
              L = eA,
              J.forEach((O) => {
                if (((Z = ei[O]), eb && ((eb = !1), Z.depth > 0))) {
                  let O = Z.dirUp ? Z.depth + 1 : Z.depth;
                  for (let T = 0; T < O; T += 1)
                    (Y = L),
                      (L = en(L, null, T)),
                      em.push(L),
                      Y.children.push(L);
                }
                Z.dirUp
                  ? (es((L = em.pop()), Z), (L = em[em.length - 1]))
                  : ((Y = L),
                    (L = en(L, Z, Z.depth)),
                    em.push(L),
                    Y.children.push(L));
              });
            em.length > 1;

          )
            es((L = em.pop()), null);
          if (0 === eA.children.length)
            throw Error("trace.toTree(): parse tree has no nodes");
          if (0 === em.length)
            throw Error(
              "trace.toTree(): integrity check: dummy root node disappeared?"
            );
          let ew = (T = eA.children[0]);
          for (; T && !T.down && !T.up; ) (ew = T), (T = T.children[0]);
          ((T = ew).leftMost = !0), (T.rightMost = !0), eh(T), (T.branch = 0);
          let ev = {};
          ev.string = [];
          for (let O = 0; O < ed.length; O += 1) ev.string[O] = ed[O];
          ev.rules = [];
          for (let O = 0; O < ep.length; O += 1) ev.rules[O] = ep[O].name;
          ev.udts = [];
          for (let O = 0; O < eg.length; O += 1) ev.udts[O] = eg[O].name;
          return (
            (ev.id = {}),
            (ev.id.ALT = { id: W.ALT, name: "ALT" }),
            (ev.id.CAT = { id: W.CAT, name: "CAT" }),
            (ev.id.REP = { id: W.REP, name: "REP" }),
            (ev.id.RNM = { id: W.RNM, name: "RNM" }),
            (ev.id.TLS = { id: W.TLS, name: "TLS" }),
            (ev.id.TBS = { id: W.TBS, name: "TBS" }),
            (ev.id.TRG = { id: W.TRG, name: "TRG" }),
            (ev.id.UDT = { id: W.UDT, name: "UDT" }),
            (ev.id.AND = { id: W.AND, name: "AND" }),
            (ev.id.NOT = { id: W.NOT, name: "NOT" }),
            (ev.id.BKR = { id: W.BKR, name: "BKR" }),
            (ev.id.BKA = { id: W.BKA, name: "BKA" }),
            (ev.id.BKN = { id: W.BKN, name: "BKN" }),
            (ev.id.ABG = { id: W.ABG, name: "ABG" }),
            (ev.id.AEN = { id: W.AEN, name: "AEN" }),
            (ev.id.ACTIVE = { id: W.ACTIVE, name: "ACTIVE" }),
            (ev.id.MATCH = { id: W.MATCH, name: "MATCH" }),
            (ev.id.EMPTY = { id: W.EMPTY, name: "EMPTY" }),
            (ev.id.NOMATCH = { id: W.NOMATCH, name: "NOMATCH" }),
            (ev.treeDepth = eu),
            (ev.leafNodes = ea),
            (X = T.down ? (T.up ? "none" : "right") : T.up ? "left" : "both"),
            (ev.branchesIncomplete = X),
            (ev.tree = ey(T, T.depth, !1)),
            ev
          );
        };
        (this.toTree = function (O) {
          let T = eP();
          return O ? JSON.stringify(T) : T;
        }),
          (this.toHtmlPage = function (T, L, J) {
            return O.htmlToPage(this.toHtml(T, L), J);
          });
        let eC = function (O, L) {
            let J;
            switch (O) {
              case X:
                J = "hexadecimal";
                break;
              case ee:
                J = "decimal";
                break;
              case et:
                J = "ASCII";
                break;
              case er:
                J = "UNICODE";
                break;
              default:
                throw Error(`${Y}htmlHeader: unrecognized mode: ${O}`);
            }
            let W = "";
            return (
              (W += `<p>display mode: ${J}</p>
<table class="${T.CLASS_TRACE}">
`),
              "string" == typeof L && (W += `<caption>${L}</caption>`),
              W
            );
          },
          eB = function () {
            return `</table>
<p class="${T.CLASS_MONOSPACE}">legend:<br>
(a)&nbsp;-&nbsp;line number<br>
(b)&nbsp;-&nbsp;matching line number<br>
(c)&nbsp;-&nbsp;phrase offset<br>
(d)&nbsp;-&nbsp;phrase length<br>
(e)&nbsp;-&nbsp;tree depth<br>
(f)&nbsp;-&nbsp;operator state<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${T.CLASS_ACTIVE}">&darr;</span>&nbsp;&nbsp;phrase opened<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${T.CLASS_MATCH}">&uarr;M</span> phrase matched<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${T.CLASS_EMPTY}">&uarr;E</span> empty phrase matched<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${T.CLASS_NOMATCH}">&uarr;N</span> phrase not matched<br>
operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>
phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${en} characters of the phrase being matched<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${T.CLASS_MATCH}">matched characters</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${T.CLASS_LOOKAHEAD}">matched characters in look ahead mode</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${T.CLASS_LOOKBEHIND}">matched characters in look behind mode</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${T.CLASS_REMAINDER}">remainder characters(not yet examined by parser)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${T.CLASS_CTRLCHAR}">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${ew} empty string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${eb} end of input string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${eA} input string display truncated<br>
</p>
<p class="${T.CLASS_MONOSPACE}">
<sup>&dagger;</sup>original ABNF operators:<br>
ALT - alternation<br>
CAT - concatenation<br>
REP - repetition<br>
RNM - rule name<br>
TRG - terminal range<br>
TLS - terminal literal string (case insensitive)<br>
TBS - terminal binary string (case sensitive)<br>
<br>
<sup>&Dagger;</sup>super set SABNF operators:<br>
UDT - user-defined terminal<br>
AND - positive look ahead<br>
NOT - negative look ahead<br>
BKA - positive look behind<br>
BKN - negative look behind<br>
BKR - back reference<br>
ABG - anchor - begin of input string<br>
AEN - anchor - end of input string<br>
</p>
`;
          };
        this.indent = function (O) {
          let T = "";
          for (let L = 0; L < O; L += 1) T += ".";
          return T;
        };
        let eO = function (O, T) {
            let L = "";
            if (T.type === W.TRG) {
              if (O === X || O === er) {
                let J = T.min.toString(16).toUpperCase();
                J.length % 2 != 0 && (J = `0${J}`),
                  (L += (O === X ? "%x" : "U+") + J),
                  (J = T.max.toString(16).toUpperCase()).length % 2 != 0 &&
                    (J = `0${J}`),
                  (L += `&ndash;${J}`);
              } else L = `%d${T.min.toString(10)}&ndash;${T.max.toString(10)}`;
            }
            return L;
          },
          eT = function (O, T) {
            let L = "";
            if (T.type === W.REP) {
              if (O === X) {
                let O = T.min.toString(16).toUpperCase();
                O.length % 2 != 0 && (O = `0${O}`),
                  (L = `x${O}`),
                  T.max < 1 / 0
                    ? (O = T.max.toString(16).toUpperCase()).length % 2 != 0 &&
                      (O = `0${O}`)
                    : (O = "inf"),
                  (L += `&ndash;${O}`);
              } else
                L =
                  T.max < 1 / 0
                    ? `${T.min.toString(10)}&ndash;${T.max.toString(10)}`
                    : `${T.min.toString(10)}&ndash;inf`;
            }
            return L;
          },
          eN = function (O, T) {
            let L = "";
            if (T.type === W.TBS) {
              let J = Math.min(T.string.length, 2 * es);
              if (O === X || O === er) {
                L += O === X ? "%x" : "U+";
                for (let O = 0; O < J; O += 1) {
                  let J;
                  O > 0 && (L += "."),
                    (J = T.string[O].toString(16).toUpperCase()).length % 2 !=
                      0 && (J = `0${J}`),
                    (L += J);
                }
              } else {
                L = "%d";
                for (let O = 0; O < J; O += 1)
                  O > 0 && (L += "."), (L += T.string[O].toString(10));
              }
              J < T.string.length && (L += eA);
            }
            return L;
          },
          eR = function (T, L) {
            let J = "";
            if (L.type === W.TLS) {
              let W = Math.min(L.string.length, es);
              if (T === X || T === ee) {
                let O, Y, Z;
                T === X ? ((J = "%x"), (Z = 16)) : ((J = "%d"), (Z = 10));
                for (let T = 0; T < W; T += 1)
                  T > 0 && (J += "."),
                    (Y = L.string[T]) >= 97 && Y <= 122
                      ? ((O = Y - 32),
                        (J += `${O.toString(Z)}/${Y.toString(
                          Z
                        )}`.toUpperCase()))
                      : Y >= 65 && Y <= 90
                      ? ((O = Y),
                        (Y += 32),
                        (J += `${O.toString(Z)}/${Y.toString(
                          Z
                        )}`.toUpperCase()))
                      : (J += Y.toString(Z).toUpperCase());
                W < L.string.length && (J += eA);
              } else {
                J = '"';
                for (let T = 0; T < W; T += 1) J += O.asciiChars[L.string[T]];
                W < L.string.length && (J += eA), (J += '"');
              }
            }
            return J;
          },
          eI = function (T, L, J, W, Y) {
            if (0 === W) return "";
            let Z = "",
              et = Y ? "," : "";
            switch (T) {
              case X:
                Z = et + O.charsToHex(L, J, W);
                break;
              case ee:
                if (Y) return `,${O.charsToDec(L, J, W)}`;
                Z = et + O.charsToDec(L, J, W);
                break;
              case er:
                Z = O.charsToUnicode(L, J, W);
                break;
              default:
                Z = O.charsToAsciiHtml(L, J, W);
            }
            return Z;
          },
          eM = function (O, L, J, Y, Z, X) {
            let ee,
              et,
              er,
              es,
              ei = "",
              ea = eb,
              eo = `<span class="${T.CLASS_LOOKBEHIND}">`,
              ec = `<span class="${T.CLASS_REMAINDER}">`,
              eu = "</span>",
              eh = !1;
            switch (J) {
              case W.EMPTY:
                ei += ew;
              case W.NOMATCH:
              case W.MATCH:
              case W.ACTIVE:
                (et = X - (ee = Y - Z)), (er = X), (es = L.length - er);
                break;
              default:
                throw Error("unrecognized state");
            }
            return (
              (ea = eb),
              et > en
                ? ((et = en), (ea = eA), (es = 0))
                : et + es > en && ((ea = eA), (es = en - et)),
              et > 0 && ((ei += eo + eI(O, L, ee, et, eh) + eu), (eh = !0)),
              es > 0 && (ei += ec + eI(O, L, er, es, eh) + eu),
              ei + ea
            );
          },
          eU = function (O, L, J, Y, Z, X) {
            let ee,
              et,
              er,
              es,
              ei = "",
              ea = eb,
              eo = `<span class="${T.CLASS_REMAINDER}">`,
              ec = "</span>",
              eu = !1;
            switch (J) {
              case W.EMPTY:
                ei += ew;
              case W.NOMATCH:
              case W.ACTIVE:
                (ee = Y), (et = 0), (er = Y), (es = L.length - er);
                break;
              case W.MATCH:
                (ee = Y), (er = Y + (et = Z)), (es = L.length - er);
                break;
              default:
                throw Error("unrecognized state");
            }
            return (
              (ea = eb),
              et > en
                ? ((et = en), (ea = eA), (es = 0))
                : et + es > en && ((ea = eA), (es = en - et)),
              et > 0 && ((ei += X + eI(O, L, ee, et, eu) + ec), (eu = !0)),
              es > 0 && (ei += eo + eI(O, L, er, es, eu) + ec),
              ei + ea
            );
          },
          eL = function (O, L, J, W, Y) {
            return eU(O, L, J, W, Y, `<span class="${T.CLASS_LOOKAHEAD}">`);
          },
          eD = function (O, L, J, W, Y) {
            return eU(O, L, J, W, Y, `<span class="${T.CLASS_MATCH}">`);
          },
          e_ = function (L) {
            let Y, X, ee, et, er, en;
            if (null === ep) return "";
            let es = "";
            return (
              (es +=
                "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th><th>operator</th><th>phrase</th></tr>\n"),
              J.forEach((J) => {
                let ea = ei[J];
                switch (
                  ((Y = ea.thisLine),
                  (X = void 0 !== ea.thatLine ? ea.thatLine : "--"),
                  (ee = !1),
                  (et = !1),
                  (er = !1),
                  ea.lookAround === W.LOOKAROUND_AHEAD &&
                    ((ee = !0), (er = !0), (en = ea.lookAnchor)),
                  (ea.opcode.type === W.AND || ea.opcode.type === W.NOT) &&
                    ((ee = !0), (er = !0), (en = ea.phraseIndex)),
                  ea.lookAround === W.LOOKAROUND_BEHIND &&
                    ((et = !0), (er = !0), (en = ea.lookAnchor)),
                  (ea.opcode.type === W.BKA || ea.opcode.type === W.BKN) &&
                    ((et = !0), (er = !0), (en = ea.phraseIndex)),
                  (es += `<tr><td>${Y}</td><td>${X}</td><td>${ea.phraseIndex}</td><td>${ea.phraseLength}</td><td>${ea.depth}</td><td>`),
                  ea.state)
                ) {
                  case W.ACTIVE:
                    es += `<span class="${T.CLASS_ACTIVE}">&darr;&nbsp;</span>`;
                    break;
                  case W.MATCH:
                    es += `<span class="${T.CLASS_MATCH}">&uarr;M</span>`;
                    break;
                  case W.NOMATCH:
                    es += `<span class="${T.CLASS_NOMATCH}">&uarr;N</span>`;
                    break;
                  case W.EMPTY:
                    es += `<span class="${T.CLASS_EMPTY}">&uarr;E</span>`;
                    break;
                  default:
                    es += `<span class="${T.CLASS_ACTIVE}">--</span>`;
                }
                if (
                  ((es += "</td><td>" + Z.indent(ea.depth)),
                  ee
                    ? (es += `<span class="${T.CLASS_LOOKAHEAD}">`)
                    : et && (es += `<span class="${T.CLASS_LOOKBEHIND}">`),
                  (es += O.opcodeToString(ea.opcode.type)),
                  ea.opcode.type === W.RNM &&
                    (es += `(${ep[ea.opcode.index].name}) `),
                  ea.opcode.type === W.BKR)
                ) {
                  let O = ea.opcode.bkrCase === W.BKR_MODE_CI ? "%i" : "%s",
                    T = ea.opcode.bkrMode === W.BKR_MODE_UM ? "%u" : "%p";
                  es += `(\\${O}${T}${ep[ea.opcode.index].name}) `;
                }
                ea.opcode.type === W.UDT &&
                  (es += `(${eg[ea.opcode.index].name}) `),
                  ea.opcode.type === W.TRG && (es += `(${eO(L, ea.opcode)}) `),
                  ea.opcode.type === W.TBS && (es += `(${eN(L, ea.opcode)}) `),
                  ea.opcode.type === W.TLS && (es += `(${eR(L, ea.opcode)}) `),
                  ea.opcode.type === W.REP && (es += `(${eT(L, ea.opcode)}) `),
                  er && (es += "</span>"),
                  (es += "</td><td>"),
                  et
                    ? (es += eM(
                        L,
                        ed,
                        ea.state,
                        ea.phraseIndex,
                        ea.phraseLength,
                        en
                      ))
                    : ee
                    ? (es += eL(
                        L,
                        ed,
                        ea.state,
                        ea.phraseIndex,
                        ea.phraseLength
                      ))
                    : (es += eD(
                        L,
                        ed,
                        ea.state,
                        ea.phraseIndex,
                        ea.phraseLength
                      )),
                  (es += "</td></tr>\n");
              }),
              (es +=
                "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th><th>operator</th><th>phrase</th></tr>\n</table>\n")
            );
          };
        this.toHtml = function (O, T) {
          let L = et;
          if ("string" == typeof O && O.length >= 3) {
            let T = O.toLowerCase().slice(0, 3);
            "hex" === T
              ? (L = X)
              : "dec" === T
              ? (L = ee)
              : "uni" === T && (L = er);
          }
          return "" + (eC(L, T) + e_(L) + eB());
        };
      };
    },
    51708: function (O, T, L) {
      let J = L(24568),
        W = L(80407),
        Y = L(41451),
        Z = L(47351),
        X = "utilities.js: ",
        ee = function (O, T, L) {
          let J;
          let W = T,
            Y = !0;
          for (; Y; ) {
            if (O <= 0) {
              (W = 0), (J = 0);
              break;
            }
            if ("number" != typeof W) {
              (W = 0), (J = O);
              break;
            }
            if (W >= O) {
              (W = O), (J = O);
              break;
            }
            if ("number" != typeof L) {
              J = O;
              break;
            }
            (J = W + L) > O && (J = O);
            break;
          }
          return { beg: W, end: J };
        };
      function et(O) {
        return (!(O >= 55296) || !(O <= 57343)) && !(O > 1114111);
      }
      (T.htmlToPage = function (O, T) {
        let L;
        if ("string" != typeof O)
          throw Error(`${X}htmlToPage: input HTML is not a string`);
        return (
          (L = "string" != typeof T ? "htmlToPage" : T),
          `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>${L}</title>
<style>
` +
            Y() +
            "</style>\n</head>\n<body>\n" +
            `<p>${new Date()}</p>
` +
            O +
            "</body>\n</html>\n"
        );
      }),
        (T.parserResultToHtml = function (O, T) {
          let L,
            W,
            Y = null;
          "string" == typeof T && "" !== T && (Y = T),
            (L =
              !0 === O.success
                ? `<span class="${J.CLASS_MATCH}">true</span>`
                : `<span class="${J.CLASS_NOMATCH}">false</span>`),
            (W =
              O.state === Z.EMPTY
                ? `<span class="${J.CLASS_EMPTY}">EMPTY</span>`
                : O.state === Z.MATCH
                ? `<span class="${J.CLASS_MATCH}">MATCH</span>`
                : O.state === Z.NOMATCH
                ? `<span class="${J.CLASS_NOMATCH}">NOMATCH</span>`
                : `<span class="${J.CLASS_NOMATCH}">unrecognized</span>`);
          let X = "";
          return (
            (X += `<table class="${J.CLASS_STATE}">
`),
            Y &&
              (X += `<caption>${Y}</caption>
`),
            (X += `<tr><th>state item</th><th>value</th><th>description</th></tr>
<tr><td>parser success</td><td>${L}</td>
<td><span class="${J.CLASS_MATCH}">true</span> if the parse succeeded,
 <span class="${J.CLASS_NOMATCH}">false</span> otherwise<br><i>NOTE: for success, entire string must be matched</i></td></tr>
<tr><td>parser state</td><td>${W}</td>
<td><span class="${J.CLASS_EMPTY}">EMPTY</span>, <span class="${J.CLASS_MATCH}">MATCH</span> or 
<span class="${J.CLASS_NOMATCH}">NOMATCH</span></td></tr>
<tr><td>string length</td><td>${O.length}</td><td>length of the input (sub)string</td></tr>
<tr><td>matched length</td><td>${O.matched}</td><td>number of input string characters matched</td></tr>
<tr><td>max matched</td><td>${O.maxMatched}</td><td>maximum number of input string characters matched</td></tr>
<tr><td>max tree depth</td><td>${O.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>
<tr><td>node hits</td><td>${O.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>
<tr><td>input length</td><td>${O.inputLength}</td><td>length of full input string</td></tr>
<tr><td>sub-string begin</td><td>${O.subBegin}</td><td>sub-string first character index</td></tr>
<tr><td>sub-string end</td><td>${O.subEnd}</td><td>sub-string end-of-string index</td></tr>
<tr><td>sub-string length</td><td>${O.subLength}</td><td>sub-string length</td></tr>
</table>
`)
          );
        }),
        (T.charsToString = function (O, T, L) {
          let J, Y;
          if ("number" == typeof T) {
            if (T >= O.length) return "";
            J = T < 0 ? 0 : T;
          } else J = 0;
          if ("number" == typeof L) {
            if (L <= 0) return "";
            Y = L > O.length - J ? O.length : J + L;
          } else Y = O.length;
          return J < Y
            ? W.encode("UTF16LE", O.slice(J, Y)).toString("utf16le")
            : "";
        }),
        (T.stringToChars = function (O) {
          return W.decode("STRING", O);
        }),
        (T.opcodeToString = function (O) {
          let T = "unknown";
          switch (O) {
            case Z.ALT:
              T = "ALT";
              break;
            case Z.CAT:
              T = "CAT";
              break;
            case Z.RNM:
              T = "RNM";
              break;
            case Z.UDT:
              T = "UDT";
              break;
            case Z.AND:
              T = "AND";
              break;
            case Z.NOT:
              T = "NOT";
              break;
            case Z.REP:
              T = "REP";
              break;
            case Z.TRG:
              T = "TRG";
              break;
            case Z.TBS:
              T = "TBS";
              break;
            case Z.TLS:
              T = "TLS";
              break;
            case Z.BKR:
              T = "BKR";
              break;
            case Z.BKA:
              T = "BKA";
              break;
            case Z.BKN:
              T = "BKN";
              break;
            case Z.ABG:
              T = "ABG";
              break;
            case Z.AEN:
              T = "AEN";
              break;
            default:
              throw Error("unrecognized opcode");
          }
          return T;
        }),
        (T.stateToString = function (O) {
          let T = "unknown";
          switch (O) {
            case Z.ACTIVE:
              T = "ACTIVE";
              break;
            case Z.MATCH:
              T = "MATCH";
              break;
            case Z.EMPTY:
              T = "EMPTY";
              break;
            case Z.NOMATCH:
              T = "NOMATCH";
              break;
            default:
              throw Error("unrecognized state");
          }
          return T;
        }),
        (T.asciiChars = [
          "NUL",
          "SOH",
          "STX",
          "ETX",
          "EOT",
          "ENQ",
          "ACK",
          "BEL",
          "BS",
          "TAB",
          "LF",
          "VT",
          "FF",
          "CR",
          "SO",
          "SI",
          "DLE",
          "DC1",
          "DC2",
          "DC3",
          "DC4",
          "NAK",
          "SYN",
          "ETB",
          "CAN",
          "EM",
          "SUB",
          "ESC",
          "FS",
          "GS",
          "RS",
          "US",
          "&nbsp;",
          "!",
          "&#34;",
          "#",
          "$",
          "%",
          "&#38;",
          "&#39;",
          "(",
          ")",
          "*",
          "+",
          ",",
          "-",
          ".",
          "/",
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          ":",
          ";",
          "&#60;",
          "=",
          "&#62;",
          "?",
          "@",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          "[",
          "&#92;",
          "]",
          "^",
          "_",
          "`",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g",
          "h",
          "i",
          "j",
          "k",
          "l",
          "m",
          "n",
          "o",
          "p",
          "q",
          "r",
          "s",
          "t",
          "u",
          "v",
          "w",
          "x",
          "y",
          "z",
          "{",
          "|",
          "}",
          "~",
          "DEL",
        ]),
        (T.charToHex = function (O) {
          let T = O.toString(16).toUpperCase();
          switch (T.length) {
            case 1:
            case 3:
            case 7:
              T = `0${T}`;
              break;
            case 2:
            case 6:
              T = `00${T}`;
              break;
            case 4:
              break;
            case 5:
              T = `000${T}`;
              break;
            default:
              throw Error("unrecognized option");
          }
          return T;
        }),
        (T.charsToDec = function (O, T, L) {
          let J = "";
          if (!Array.isArray(O))
            throw Error(`${X}charsToDec: input must be an array of integers`);
          let W = ee(O.length, T, L);
          if (W.end > W.beg) {
            J += O[W.beg];
            for (let T = W.beg + 1; T < W.end; T += 1) J += `,${O[T]}`;
          }
          return J;
        }),
        (T.charsToHex = function (O, L, J) {
          let W = "";
          if (!Array.isArray(O))
            throw Error(`${X}charsToHex: input must be an array of integers`);
          let Y = ee(O.length, L, J);
          if (Y.end > Y.beg) {
            W += `\\x${T.charToHex(O[Y.beg])}`;
            for (let L = Y.beg + 1; L < Y.end; L += 1)
              W += `,\\x${T.charToHex(O[L])}`;
          }
          return W;
        }),
        (T.charsToHtmlEntities = function (O, T, L) {
          let J = "";
          if (!Array.isArray(O))
            throw Error(`${X}charsToHex: input must be an array of integers`);
          let W = ee(O.length, T, L);
          if (W.end > W.beg)
            for (let T = W.beg; T < W.end; T += 1)
              J += `&x__0${O[T].toString(16)};`;
          return J;
        }),
        (T.charsToUnicode = function (O, L, J) {
          let W = "";
          if (!Array.isArray(O))
            throw Error(
              `${X}charsToUnicode: input must be an array of integers`
            );
          let Y = ee(O.length, L, J);
          if (Y.end > Y.beg)
            for (let L = Y.beg; L < Y.end; L += 1)
              et(O[L]) ? (W += `&#${O[L]};`) : (W += ` U+${T.charToHex(O[L])}`);
          return W;
        }),
        (T.charsToJsUnicode = function (O, L, J) {
          let W = "";
          if (!Array.isArray(O))
            throw Error(
              `${X}charsToJsUnicode: input must be an array of integers`
            );
          let Y = ee(O.length, L, J);
          if (Y.end > Y.beg) {
            W += `\\u${T.charToHex(O[Y.beg])}`;
            for (let L = Y.beg + 1; L < Y.end; L += 1)
              W += `,\\u${T.charToHex(O[L])}`;
          }
          return W;
        }),
        (T.charsToAscii = function (O, L, J) {
          let W = "";
          if (!Array.isArray(O))
            throw Error(`${X}charsToAscii: input must be an array of integers`);
          let Y = ee(O.length, L, J);
          for (let L = Y.beg; L < Y.end; L += 1) {
            let J = O[L];
            J >= 32 && J <= 126
              ? (W += String.fromCharCode(J))
              : (W += `\\x${T.charToHex(J)}`);
          }
          return W;
        }),
        (T.charsToAsciiHtml = function (O, L, W) {
          let Y;
          if (!Array.isArray(O))
            throw Error(
              `${X}charsToAsciiHtml: input must be an array of integers`
            );
          let Z = "",
            et = ee(O.length, L, W);
          for (let L = et.beg; L < et.end; L += 1)
            (Y = O[L]) < 32 || 127 === Y
              ? (Z += `<span class="${J.CLASS_CTRLCHAR}">${T.asciiChars[Y]}</span>`)
              : Y > 127
              ? (Z += `<span class="${J.CLASS_CTRLCHAR}">U+${T.charToHex(
                  Y
                )}</span>`)
              : (Z += T.asciiChars[Y]);
          return Z;
        }),
        (T.stringToAsciiHtml = function (O) {
          let T = W.decode("STRING", O);
          return this.charsToAsciiHtml(T);
        });
    },
    78305: function (O, T) {
      // "use strict";
      /*!
       * cookie
       * Copyright(c) 2012-2014 Roman Shtylman
       * Copyright(c) 2015 Douglas Christopher Wilson
       * MIT Licensed
       */ (T.parse = W), (T.serialize = Y);
      var L = Object.prototype.toString,
        J = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
      function W(O, T) {
        if ("string" != typeof O)
          throw TypeError("argument str must be a string");
        for (var L = {}, J = (T || {}).decode || Z, W = 0; W < O.length; ) {
          var Y = O.indexOf("=", W);
          if (-1 === Y) break;
          var X = O.indexOf(";", W);
          if (-1 === X) X = O.length;
          else if (X < Y) {
            W = O.lastIndexOf(";", Y - 1) + 1;
            continue;
          }
          var ee = O.slice(W, Y).trim();
          if (void 0 === L[ee]) {
            var er = O.slice(Y + 1, X).trim();
            34 === er.charCodeAt(0) && (er = er.slice(1, -1)),
              (L[ee] = et(er, J));
          }
          W = X + 1;
        }
        return L;
      }
      function Y(O, T, L) {
        var W = L || {},
          Y = W.encode || X;
        if ("function" != typeof Y) throw TypeError("option encode is invalid");
        if (!J.test(O)) throw TypeError("argument name is invalid");
        var Z = Y(T);
        if (Z && !J.test(Z)) throw TypeError("argument val is invalid");
        var et = O + "=" + Z;
        if (null != W.maxAge) {
          var er = W.maxAge - 0;
          if (isNaN(er) || !isFinite(er))
            throw TypeError("option maxAge is invalid");
          et += "; Max-Age=" + Math.floor(er);
        }
        if (W.domain) {
          if (!J.test(W.domain)) throw TypeError("option domain is invalid");
          et += "; Domain=" + W.domain;
        }
        if (W.path) {
          if (!J.test(W.path)) throw TypeError("option path is invalid");
          et += "; Path=" + W.path;
        }
        if (W.expires) {
          var en = W.expires;
          if (!ee(en) || isNaN(en.valueOf()))
            throw TypeError("option expires is invalid");
          et += "; Expires=" + en.toUTCString();
        }
        if (
          (W.httpOnly && (et += "; HttpOnly"),
          W.secure && (et += "; Secure"),
          W.priority)
        )
          switch (
            "string" == typeof W.priority
              ? W.priority.toLowerCase()
              : W.priority
          ) {
            case "low":
              et += "; Priority=Low";
              break;
            case "medium":
              et += "; Priority=Medium";
              break;
            case "high":
              et += "; Priority=High";
              break;
            default:
              throw TypeError("option priority is invalid");
          }
        if (W.sameSite)
          switch (
            "string" == typeof W.sameSite
              ? W.sameSite.toLowerCase()
              : W.sameSite
          ) {
            case !0:
            case "strict":
              et += "; SameSite=Strict";
              break;
            case "lax":
              et += "; SameSite=Lax";
              break;
            case "none":
              et += "; SameSite=None";
              break;
            default:
              throw TypeError("option sameSite is invalid");
          }
        return et;
      }
      function Z(O) {
        return -1 !== O.indexOf("%") ? decodeURIComponent(O) : O;
      }
      function X(O) {
        return encodeURIComponent(O);
      }
      function ee(O) {
        return "[object Date]" === L.call(O) || O instanceof Date;
      }
      function et(O, T) {
        try {
          return T(O);
        } catch (T) {
          return O;
        }
      }
    },
    51562: function (module) {
      var __dirname = "/";
      !(function () {
        var __webpack_modules__ = {
          950: function (__unused_webpack_module, exports) {
            var indexOf = function (O, T) {
                if (O.indexOf) return O.indexOf(T);
                for (var L = 0; L < O.length; L++) if (O[L] === T) return L;
                return -1;
              },
              Object_keys = function (O) {
                if (Object.keys) return Object.keys(O);
                var T = [];
                for (var L in O) T.push(L);
                return T;
              },
              forEach = function (O, T) {
                if (O.forEach) return O.forEach(T);
                for (var L = 0; L < O.length; L++) T(O[L], L, O);
              },
              defineProp = (function () {
                try {
                  return (
                    Object.defineProperty({}, "_", {}),
                    function (O, T, L) {
                      Object.defineProperty(O, T, {
                        writable: !0,
                        enumerable: !1,
                        configurable: !0,
                        value: L,
                      });
                    }
                  );
                } catch (O) {
                  return function (O, T, L) {
                    O[T] = L;
                  };
                }
              })(),
              globals = [
                "Array",
                "Boolean",
                "Date",
                "Error",
                "EvalError",
                "Function",
                "Infinity",
                "JSON",
                "Math",
                "NaN",
                "Number",
                "Object",
                "RangeError",
                "ReferenceError",
                "RegExp",
                "String",
                "SyntaxError",
                "TypeError",
                "URIError",
                "decodeURI",
                "decodeURIComponent",
                "encodeURI",
                "encodeURIComponent",
                "escape",
                "eval",
                "isFinite",
                "isNaN",
                "parseFloat",
                "parseInt",
                "undefined",
                "unescape",
              ];
            function Context() {}
            Context.prototype = {};
            var Script = (exports.Script = function (O) {
              if (!(this instanceof Script)) return new Script(O);
              this.code = O;
            });
            (Script.prototype.runInContext = function (O) {
              if (!(O instanceof Context))
                throw TypeError("needs a 'context' argument.");
              var T = document.createElement("iframe");
              T.style || (T.style = {}),
                (T.style.display = "none"),
                document.body.appendChild(T);
              var L = T.contentWindow,
                J = L.eval,
                W = L.execScript;
              !J && W && (W.call(L, "null"), (J = L.eval)),
                forEach(Object_keys(O), function (T) {
                  L[T] = O[T];
                }),
                forEach(globals, function (T) {
                  O[T] && (L[T] = O[T]);
                });
              var Y = Object_keys(L),
                Z = J.call(L, this.code);
              return (
                forEach(Object_keys(L), function (T) {
                  (T in O || -1 === indexOf(Y, T)) && (O[T] = L[T]);
                }),
                forEach(globals, function (T) {
                  T in O || defineProp(O, T, L[T]);
                }),
                document.body.removeChild(T),
                Z
              );
            }),
              (Script.prototype.runInThisContext = function () {
                return eval(this.code);
              }),
              (Script.prototype.runInNewContext = function (O) {
                var T = Script.createContext(O),
                  L = this.runInContext(T);
                return (
                  O &&
                    forEach(Object_keys(T), function (L) {
                      O[L] = T[L];
                    }),
                  L
                );
              }),
              forEach(Object_keys(Script.prototype), function (O) {
                exports[O] = Script[O] = function (T) {
                  var L = Script(T);
                  return L[O].apply(L, [].slice.call(arguments, 1));
                };
              }),
              (exports.isContext = function (O) {
                return O instanceof Context;
              }),
              (exports.createScript = function (O) {
                return exports.Script(O);
              }),
              (exports.createContext = Script.createContext =
                function (O) {
                  var T = new Context();
                  return (
                    "object" == typeof O &&
                      forEach(Object_keys(O), function (L) {
                        T[L] = O[L];
                      }),
                    T
                  );
                });
          },
        };
        "undefined" != typeof __nccwpck_require__ &&
          (__nccwpck_require__.ab = __dirname + "/");
        var __nested_webpack_exports__ = {};
        __webpack_modules__[950](0, __nested_webpack_exports__),
          (module.exports = __nested_webpack_exports__);
      })();
    },
    87710: function (O) {
      !(function (T, L) {
        O.exports = L();
      })(0, function () {
        var O = [],
          T = [],
          L = {},
          J = {},
          W = {};
        function Y(O) {
          return "string" == typeof O ? RegExp("^" + O + "$", "i") : O;
        }
        function Z(O, T) {
          return O === T
            ? T
            : O === O.toLowerCase()
            ? T.toLowerCase()
            : O === O.toUpperCase()
            ? T.toUpperCase()
            : O[0] === O[0].toUpperCase()
            ? T.charAt(0).toUpperCase() + T.substr(1).toLowerCase()
            : T.toLowerCase();
        }
        function X(O, T) {
          return O.replace(/\$(\d{1,2})/g, function (O, L) {
            return T[L] || "";
          });
        }
        function ee(O, T) {
          return O.replace(T[0], function (L, J) {
            var W = X(T[1], arguments);
            return "" === L ? Z(O[J - 1], W) : Z(L, W);
          });
        }
        function et(O, T, J) {
          if (!O.length || L.hasOwnProperty(O)) return T;
          for (var W = J.length; W--; ) {
            var Y = J[W];
            if (Y[0].test(T)) return ee(T, Y);
          }
          return T;
        }
        function er(O, T, L) {
          return function (J) {
            var W = J.toLowerCase();
            return T.hasOwnProperty(W)
              ? Z(J, W)
              : O.hasOwnProperty(W)
              ? Z(J, O[W])
              : et(W, J, L);
          };
        }
        function en(O, T, L, J) {
          return function (J) {
            var W = J.toLowerCase();
            return (
              !!T.hasOwnProperty(W) ||
              (!O.hasOwnProperty(W) && et(W, W, L) === W)
            );
          };
        }
        function es(O, T, L) {
          var J = 1 === T ? es.singular(O) : es.plural(O);
          return (L ? T + " " : "") + J;
        }
        return (
          (es.plural = er(W, J, O)),
          (es.isPlural = en(W, J, O)),
          (es.singular = er(J, W, T)),
          (es.isSingular = en(J, W, T)),
          (es.addPluralRule = function (T, L) {
            O.push([Y(T), L]);
          }),
          (es.addSingularRule = function (O, L) {
            T.push([Y(O), L]);
          }),
          (es.addUncountableRule = function (O) {
            if ("string" == typeof O) {
              L[O.toLowerCase()] = !0;
              return;
            }
            es.addPluralRule(O, "$0"), es.addSingularRule(O, "$0");
          }),
          (es.addIrregularRule = function (O, T) {
            (T = T.toLowerCase()), (W[(O = O.toLowerCase())] = T), (J[T] = O);
          }),
          [
            ["I", "we"],
            ["me", "us"],
            ["he", "they"],
            ["she", "they"],
            ["them", "them"],
            ["myself", "ourselves"],
            ["yourself", "yourselves"],
            ["itself", "themselves"],
            ["herself", "themselves"],
            ["himself", "themselves"],
            ["themself", "themselves"],
            ["is", "are"],
            ["was", "were"],
            ["has", "have"],
            ["this", "these"],
            ["that", "those"],
            ["echo", "echoes"],
            ["dingo", "dingoes"],
            ["volcano", "volcanoes"],
            ["tornado", "tornadoes"],
            ["torpedo", "torpedoes"],
            ["genus", "genera"],
            ["viscus", "viscera"],
            ["stigma", "stigmata"],
            ["stoma", "stomata"],
            ["dogma", "dogmata"],
            ["lemma", "lemmata"],
            ["schema", "schemata"],
            ["anathema", "anathemata"],
            ["ox", "oxen"],
            ["axe", "axes"],
            ["die", "dice"],
            ["yes", "yeses"],
            ["foot", "feet"],
            ["eave", "eaves"],
            ["goose", "geese"],
            ["tooth", "teeth"],
            ["quiz", "quizzes"],
            ["human", "humans"],
            ["proof", "proofs"],
            ["carve", "carves"],
            ["valve", "valves"],
            ["looey", "looies"],
            ["thief", "thieves"],
            ["groove", "grooves"],
            ["pickaxe", "pickaxes"],
            ["passerby", "passersby"],
          ].forEach(function (O) {
            return es.addIrregularRule(O[0], O[1]);
          }),
          [
            [/s?$/i, "s"],
            [/[^\u0000-\u007F]$/i, "$0"],
            [/([^aeiou]ese)$/i, "$1"],
            [/(ax|test)is$/i, "$1es"],
            [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
            [/(e[mn]u)s?$/i, "$1s"],
            [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
            [
              /(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i,
              "$1i",
            ],
            [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
            [/(seraph|cherub)(?:im)?$/i, "$1im"],
            [/(her|at|gr)o$/i, "$1oes"],
            [
              /(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i,
              "$1a",
            ],
            [
              /(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i,
              "$1a",
            ],
            [/sis$/i, "ses"],
            [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
            [/([^aeiouy]|qu)y$/i, "$1ies"],
            [/([^ch][ieo][ln])ey$/i, "$1ies"],
            [/(x|ch|ss|sh|zz)$/i, "$1es"],
            [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
            [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
            [/(pe)(?:rson|ople)$/i, "$1ople"],
            [/(child)(?:ren)?$/i, "$1ren"],
            [/eaux$/i, "$0"],
            [/m[ae]n$/i, "men"],
            ["thou", "you"],
          ].forEach(function (O) {
            return es.addPluralRule(O[0], O[1]);
          }),
          [
            [/s$/i, ""],
            [/(ss)$/i, "$1"],
            [
              /(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i,
              "$1fe",
            ],
            [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
            [/ies$/i, "y"],
            [
              /\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i,
              "$1ie",
            ],
            [/\b(mon|smil)ies$/i, "$1ey"],
            [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
            [/(seraph|cherub)im$/i, "$1"],
            [
              /(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i,
              "$1",
            ],
            [
              /(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i,
              "$1sis",
            ],
            [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
            [/(test)(?:is|es)$/i, "$1is"],
            [
              /(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i,
              "$1us",
            ],
            [
              /(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i,
              "$1um",
            ],
            [
              /(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i,
              "$1on",
            ],
            [/(alumn|alg|vertebr)ae$/i, "$1a"],
            [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
            [/(matr|append)ices$/i, "$1ix"],
            [/(pe)(rson|ople)$/i, "$1rson"],
            [/(child)ren$/i, "$1"],
            [/(eau)x?$/i, "$1"],
            [/men$/i, "man"],
          ].forEach(function (O) {
            return es.addSingularRule(O[0], O[1]);
          }),
          [
            "adulthood",
            "advice",
            "agenda",
            "aid",
            "aircraft",
            "alcohol",
            "ammo",
            "analytics",
            "anime",
            "athletics",
            "audio",
            "bison",
            "blood",
            "bream",
            "buffalo",
            "butter",
            "carp",
            "cash",
            "chassis",
            "chess",
            "clothing",
            "cod",
            "commerce",
            "cooperation",
            "corps",
            "debris",
            "diabetes",
            "digestion",
            "elk",
            "energy",
            "equipment",
            "excretion",
            "expertise",
            "firmware",
            "flounder",
            "fun",
            "gallows",
            "garbage",
            "graffiti",
            "hardware",
            "headquarters",
            "health",
            "herpes",
            "highjinks",
            "homework",
            "housework",
            "information",
            "jeans",
            "justice",
            "kudos",
            "labour",
            "literature",
            "machinery",
            "mackerel",
            "mail",
            "media",
            "mews",
            "moose",
            "music",
            "mud",
            "manga",
            "news",
            "only",
            "personnel",
            "pike",
            "plankton",
            "pliers",
            "police",
            "pollution",
            "premises",
            "rain",
            "research",
            "rice",
            "salmon",
            "scissors",
            "series",
            "sewage",
            "shambles",
            "shrimp",
            "software",
            "species",
            "staff",
            "swine",
            "tennis",
            "traffic",
            "transportation",
            "trout",
            "tuna",
            "wealth",
            "welfare",
            "whiting",
            "wildebeest",
            "wildlife",
            "you",
            /pok[e]mon$/i,
            /[^aeiou]ese$/i,
            /deer$/i,
            /fish$/i,
            /measles$/i,
            /o[iu]s$/i,
            /pox$/i,
            /sheep$/i,
          ].forEach(es.addUncountableRule),
          es
        );
      });
    },
    89594: function (O, T, L) {
      // "use strict";
      var J,
        W = L(30410).Buffer;
      /*!
       * MIT License
       *
       * Copyright (c) 2017-2022 Peculiar Ventures, LLC
       *
       * Permission is hereby granted, free of charge, to any person obtaining a copy
       * of this software and associated documentation files (the "Software"), to deal
       * in the Software without restriction, including without limitation the rights
       * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       * copies of the Software, and to permit persons to whom the Software is
       * furnished to do so, subject to the following conditions:
       *
       * The above copyright notice and this permission notice shall be included in all
       * copies or substantial portions of the Software.
       *
       * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       * SOFTWARE.
       *
       */ let Y = "[object ArrayBuffer]";
      class Z {
        static isArrayBuffer(O) {
          return Object.prototype.toString.call(O) === Y;
        }
        static toArrayBuffer(O) {
          return this.isArrayBuffer(O)
            ? O
            : O.byteLength === O.buffer.byteLength ||
              (0 === O.byteOffset && O.byteLength === O.buffer.byteLength)
            ? O.buffer
            : this.toUint8Array(O.buffer).slice(
                O.byteOffset,
                O.byteOffset + O.byteLength
              ).buffer;
        }
        static toUint8Array(O) {
          return this.toView(O, Uint8Array);
        }
        static toView(O, T) {
          if (O.constructor === T) return O;
          if (this.isArrayBuffer(O)) return new T(O);
          if (this.isArrayBufferView(O))
            return new T(O.buffer, O.byteOffset, O.byteLength);
          throw TypeError(
            "The provided value is not of type '(ArrayBuffer or ArrayBufferView)'"
          );
        }
        static isBufferSource(O) {
          return this.isArrayBufferView(O) || this.isArrayBuffer(O);
        }
        static isArrayBufferView(O) {
          return ArrayBuffer.isView(O) || (O && this.isArrayBuffer(O.buffer));
        }
        static isEqual(O, T) {
          let L = Z.toUint8Array(O),
            J = Z.toUint8Array(T);
          if (L.length !== J.byteLength) return !1;
          for (let O = 0; O < L.length; O++) if (L[O] !== J[O]) return !1;
          return !0;
        }
        static concat(...O) {
          let T;
          T =
            !Array.isArray(O[0]) || O[1] instanceof Function
              ? Array.isArray(O[0]) && O[1] instanceof Function
                ? O[0]
                : O[O.length - 1] instanceof Function
                ? O.slice(0, O.length - 1)
                : O
              : O[0];
          let L = 0;
          for (let O of T) L += O.byteLength;
          let J = new Uint8Array(L),
            W = 0;
          for (let O of T) {
            let T = this.toUint8Array(O);
            J.set(T, W), (W += T.length);
          }
          return O[O.length - 1] instanceof Function
            ? this.toView(J, O[O.length - 1])
            : J.buffer;
        }
      }
      let X = "string",
        ee = /^[0-9a-f]+$/i,
        et = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,
        er = /^[a-zA-Z0-9-_]+$/;
      class en {
        static fromString(O) {
          let T = unescape(encodeURIComponent(O)),
            L = new Uint8Array(T.length);
          for (let O = 0; O < T.length; O++) L[O] = T.charCodeAt(O);
          return L.buffer;
        }
        static toString(O) {
          let T = Z.toUint8Array(O),
            L = "";
          for (let O = 0; O < T.length; O++) L += String.fromCharCode(T[O]);
          return decodeURIComponent(escape(L));
        }
      }
      class es {
        static toString(O, T = !1) {
          let L = Z.toArrayBuffer(O),
            J = new DataView(L),
            W = "";
          for (let O = 0; O < L.byteLength; O += 2)
            W += String.fromCharCode(J.getUint16(O, T));
          return W;
        }
        static fromString(O, T = !1) {
          let L = new ArrayBuffer(2 * O.length),
            J = new DataView(L);
          for (let L = 0; L < O.length; L++)
            J.setUint16(2 * L, O.charCodeAt(L), T);
          return L;
        }
      }
      class ei {
        static isHex(O) {
          return typeof O === X && ee.test(O);
        }
        static isBase64(O) {
          return typeof O === X && et.test(O);
        }
        static isBase64Url(O) {
          return typeof O === X && er.test(O);
        }
        static ToString(O, T = "utf8") {
          let L = Z.toUint8Array(O);
          switch (T.toLowerCase()) {
            case "utf8":
              return this.ToUtf8String(L);
            case "binary":
              return this.ToBinary(L);
            case "hex":
              return this.ToHex(L);
            case "base64":
              return this.ToBase64(L);
            case "base64url":
              return this.ToBase64Url(L);
            case "utf16le":
              return es.toString(L, !0);
            case "utf16":
            case "utf16be":
              return es.toString(L);
            default:
              throw Error(`Unknown type of encoding '${T}'`);
          }
        }
        static FromString(O, T = "utf8") {
          if (!O) return new ArrayBuffer(0);
          switch (T.toLowerCase()) {
            case "utf8":
              return this.FromUtf8String(O);
            case "binary":
              return this.FromBinary(O);
            case "hex":
              return this.FromHex(O);
            case "base64":
              return this.FromBase64(O);
            case "base64url":
              return this.FromBase64Url(O);
            case "utf16le":
              return es.fromString(O, !0);
            case "utf16":
            case "utf16be":
              return es.fromString(O);
            default:
              throw Error(`Unknown type of encoding '${T}'`);
          }
        }
        static ToBase64(O) {
          let T = Z.toUint8Array(O);
          return "undefined" != typeof btoa
            ? btoa(this.ToString(T, "binary"))
            : W.from(T).toString("base64");
        }
        static FromBase64(O) {
          let T = this.formatString(O);
          if (!T) return new ArrayBuffer(0);
          if (!ei.isBase64(T))
            throw TypeError("Argument 'base64Text' is not Base64 encoded");
          return "undefined" != typeof atob
            ? this.FromBinary(atob(T))
            : new Uint8Array(W.from(T, "base64")).buffer;
        }
        static FromBase64Url(O) {
          let T = this.formatString(O);
          if (!T) return new ArrayBuffer(0);
          if (!ei.isBase64Url(T))
            throw TypeError("Argument 'base64url' is not Base64Url encoded");
          return this.FromBase64(
            this.Base64Padding(T.replace(/\-/g, "+").replace(/\_/g, "/"))
          );
        }
        static ToBase64Url(O) {
          return this.ToBase64(O)
            .replace(/\+/g, "-")
            .replace(/\//g, "_")
            .replace(/\=/g, "");
        }
        static FromUtf8String(O, T = ei.DEFAULT_UTF8_ENCODING) {
          switch (T) {
            case "ascii":
              return this.FromBinary(O);
            case "utf8":
              return en.fromString(O);
            case "utf16":
            case "utf16be":
              return es.fromString(O);
            case "utf16le":
            case "usc2":
              return es.fromString(O, !0);
            default:
              throw Error(`Unknown type of encoding '${T}'`);
          }
        }
        static ToUtf8String(O, T = ei.DEFAULT_UTF8_ENCODING) {
          switch (T) {
            case "ascii":
              return this.ToBinary(O);
            case "utf8":
              return en.toString(O);
            case "utf16":
            case "utf16be":
              return es.toString(O);
            case "utf16le":
            case "usc2":
              return es.toString(O, !0);
            default:
              throw Error(`Unknown type of encoding '${T}'`);
          }
        }
        static FromBinary(O) {
          let T = O.length,
            L = new Uint8Array(T);
          for (let J = 0; J < T; J++) L[J] = O.charCodeAt(J);
          return L.buffer;
        }
        static ToBinary(O) {
          let T = Z.toUint8Array(O),
            L = "";
          for (let O = 0; O < T.length; O++) L += String.fromCharCode(T[O]);
          return L;
        }
        static ToHex(O) {
          let T = Z.toUint8Array(O),
            L = "",
            J = T.length;
          for (let O = 0; O < J; O++) {
            let J = T[O];
            J < 16 && (L += "0"), (L += J.toString(16));
          }
          return L;
        }
        static FromHex(O) {
          let T = this.formatString(O);
          if (!T) return new ArrayBuffer(0);
          if (!ei.isHex(T))
            throw TypeError("Argument 'hexString' is not HEX encoded");
          T.length % 2 && (T = `0${T}`);
          let L = new Uint8Array(T.length / 2);
          for (let O = 0; O < T.length; O += 2) {
            let J = T.slice(O, O + 2);
            L[O / 2] = parseInt(J, 16);
          }
          return L.buffer;
        }
        static ToUtf16String(O, T = !1) {
          return es.toString(O, T);
        }
        static FromUtf16String(O, T = !1) {
          return es.fromString(O, T);
        }
        static Base64Padding(O) {
          let T = 4 - (O.length % 4);
          if (T < 4) for (let L = 0; L < T; L++) O += "=";
          return O;
        }
        static formatString(O) {
          return (null == O ? void 0 : O.replace(/[\n\r\t ]/g, "")) || "";
        }
      }
      function ea(O, ...T) {
        let L = arguments[0];
        for (let O = 1; O < arguments.length; O++) {
          let T = arguments[O];
          for (let O in T) L[O] = T[O];
        }
        return L;
      }
      function eo(...O) {
        let T = O.map((O) => O.byteLength).reduce((O, T) => O + T),
          L = new Uint8Array(T),
          J = 0;
        return (
          O.map((O) => new Uint8Array(O)).forEach((O) => {
            for (let T of O) L[J++] = T;
          }),
          L.buffer
        );
      }
      (ei.DEFAULT_UTF8_ENCODING = "utf8"),
        (T.vJ = Z),
        (T.ep = ei),
        (J = ea),
        (T.$e = eo);
    },
    50250: function (O, T, L) {
      var J = L(30410),
        W = J.Buffer;
      function Y(O, T) {
        for (var L in O) T[L] = O[L];
      }
      function Z(O, T, L) {
        return W(O, T, L);
      }
      W.from && W.alloc && W.allocUnsafe && W.allocUnsafeSlow
        ? (O.exports = J)
        : (Y(J, T), (T.Buffer = Z)),
        Y(W, Z),
        (Z.from = function (O, T, L) {
          if ("number" == typeof O)
            throw TypeError("Argument must not be a number");
          return W(O, T, L);
        }),
        (Z.alloc = function (O, T, L) {
          if ("number" != typeof O)
            throw TypeError("Argument must be a number");
          var J = W(O);
          return (
            void 0 !== T
              ? "string" == typeof L
                ? J.fill(T, L)
                : J.fill(T)
              : J.fill(0),
            J
          );
        }),
        (Z.allocUnsafe = function (O) {
          if ("number" != typeof O)
            throw TypeError("Argument must be a number");
          return W(O);
        }),
        (Z.allocUnsafeSlow = function (O) {
          if ("number" != typeof O)
            throw TypeError("Argument must be a number");
          return J.SlowBuffer(O);
        });
    },
    88177: function (O, T, L) {
      // "use strict";
      var J =
          (this && this.__createBinding) ||
          (Object.create
            ? function (O, T, L, J) {
                void 0 === J && (J = L);
                var W = Object.getOwnPropertyDescriptor(T, L);
                (!W ||
                  ("get" in W
                    ? !T.__esModule
                    : W.writable || W.configurable)) &&
                  (W = {
                    enumerable: !0,
                    get: function () {
                      return T[L];
                    },
                  }),
                  Object.defineProperty(O, J, W);
              }
            : function (O, T, L, J) {
                void 0 === J && (J = L), (O[J] = T[L]);
              }),
        W =
          (this && this.__setModuleDefault) ||
          (Object.create
            ? function (O, T) {
                Object.defineProperty(O, "default", {
                  enumerable: !0,
                  value: T,
                });
              }
            : function (O, T) {
                O.default = T;
              }),
        Y =
          (this && this.__importStar) ||
          function (O) {
            if (O && O.__esModule) return O;
            var T = {};
            if (null != O)
              for (var L in O)
                "default" !== L &&
                  Object.prototype.hasOwnProperty.call(O, L) &&
                  J(T, O, L);
            return W(T, O), T;
          },
        Z =
          (this && this.__awaiter) ||
          function (O, T, L, J) {
            function W(O) {
              return O instanceof L
                ? O
                : new L(function (T) {
                    T(O);
                  });
            }
            return new (L || (L = Promise))(function (L, Y) {
              function Z(O) {
                try {
                  ee(J.next(O));
                } catch (O) {
                  Y(O);
                }
              }
              function X(O) {
                try {
                  ee(J.throw(O));
                } catch (O) {
                  Y(O);
                }
              }
              function ee(O) {
                O.done ? L(O.value) : W(O.value).then(Z, X);
              }
              ee((J = J.apply(O, T || [])).next());
            });
          };
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.SiweMessage = void 0);
      let X = L(88125),
        ee = Y(L(65365)),
        et = L(14909),
        er = L(86606),
        en = L(84176);
      class es {
        constructor(O) {
          if ("string" == typeof O) {
            let T = new X.ParsedMessage(O);
            (this.domain = T.domain),
              (this.address = T.address),
              (this.statement = T.statement),
              (this.uri = T.uri),
              (this.version = T.version),
              (this.nonce = T.nonce),
              (this.issuedAt = T.issuedAt),
              (this.expirationTime = T.expirationTime),
              (this.notBefore = T.notBefore),
              (this.requestId = T.requestId),
              (this.chainId = T.chainId),
              (this.resources = T.resources);
          } else
            Object.assign(this, O),
              "string" == typeof this.chainId &&
                (this.chainId = (0, X.parseIntegerNumber)(this.chainId));
          (this.nonce = this.nonce || (0, en.generateNonce)()),
            this.validateMessage();
        }
        toMessage() {
          this.validateMessage();
          let O = `${this.domain} wants you to sign in with your Ethereum account:`,
            T = `URI: ${this.uri}`,
            L = [O, this.address].join("\n"),
            J = `Version: ${this.version}`;
          this.nonce || (this.nonce = (0, en.generateNonce)());
          let W = [T, J, "Chain ID: " + this.chainId, `Nonce: ${this.nonce}`];
          if (
            ((this.issuedAt = this.issuedAt || new Date().toISOString()),
            W.push(`Issued At: ${this.issuedAt}`),
            this.expirationTime)
          ) {
            let O = `Expiration Time: ${this.expirationTime}`;
            W.push(O);
          }
          this.notBefore && W.push(`Not Before: ${this.notBefore}`),
            this.requestId && W.push(`Request ID: ${this.requestId}`),
            this.resources &&
              W.push(
                ["Resources:", ...this.resources.map((O) => `- ${O}`)].join(
                  "\n"
                )
              );
          let Y = W.join("\n");
          return (
            (L = [L, this.statement].join("\n\n")),
            this.statement && (L += "\n"),
            [L, Y].join("\n")
          );
        }
        prepareMessage() {
          let O;
          return this.version, (O = this.toMessage());
        }
        validate(O, T) {
          return Z(this, void 0, void 0, function* () {
            return (
              console.warn(
                "validate() has been deprecated, please update your code to use verify(). validate() may be removed in future versions."
              ),
              this.verify(
                { signature: O },
                { provider: T, suppressExceptions: !1 }
              )
                .then(({ data: O }) => O)
                .catch(({ error: O }) => {
                  throw O;
                })
            );
          });
        }
        verify(O, T = { suppressExceptions: !1 }) {
          return Z(this, void 0, void 0, function* () {
            return new Promise((L, J) => {
              var W, Y, Z;
              let X, ee;
              let es = (O) => (T.suppressExceptions ? L(O) : J(O)),
                ei = (0, en.checkInvalidKeys)(O, er.VerifyParamsKeys);
              ei.length > 0 &&
                es({
                  success: !1,
                  data: this,
                  error: Error(
                    `${ei.join(", ")} is/are not valid key(s) for VerifyParams.`
                  ),
                });
              let ea = (0, en.checkInvalidKeys)(T, er.VerifyOptsKeys);
              ei.length > 0 &&
                es({
                  success: !1,
                  data: this,
                  error: Error(
                    `${ea.join(", ")} is/are not valid key(s) for VerifyOpts.`
                  ),
                });
              let { signature: eo, domain: ec, nonce: eu, time: eh } = O;
              ec &&
                ec !== this.domain &&
                es({
                  success: !1,
                  data: this,
                  error: new er.SiweError(
                    er.SiweErrorType.DOMAIN_MISMATCH,
                    ec,
                    this.domain
                  ),
                }),
                eu &&
                  eu !== this.nonce &&
                  es({
                    success: !1,
                    data: this,
                    error: new er.SiweError(
                      er.SiweErrorType.NONCE_MISMATCH,
                      eu,
                      this.nonce
                    ),
                  });
              let ed = new Date(eh || new Date());
              if (this.expirationTime) {
                let O = new Date(this.expirationTime);
                ed.getTime() >= O.getTime() &&
                  es({
                    success: !1,
                    data: this,
                    error: new er.SiweError(
                      er.SiweErrorType.EXPIRED_MESSAGE,
                      `${ed.toISOString()} < ${O.toISOString()}`,
                      `${ed.toISOString()} >= ${O.toISOString()}`
                    ),
                  });
              }
              if (this.notBefore) {
                let O = new Date(this.notBefore);
                ed.getTime() < O.getTime() &&
                  es({
                    success: !1,
                    data: this,
                    error: new er.SiweError(
                      er.SiweErrorType.NOT_YET_VALID_MESSAGE,
                      `${ed.toISOString()} >= ${O.toISOString()}`,
                      `${ed.toISOString()} < ${O.toISOString()}`
                    ),
                  });
              }
              try {
                X = this.prepareMessage();
              } catch (O) {
                es({ success: !1, data: this, error: O });
              }
              try {
                ee = (0, et.verifyMessage)(X, eo);
              } catch (O) {
                console.error(O);
              }
              if (ee === this.address) return L({ success: !0, data: this });
              {
                let J = (0, en.checkContractWalletSignature)(
                  this,
                  eo,
                  T.provider
                )
                  .then((O) =>
                    O
                      ? { success: !0, data: this }
                      : {
                          success: !1,
                          data: this,
                          error: new er.SiweError(
                            er.SiweErrorType.INVALID_SIGNATURE,
                            ee,
                            `Resolved address to be ${this.address}`
                          ),
                        }
                  )
                  .catch((O) => ({ success: !1, data: this, error: O }));
                Promise.all([
                  J,
                  null ===
                    (Z =
                      null ===
                        (Y =
                          null ===
                            (W = null == T ? void 0 : T.verificationFallback) ||
                          void 0 === W
                            ? void 0
                            : W.call(T, O, T, this, J)) || void 0 === Y
                        ? void 0
                        : Y.then((O) => O)) || void 0 === Z
                    ? void 0
                    : Z.catch((O) => O),
                ]).then(([O, T]) => {
                  if (T) {
                    if (T.success) return L(T);
                    es(T);
                  } else {
                    if (O.success) return L(O);
                    es(O);
                  }
                });
              }
            });
          });
        }
        validateMessage(...O) {
          var T;
          if (O.length > 0)
            throw new er.SiweError(
              er.SiweErrorType.UNABLE_TO_PARSE,
              "Unexpected argument in the validateMessage function."
            );
          if (
            !this.domain ||
            0 === this.domain.length ||
            !/[^#?]*/.test(this.domain)
          )
            throw new er.SiweError(
              er.SiweErrorType.INVALID_DOMAIN,
              `${this.domain} to be a valid domain.`
            );
          if (!(0, X.isEIP55Address)(this.address))
            throw new er.SiweError(
              er.SiweErrorType.INVALID_ADDRESS,
              (0, et.getAddress)(this.address),
              this.address
            );
          if (!ee.isUri(this.uri))
            throw new er.SiweError(
              er.SiweErrorType.INVALID_URI,
              `${this.uri} to be a valid uri.`
            );
          if ("1" !== this.version)
            throw new er.SiweError(
              er.SiweErrorType.INVALID_MESSAGE_VERSION,
              "1",
              this.version
            );
          let L =
            null ===
              (T = this === null || void 0 === this ? void 0 : this.nonce) ||
            void 0 === T
              ? void 0
              : T.match(/[a-zA-Z0-9]{8,}/);
          if (!L || this.nonce.length < 8 || L[0] !== this.nonce)
            throw new er.SiweError(
              er.SiweErrorType.INVALID_NONCE,
              `Length > 8 (${L.length}). Alphanumeric.`,
              this.nonce
            );
          if (
            (this.issuedAt && !(0, en.isValidISO8601Date)(this.issuedAt)) ||
            (this.expirationTime &&
              !(0, en.isValidISO8601Date)(this.expirationTime)) ||
            (this.notBefore && !(0, en.isValidISO8601Date)(this.notBefore))
          )
            throw Error(er.SiweErrorType.INVALID_TIME_FORMAT);
        }
      }
      T.SiweMessage = es;
    },
    14909: function (O, T, L) {
      // "use strict";
      var J, W, Y;
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.getAddress = T.hashMessage = T.verifyMessage = void 0);
      let Z = L(77806);
      (T.verifyMessage =
        null !==
          (J =
            null === Z.utils || void 0 === Z.utils
              ? void 0
              : Z.utils.verifyMessage) && void 0 !== J
          ? J
          : Z.verifyMessage),
        (T.hashMessage =
          null !==
            (W =
              null === Z.utils || void 0 === Z.utils
                ? void 0
                : Z.utils.hashMessage) && void 0 !== W
            ? W
            : Z.hashMessage),
        (T.getAddress =
          null !==
            (Y =
              null === Z.utils || void 0 === Z.utils
                ? void 0
                : Z.utils.getAddress) && void 0 !== Y
            ? Y
            : Z.getAddress);
    },
    71970: function (O, T, L) {
      // "use strict";
      var J =
          (this && this.__createBinding) ||
          (Object.create
            ? function (O, T, L, J) {
                void 0 === J && (J = L);
                var W = Object.getOwnPropertyDescriptor(T, L);
                (!W ||
                  ("get" in W
                    ? !T.__esModule
                    : W.writable || W.configurable)) &&
                  (W = {
                    enumerable: !0,
                    get: function () {
                      return T[L];
                    },
                  }),
                  Object.defineProperty(O, J, W);
              }
            : function (O, T, L, J) {
                void 0 === J && (J = L), (O[J] = T[L]);
              }),
        W =
          (this && this.__exportStar) ||
          function (O, T) {
            for (var L in O)
              "default" === L ||
                Object.prototype.hasOwnProperty.call(T, L) ||
                J(T, O, L);
          };
      Object.defineProperty(T, "__esModule", { value: !0 }),
        W(L(88177), T),
        W(L(86606), T),
        W(L(84176), T);
    },
    86606: function (O, T) {
      // "use strict";
      var L;
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.SiweErrorType =
          T.SiweError =
          T.VerifyOptsKeys =
          T.VerifyParamsKeys =
            void 0),
        (T.VerifyParamsKeys = ["signature", "domain", "nonce", "time"]),
        (T.VerifyOptsKeys = [
          "provider",
          "suppressExceptions",
          "verificationFallback",
        ]);
      class J {
        constructor(O, T, L) {
          (this.type = O), (this.expected = T), (this.received = L);
        }
      }
      (T.SiweError = J),
        (function (O) {
          (O.EXPIRED_MESSAGE = "Expired message."),
            (O.INVALID_DOMAIN = "Invalid domain."),
            (O.DOMAIN_MISMATCH =
              "Domain does not match provided domain for verification."),
            (O.NONCE_MISMATCH =
              "Nonce does not match provided nonce for verification."),
            (O.INVALID_ADDRESS = "Invalid address."),
            (O.INVALID_URI = "URI does not conform to RFC 3986."),
            (O.INVALID_NONCE =
              "Nonce size smaller then 8 characters or is not alphanumeric."),
            (O.NOT_YET_VALID_MESSAGE = "Message is not valid yet."),
            (O.INVALID_SIGNATURE =
              "Signature does not match address of the message."),
            (O.INVALID_TIME_FORMAT = "Invalid time format."),
            (O.INVALID_MESSAGE_VERSION = "Invalid message version."),
            (O.UNABLE_TO_PARSE = "Unable to parse the message.");
        })((L = T.SiweErrorType || (T.SiweErrorType = {})));
    },
    84176: function (O, T, L) {
      // "use strict";
      var J =
        (this && this.__awaiter) ||
        function (O, T, L, J) {
          function W(O) {
            return O instanceof L
              ? O
              : new L(function (T) {
                  T(O);
                });
          }
          return new (L || (L = Promise))(function (L, Y) {
            function Z(O) {
              try {
                ee(J.next(O));
              } catch (O) {
                Y(O);
              }
            }
            function X(O) {
              try {
                ee(J.throw(O));
              } catch (O) {
                Y(O);
              }
            }
            function ee(O) {
              O.done ? L(O.value) : W(O.value).then(Z, X);
            }
            ee((J = J.apply(O, T || [])).next());
          });
        };
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.checkInvalidKeys =
          T.isValidISO8601Date =
          T.generateNonce =
          T.checkContractWalletSignature =
            void 0);
      let W = L(81214),
        Y = L(77806),
        Z = L(14909),
        X = [
          "function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)",
        ],
        ee = "0x1626ba7e",
        et =
          /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/,
        er = (O, T, L) =>
          J(void 0, void 0, void 0, function* () {
            if (!L) return !1;
            let J = new Y.Contract(O.address, X, L),
              W = (0, Z.hashMessage)(O.prepareMessage());
            return (yield J.isValidSignature(W, T)) == ee;
          });
      T.checkContractWalletSignature = er;
      let en = () => {
        let O = (0, W.randomStringForEntropy)(96);
        if (!O || O.length < 8) throw Error("Error during nonce creation.");
        return O;
      };
      T.generateNonce = en;
      let es = (O) => {
        let T = et.exec(O);
        if (!O) return !1;
        let L = new Date(T.groups.date).toISOString(),
          J = et.exec(L);
        return T.groups.date === J.groups.date;
      };
      T.isValidISO8601Date = es;
      let ei = (O, T) => {
        let L = [];
        return (
          Object.keys(O).forEach((O) => {
            T.includes(O) || L.push(O);
          }),
          L
        );
      };
      T.checkInvalidKeys = ei;
    },
    93036: function (O, T, L) {
      // "use strict";
      var J = L(50250).Buffer,
        W =
          J.isEncoding ||
          function (O) {
            switch ((O = "" + O) && O.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return !0;
              default:
                return !1;
            }
          };
      function Y(O) {
        var T;
        if (!O) return "utf8";
        for (;;)
          switch (O) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return O;
            default:
              if (T) return;
              (O = ("" + O).toLowerCase()), (T = !0);
          }
      }
      function Z(O) {
        var T = Y(O);
        if ("string" != typeof T && (J.isEncoding === W || !W(O)))
          throw Error("Unknown encoding: " + O);
        return T || O;
      }
      function X(O) {
        var T;
        switch (((this.encoding = Z(O)), this.encoding)) {
          case "utf16le":
            (this.text = ea), (this.end = eo), (T = 4);
            break;
          case "utf8":
            (this.fillLast = en), (T = 4);
            break;
          case "base64":
            (this.text = ec), (this.end = eu), (T = 3);
            break;
          default:
            (this.write = eh), (this.end = ed);
            return;
        }
        (this.lastNeed = 0),
          (this.lastTotal = 0),
          (this.lastChar = J.allocUnsafe(T));
      }
      function ee(O) {
        return O <= 127
          ? 0
          : O >> 5 == 6
          ? 2
          : O >> 4 == 14
          ? 3
          : O >> 3 == 30
          ? 4
          : O >> 6 == 2
          ? -1
          : -2;
      }
      function et(O, T, L) {
        var J = T.length - 1;
        if (J < L) return 0;
        var W = ee(T[J]);
        return W >= 0
          ? (W > 0 && (O.lastNeed = W - 1), W)
          : --J < L || -2 === W
          ? 0
          : (W = ee(T[J])) >= 0
          ? (W > 0 && (O.lastNeed = W - 2), W)
          : --J < L || -2 === W
          ? 0
          : (W = ee(T[J])) >= 0
          ? (W > 0 && (2 === W ? (W = 0) : (O.lastNeed = W - 3)), W)
          : 0;
      }
      function er(O, T, L) {
        if ((192 & T[0]) != 128) return (O.lastNeed = 0), "";
        if (O.lastNeed > 1 && T.length > 1) {
          if ((192 & T[1]) != 128) return (O.lastNeed = 1), "";
          if (O.lastNeed > 2 && T.length > 2 && (192 & T[2]) != 128)
            return (O.lastNeed = 2), "";
        }
      }
      function en(O) {
        var T = this.lastTotal - this.lastNeed,
          L = er(this, O, T);
        return void 0 !== L
          ? L
          : this.lastNeed <= O.length
          ? (O.copy(this.lastChar, T, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal))
          : void (O.copy(this.lastChar, T, 0, O.length),
            (this.lastNeed -= O.length));
      }
      function es(O, T) {
        var L = et(this, O, T);
        if (!this.lastNeed) return O.toString("utf8", T);
        this.lastTotal = L;
        var J = O.length - (L - this.lastNeed);
        return O.copy(this.lastChar, 0, J), O.toString("utf8", T, J);
      }
      function ei(O) {
        var T = O && O.length ? this.write(O) : "";
        return this.lastNeed ? T + "" : T;
      }
      function ea(O, T) {
        if ((O.length - T) % 2 == 0) {
          var L = O.toString("utf16le", T);
          if (L) {
            var J = L.charCodeAt(L.length - 1);
            if (J >= 55296 && J <= 56319)
              return (
                (this.lastNeed = 2),
                (this.lastTotal = 4),
                (this.lastChar[0] = O[O.length - 2]),
                (this.lastChar[1] = O[O.length - 1]),
                L.slice(0, -1)
              );
          }
          return L;
        }
        return (
          (this.lastNeed = 1),
          (this.lastTotal = 2),
          (this.lastChar[0] = O[O.length - 1]),
          O.toString("utf16le", T, O.length - 1)
        );
      }
      function eo(O) {
        var T = O && O.length ? this.write(O) : "";
        if (this.lastNeed) {
          var L = this.lastTotal - this.lastNeed;
          return T + this.lastChar.toString("utf16le", 0, L);
        }
        return T;
      }
      function ec(O, T) {
        var L = (O.length - T) % 3;
        return 0 === L
          ? O.toString("base64", T)
          : ((this.lastNeed = 3 - L),
            (this.lastTotal = 3),
            1 === L
              ? (this.lastChar[0] = O[O.length - 1])
              : ((this.lastChar[0] = O[O.length - 2]),
                (this.lastChar[1] = O[O.length - 1])),
            O.toString("base64", T, O.length - L));
      }
      function eu(O) {
        var T = O && O.length ? this.write(O) : "";
        return this.lastNeed
          ? T + this.lastChar.toString("base64", 0, 3 - this.lastNeed)
          : T;
      }
      function eh(O) {
        return O.toString(this.encoding);
      }
      function ed(O) {
        return O && O.length ? this.write(O) : "";
      }
      (T.StringDecoder = X),
        (X.prototype.write = function (O) {
          var T, L;
          if (0 === O.length) return "";
          if (this.lastNeed) {
            if (void 0 === (T = this.fillLast(O))) return "";
            (L = this.lastNeed), (this.lastNeed = 0);
          } else L = 0;
          return L < O.length
            ? T
              ? T + this.text(O, L)
              : this.text(O, L)
            : T || "";
        }),
        (X.prototype.end = ei),
        (X.prototype.text = es),
        (X.prototype.fillLast = function (O) {
          if (this.lastNeed <= O.length)
            return (
              O.copy(
                this.lastChar,
                this.lastTotal - this.lastNeed,
                0,
                this.lastNeed
              ),
              this.lastChar.toString(this.encoding, 0, this.lastTotal)
            );
          O.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, O.length),
            (this.lastNeed -= O.length);
        });
    },
    87152: function (O, T, L) {
      // "use strict";
      L.r(T),
        L.d(T, {
          __assign: function () {
            return Y;
          },
          __asyncDelegator: function () {
            return eg;
          },
          __asyncGenerator: function () {
            return ep;
          },
          __asyncValues: function () {
            return ey;
          },
          __await: function () {
            return ed;
          },
          __awaiter: function () {
            return er;
          },
          __classPrivateFieldGet: function () {
            return ev;
          },
          __classPrivateFieldIn: function () {
            return eE;
          },
          __classPrivateFieldSet: function () {
            return ek;
          },
          __createBinding: function () {
            return es;
          },
          __decorate: function () {
            return X;
          },
          __exportStar: function () {
            return ei;
          },
          __extends: function () {
            return W;
          },
          __generator: function () {
            return en;
          },
          __importDefault: function () {
            return ew;
          },
          __importStar: function () {
            return eA;
          },
          __makeTemplateObject: function () {
            return em;
          },
          __metadata: function () {
            return et;
          },
          __param: function () {
            return ee;
          },
          __read: function () {
            return eo;
          },
          __rest: function () {
            return Z;
          },
          __spread: function () {
            return ec;
          },
          __spreadArray: function () {
            return eh;
          },
          __spreadArrays: function () {
            return eu;
          },
          __values: function () {
            return ea;
          },
        });
      var J = function (O, T) {
        return (J =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (O, T) {
              O.__proto__ = T;
            }) ||
          function (O, T) {
            for (var L in T)
              Object.prototype.hasOwnProperty.call(T, L) && (O[L] = T[L]);
          })(O, T);
      };
      function W(O, T) {
        if ("function" != typeof T && null !== T)
          throw TypeError(
            "Class extends value " + String(T) + " is not a constructor or null"
          );
        function L() {
          this.constructor = O;
        }
        J(O, T),
          (O.prototype =
            null === T
              ? Object.create(T)
              : ((L.prototype = T.prototype), new L()));
      }
      var Y = function () {
        return (Y =
          Object.assign ||
          function (O) {
            for (var T, L = 1, J = arguments.length; L < J; L++)
              for (var W in (T = arguments[L]))
                Object.prototype.hasOwnProperty.call(T, W) && (O[W] = T[W]);
            return O;
          }).apply(this, arguments);
      };
      function Z(O, T) {
        var L = {};
        for (var J in O)
          Object.prototype.hasOwnProperty.call(O, J) &&
            0 > T.indexOf(J) &&
            (L[J] = O[J]);
        if (null != O && "function" == typeof Object.getOwnPropertySymbols)
          for (
            var W = 0, J = Object.getOwnPropertySymbols(O);
            W < J.length;
            W++
          )
            0 > T.indexOf(J[W]) &&
              Object.prototype.propertyIsEnumerable.call(O, J[W]) &&
              (L[J[W]] = O[J[W]]);
        return L;
      }
      function X(O, T, L, J) {
        var W,
          Y = arguments.length,
          Z =
            Y < 3
              ? T
              : null === J
              ? (J = Object.getOwnPropertyDescriptor(T, L))
              : J;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          Z = Reflect.decorate(O, T, L, J);
        else
          for (var X = O.length - 1; X >= 0; X--)
            (W = O[X]) &&
              (Z = (Y < 3 ? W(Z) : Y > 3 ? W(T, L, Z) : W(T, L)) || Z);
        return Y > 3 && Z && Object.defineProperty(T, L, Z), Z;
      }
      function ee(O, T) {
        return function (L, J) {
          T(L, J, O);
        };
      }
      function et(O, T) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
          return Reflect.metadata(O, T);
      }
      function er(O, T, L, J) {
        function W(O) {
          return O instanceof L
            ? O
            : new L(function (T) {
                T(O);
              });
        }
        return new (L || (L = Promise))(function (L, Y) {
          function Z(O) {
            try {
              ee(J.next(O));
            } catch (O) {
              Y(O);
            }
          }
          function X(O) {
            try {
              ee(J.throw(O));
            } catch (O) {
              Y(O);
            }
          }
          function ee(O) {
            O.done ? L(O.value) : W(O.value).then(Z, X);
          }
          ee((J = J.apply(O, T || [])).next());
        });
      }
      function en(O, T) {
        var L,
          J,
          W,
          Y,
          Z = {
            label: 0,
            sent: function () {
              if (1 & W[0]) throw W[1];
              return W[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (Y = { next: X(0), throw: X(1), return: X(2) }),
          "function" == typeof Symbol &&
            (Y[Symbol.iterator] = function () {
              return this;
            }),
          Y
        );
        function X(O) {
          return function (T) {
            return ee([O, T]);
          };
        }
        function ee(Y) {
          if (L) throw TypeError("Generator is already executing.");
          for (; Z; )
            try {
              if (
                ((L = 1),
                J &&
                  (W =
                    2 & Y[0]
                      ? J.return
                      : Y[0]
                      ? J.throw || ((W = J.return) && W.call(J), 0)
                      : J.next) &&
                  !(W = W.call(J, Y[1])).done)
              )
                return W;
              switch (((J = 0), W && (Y = [2 & Y[0], W.value]), Y[0])) {
                case 0:
                case 1:
                  W = Y;
                  break;
                case 4:
                  return Z.label++, { value: Y[1], done: !1 };
                case 5:
                  Z.label++, (J = Y[1]), (Y = [0]);
                  continue;
                case 7:
                  (Y = Z.ops.pop()), Z.trys.pop();
                  continue;
                default:
                  if (
                    !(W = (W = Z.trys).length > 0 && W[W.length - 1]) &&
                    (6 === Y[0] || 2 === Y[0])
                  ) {
                    Z = 0;
                    continue;
                  }
                  if (3 === Y[0] && (!W || (Y[1] > W[0] && Y[1] < W[3]))) {
                    Z.label = Y[1];
                    break;
                  }
                  if (6 === Y[0] && Z.label < W[1]) {
                    (Z.label = W[1]), (W = Y);
                    break;
                  }
                  if (W && Z.label < W[2]) {
                    (Z.label = W[2]), Z.ops.push(Y);
                    break;
                  }
                  W[2] && Z.ops.pop(), Z.trys.pop();
                  continue;
              }
              Y = T.call(O, Z);
            } catch (O) {
              (Y = [6, O]), (J = 0);
            } finally {
              L = W = 0;
            }
          if (5 & Y[0]) throw Y[1];
          return { value: Y[0] ? Y[1] : void 0, done: !0 };
        }
      }
      var es = Object.create
        ? function (O, T, L, J) {
            void 0 === J && (J = L);
            var W = Object.getOwnPropertyDescriptor(T, L);
            (!W ||
              ("get" in W ? !T.__esModule : W.writable || W.configurable)) &&
              (W = {
                enumerable: !0,
                get: function () {
                  return T[L];
                },
              }),
              Object.defineProperty(O, J, W);
          }
        : function (O, T, L, J) {
            void 0 === J && (J = L), (O[J] = T[L]);
          };
      function ei(O, T) {
        for (var L in O)
          "default" === L ||
            Object.prototype.hasOwnProperty.call(T, L) ||
            es(T, O, L);
      }
      function ea(O) {
        var T = "function" == typeof Symbol && Symbol.iterator,
          L = T && O[T],
          J = 0;
        if (L) return L.call(O);
        if (O && "number" == typeof O.length)
          return {
            next: function () {
              return (
                O && J >= O.length && (O = void 0),
                { value: O && O[J++], done: !O }
              );
            },
          };
        throw TypeError(
          T ? "Object is not iterable." : "Symbol.iterator is not defined."
        );
      }
      function eo(O, T) {
        var L = "function" == typeof Symbol && O[Symbol.iterator];
        if (!L) return O;
        var J,
          W,
          Y = L.call(O),
          Z = [];
        try {
          for (; (void 0 === T || T-- > 0) && !(J = Y.next()).done; )
            Z.push(J.value);
        } catch (O) {
          W = { error: O };
        } finally {
          try {
            J && !J.done && (L = Y.return) && L.call(Y);
          } finally {
            if (W) throw W.error;
          }
        }
        return Z;
      }
      function ec() {
        for (var O = [], T = 0; T < arguments.length; T++)
          O = O.concat(eo(arguments[T]));
        return O;
      }
      function eu() {
        for (var O = 0, T = 0, L = arguments.length; T < L; T++)
          O += arguments[T].length;
        for (var J = Array(O), W = 0, T = 0; T < L; T++)
          for (var Y = arguments[T], Z = 0, X = Y.length; Z < X; Z++, W++)
            J[W] = Y[Z];
        return J;
      }
      function eh(O, T, L) {
        if (L || 2 == arguments.length)
          for (var J, W = 0, Y = T.length; W < Y; W++)
            (!J && W in T) ||
              (J || (J = Array.prototype.slice.call(T, 0, W)), (J[W] = T[W]));
        return O.concat(J || Array.prototype.slice.call(T));
      }
      function ed(O) {
        return this instanceof ed ? ((this.v = O), this) : new ed(O);
      }
      function ep(O, T, L) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var J,
          W = L.apply(O, T || []),
          Y = [];
        return (
          (J = {}),
          Z("next"),
          Z("throw"),
          Z("return"),
          (J[Symbol.asyncIterator] = function () {
            return this;
          }),
          J
        );
        function Z(O) {
          W[O] &&
            (J[O] = function (T) {
              return new Promise(function (L, J) {
                Y.push([O, T, L, J]) > 1 || X(O, T);
              });
            });
        }
        function X(O, T) {
          try {
            ee(W[O](T));
          } catch (O) {
            en(Y[0][3], O);
          }
        }
        function ee(O) {
          O.value instanceof ed
            ? Promise.resolve(O.value.v).then(et, er)
            : en(Y[0][2], O);
        }
        function et(O) {
          X("next", O);
        }
        function er(O) {
          X("throw", O);
        }
        function en(O, T) {
          O(T), Y.shift(), Y.length && X(Y[0][0], Y[0][1]);
        }
      }
      function eg(O) {
        var T, L;
        return (
          (T = {}),
          J("next"),
          J("throw", function (O) {
            throw O;
          }),
          J("return"),
          (T[Symbol.iterator] = function () {
            return this;
          }),
          T
        );
        function J(J, W) {
          T[J] = O[J]
            ? function (T) {
                return (L = !L)
                  ? { value: ed(O[J](T)), done: "return" === J }
                  : W
                  ? W(T)
                  : T;
              }
            : W;
        }
      }
      function ey(O) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var T,
          L = O[Symbol.asyncIterator];
        return L
          ? L.call(O)
          : ((O = ea(O)),
            (T = {}),
            J("next"),
            J("throw"),
            J("return"),
            (T[Symbol.asyncIterator] = function () {
              return this;
            }),
            T);
        function J(L) {
          T[L] =
            O[L] &&
            function (T) {
              return new Promise(function (J, Y) {
                W(J, Y, (T = O[L](T)).done, T.value);
              });
            };
        }
        function W(O, T, L, J) {
          Promise.resolve(J).then(function (T) {
            O({ value: T, done: L });
          }, T);
        }
      }
      function em(O, T) {
        return (
          Object.defineProperty
            ? Object.defineProperty(O, "raw", { value: T })
            : (O.raw = T),
          O
        );
      }
      var eb = Object.create
        ? function (O, T) {
            Object.defineProperty(O, "default", { enumerable: !0, value: T });
          }
        : function (O, T) {
            O.default = T;
          };
      function eA(O) {
        if (O && O.__esModule) return O;
        var T = {};
        if (null != O)
          for (var L in O)
            "default" !== L &&
              Object.prototype.hasOwnProperty.call(O, L) &&
              es(T, O, L);
        return eb(T, O), T;
      }
      function ew(O) {
        return O && O.__esModule ? O : { default: O };
      }
      function ev(O, T, L, J) {
        if ("a" === L && !J)
          throw TypeError("Private accessor was defined without a getter");
        if ("function" == typeof T ? O !== T || !J : !T.has(O))
          throw TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        return "m" === L ? J : "a" === L ? J.call(O) : J ? J.value : T.get(O);
      }
      function ek(O, T, L, J, W) {
        if ("m" === J) throw TypeError("Private method is not writable");
        if ("a" === J && !W)
          throw TypeError("Private accessor was defined without a setter");
        if ("function" == typeof T ? O !== T || !W : !T.has(O))
          throw TypeError(
            "Cannot write private member to an object whose class did not declare it"
          );
        return "a" === J ? W.call(O, L) : W ? (W.value = L) : T.set(O, L), L;
      }
      function eE(O, T) {
        if (null === T || ("object" != typeof T && "function" != typeof T))
          throw TypeError("Cannot use 'in' operator on non-object");
        return "function" == typeof O ? T === O : O.has(T);
      }
    },
    65365: function (O, T, L) {
      !(function (O) {
        // "use strict";
        (O.exports.is_uri = L),
          (O.exports.is_http_uri = J),
          (O.exports.is_https_uri = W),
          (O.exports.is_web_uri = Y),
          (O.exports.isUri = L),
          (O.exports.isHttpUri = J),
          (O.exports.isHttpsUri = W),
          (O.exports.isWebUri = Y);
        var T = function (O) {
          return O.match(
            /(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
          );
        };
        function L(O) {
          if (
            !(
              !O ||
              /[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(
                O
              ) ||
              /%[^0-9a-f]/i.test(O) ||
              /%[0-9a-f](:?[^0-9a-f]|$)/i.test(O)
            )
          ) {
            var L = [],
              J = "",
              W = "",
              Y = "",
              Z = "",
              X = "",
              ee = "";
            if (
              ((J = (L = T(O))[1]),
              (W = L[2]),
              (Y = L[3]),
              (Z = L[4]),
              (X = L[5]),
              J && J.length && Y.length >= 0)
            ) {
              if (W && W.length) {
                if (!(0 === Y.length || /^\//.test(Y))) return;
              } else if (/^\/\//.test(Y)) return;
              if (/^[a-z][a-z0-9\+\-\.]*$/.test(J.toLowerCase()))
                return (
                  (ee += J + ":"),
                  W && W.length && (ee += "//" + W),
                  (ee += Y),
                  Z && Z.length && (ee += "?" + Z),
                  X && X.length && (ee += "#" + X),
                  ee
                );
            }
          }
        }
        function J(O, J) {
          if (L(O)) {
            var W = [],
              Y = "",
              Z = "",
              X = "",
              ee = "",
              et = "",
              er = "",
              en = "";
            if (
              ((Y = (W = T(O))[1]),
              (Z = W[2]),
              (X = W[3]),
              (et = W[4]),
              (er = W[5]),
              Y)
            ) {
              if (J) {
                if ("https" != Y.toLowerCase()) return;
              } else if ("http" != Y.toLowerCase()) return;
              if (!Z) return;
              return (
                /:(\d+)$/.test(Z) &&
                  ((ee = Z.match(/:(\d+)$/)[0]), (Z = Z.replace(/:\d+$/, ""))),
                (en += Y + ":"),
                (en += "//" + Z),
                ee && (en += ee),
                (en += X),
                et && et.length && (en += "?" + et),
                er && er.length && (en += "#" + er),
                en
              );
            }
          }
        }
        function W(O) {
          return J(O, !0);
        }
        function Y(O) {
          return J(O) || W(O);
        }
      })((O = L.nmd(O)));
    },
    13467: function (O, T) {
      // "use strict";
      let L, J, W, Y, Z, X, ee, et, er, en, es, ei, ea, eo, ec, eu;
      var eh =
        "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
      let ed = new Map([
          [8217, "apostrophe"],
          [8260, "fraction slash"],
          [12539, "middle dot"],
        ]),
        ep = 4;
      function eg(O) {
        let T = 0;
        function L() {
          return (O[T++] << 8) | O[T++];
        }
        let J = L(),
          W = 1,
          Y = [0, 1];
        for (let O = 1; O < J; O++) Y.push((W += L()));
        let Z = L(),
          X = T;
        T += Z;
        let ee = 0,
          et = 0;
        function er() {
          return (
            0 == ee && ((et = (et << 8) | O[T++]), (ee = 8)), (et >> --ee) & 1
          );
        }
        let en = 31,
          es = 2147483648,
          ei = 1073741824,
          ea = 536870912,
          eo = 2147483648 - 1,
          ec = 0;
        for (let O = 0; O < en; O++) ec = (ec << 1) | er();
        let eu = [],
          eh = 0,
          ed = es;
        for (;;) {
          let O = Math.floor(((ec - eh + 1) * W - 1) / ed),
            T = 0,
            L = J;
          for (; L - T > 1; ) {
            let J = (T + L) >>> 1;
            O < Y[J] ? (L = J) : (T = J);
          }
          if (0 == T) break;
          eu.push(T);
          let Z = eh + Math.floor((ed * Y[T]) / W),
            X = eh + Math.floor((ed * Y[T + 1]) / W) - 1;
          for (; ((Z ^ X) & ei) == 0; )
            (ec = ((ec << 1) & eo) | er()),
              (Z = (Z << 1) & eo),
              (X = ((X << 1) & eo) | 1);
          for (; Z & ~X & ea; )
            (ec = (ec & ei) | ((ec << 1) & (eo >>> 1)) | er()),
              (Z = (Z << 1) ^ ei),
              (X = ((X ^ ei) << 1) | ei | 1);
          (eh = Z), (ed = 1 + X - Z);
        }
        let ep = J - 4;
        return eu.map((T) => {
          switch (T - ep) {
            case 3:
              return ep + 65792 + ((O[X++] << 16) | (O[X++] << 8) | O[X++]);
            case 2:
              return ep + 256 + ((O[X++] << 8) | O[X++]);
            case 1:
              return ep + O[X++];
            default:
              return T - 1;
          }
        });
      }
      function ey(O) {
        let T = 0;
        return () => O[T++];
      }
      function em(O) {
        return ey(eg(eb(O)));
      }
      function eb(O) {
        let T = [];
        [
          ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        ].forEach((O, L) => (T[O.charCodeAt(0)] = L));
        let L = O.length,
          J = new Uint8Array((6 * L) >> 3);
        for (let W = 0, Y = 0, Z = 0, X = 0; W < L; W++)
          (X = (X << 6) | T[O.charCodeAt(W)]),
            (Z += 6) >= 8 && (J[Y++] = X >> (Z -= 8));
        return J;
      }
      function eA(O) {
        return 1 & O ? ~O >> 1 : O >> 1;
      }
      function ew(O, T) {
        let L = Array(O);
        for (let J = 0, W = 0; J < O; J++) L[J] = W += eA(T());
        return L;
      }
      function ev(O, T = 0) {
        let L = [];
        for (;;) {
          let J = O(),
            W = O();
          if (!W) break;
          T += J;
          for (let O = 0; O < W; O++) L.push(T + O);
          T += W + 1;
        }
        return L;
      }
      function ek(O) {
        return eS(() => {
          let T = ev(O);
          if (T.length) return T;
        });
      }
      function eE(O) {
        let T = [];
        for (;;) {
          let L = O();
          if (0 == L) break;
          T.push(eC(L, O));
        }
        for (;;) {
          let L = O() - 1;
          if (L < 0) break;
          T.push(eB(L, O));
        }
        return T.flat();
      }
      function eS(O) {
        let T = [];
        for (;;) {
          let L = O(T.length);
          if (!L) break;
          T.push(L);
        }
        return T;
      }
      function eP(O, T, L) {
        let J = Array(O)
          .fill()
          .map(() => []);
        for (let W = 0; W < T; W++) ew(O, L).forEach((O, T) => J[T].push(O));
        return J;
      }
      function eC(O, T) {
        let L = 1 + T(),
          J = T(),
          W = eS(T);
        return eP(W.length, 1 + O, T).flatMap((O, T) => {
          let [Y, ...Z] = O;
          return Array(W[T])
            .fill()
            .map((O, T) => {
              let W = T * J;
              return [Y + T * L, Z.map((O) => O + W)];
            });
        });
      }
      function eB(O, T) {
        return eP(1 + T(), 1 + O, T).map((O) => [O[0], O.slice(1)]);
      }
      function eO(O) {
        let T = [],
          L = ev(O);
        return W(J([]), []), T;
        function J(T) {
          return {
            S: O(),
            B: eS(() => {
              let T = ev(O).map((O) => L[O]);
              if (T.length) return J(T);
            }),
            Q: T,
          };
        }
        function W({ S: O, B: L }, J, Y) {
          if (!(4 & O) || Y !== J[J.length - 1])
            for (let Z of (2 & O && (Y = J[J.length - 1]),
            1 & O && T.push(J),
            L))
              for (let O of Z.Q) W(Z, [...J, O], Y);
        }
      }
      function eT(O) {
        return O.toString(16).toUpperCase().padStart(2, "0");
      }
      function eN(O) {
        return `{${eT(O)}}`;
      }
      function eR(O) {
        let T = [];
        for (let L = 0, J = O.length; L < J; ) {
          let J = O.codePointAt(L);
          (L += J < 65536 ? 1 : 2), T.push(J);
        }
        return T;
      }
      function eI(O) {
        let T = 4096,
          L = O.length;
        if (L < T) return String.fromCodePoint(...O);
        let J = [];
        for (let W = 0; W < L; )
          J.push(String.fromCodePoint(...O.slice(W, (W += T))));
        return J.join("");
      }
      function eM(O, T) {
        let L = O.length,
          J = L - T.length;
        for (let W = 0; 0 == J && W < L; W++) J = O[W] - T[W];
        return J;
      }
      var eU =
        "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
      let eL = 44032,
        eD = 4352,
        e_ = 4449,
        eF = 4519,
        eK = 28,
        ej = 588,
        eH = 55204,
        e$ = 4371,
        eV = 4470,
        eG = 4547;
      function eJ(O) {
        return (O >> 24) & 255;
      }
      function ez(O) {
        return 16777215 & O;
      }
      function eQ() {
        let O = em(eU);
        for (let [T, Z] of ((L = new Map(
          ek(O).flatMap((O, T) => O.map((O) => [O, (T + 1) << 24]))
        )),
        (J = new Set(ev(O))),
        (W = new Map()),
        (Y = new Map()),
        eE(O))) {
          if (!J.has(T) && 2 == Z.length) {
            let [O, L] = Z,
              J = Y.get(O);
            J || ((J = new Map()), Y.set(O, J)), J.set(L, T);
          }
          W.set(T, Z.reverse());
        }
      }
      function eq(O) {
        return O >= eL && O < eH;
      }
      function eW(O, T) {
        if (O >= eD && O < e$ && T >= e_ && T < eV)
          return eL + (O - eD) * ej + (T - e_) * eK;
        if (eq(O) && T > eF && T < eG && (O - eL) % eK == 0)
          return O + (T - eF);
        {
          let L = Y.get(O);
          return L && (L = L.get(T)) ? L : -1;
        }
      }
      function eY(O) {
        L || eQ();
        let T = [],
          J = [],
          Y = !1;
        function Z(O) {
          let J = L.get(O);
          J && ((Y = !0), (O |= J)), T.push(O);
        }
        for (let L of O)
          for (;;) {
            if (L < 128) T.push(L);
            else if (eq(L)) {
              let O = L - eL,
                T = (O / ej) | 0,
                J = ((O % ej) / eK) | 0,
                W = O % eK;
              Z(eD + T), Z(e_ + J), W > 0 && Z(eF + W);
            } else {
              let O = W.get(L);
              O ? J.push(...O) : Z(L);
            }
            if (!J.length) break;
            L = J.pop();
          }
        if (Y && T.length > 1) {
          let O = eJ(T[0]);
          for (let L = 1; L < T.length; L++) {
            let J = eJ(T[L]);
            if (0 == J || O <= J) {
              O = J;
              continue;
            }
            let W = L - 1;
            for (;;) {
              let L = T[W + 1];
              if (((T[W + 1] = T[W]), (T[W] = L), !W || (O = eJ(T[--W])) <= J))
                break;
            }
            O = eJ(T[L]);
          }
        }
        return T;
      }
      function eZ(O) {
        let T = [],
          L = [],
          J = -1,
          W = 0;
        for (let Y of O) {
          let O = eJ(Y),
            Z = ez(Y);
          if (-1 == J) 0 == O ? (J = Z) : T.push(Z);
          else if (W > 0 && W >= O)
            0 == O ? (T.push(J, ...L), (L.length = 0), (J = Z)) : L.push(Z),
              (W = O);
          else {
            let Y = eW(J, Z);
            Y >= 0
              ? (J = Y)
              : 0 == W && 0 == O
              ? (T.push(J), (J = Z))
              : (L.push(Z), (W = O));
          }
        }
        return J >= 0 && T.push(J, ...L), T;
      }
      function eX(O) {
        return eY(O).map(ez);
      }
      function e0(O) {
        return eZ(eY(O));
      }
      let e1 = 45,
        e2 = 46,
        e3 = ".",
        e4 = 65039,
        e8 = 1,
        e6 = (O) => Array.from(O);
      function e5(O, T) {
        return O.P.has(T) || O.Q.has(T);
      }
      class e7 extends Array {
        get is_emoji() {
          return !0;
        }
      }
      function e9() {
        if (Z) return;
        let O = em(eh),
          T = () => ev(O),
          L = () => new Set(T()),
          J = (O, T) => T.forEach((T) => O.add(T));
        (Z = new Map(eE(O))),
          (X = L()),
          (ee = T()),
          (et = new Set(T().map((O) => ee[O]))),
          (ee = new Set(ee)),
          (er = L()),
          (en = L());
        let W = ek(O),
          Y = O(),
          ed = () => {
            let O = new Set();
            return T().forEach((T) => J(O, W[T])), J(O, T()), O;
          };
        (es = eS((T) => {
          let L = eS(O).map((O) => O + 96);
          if (L.length) {
            let J = T >= Y;
            return (
              (L[0] -= 32),
              (L = eI(L)),
              J && (L = `Restricted[${L}]`),
              { N: L, P: ed(), Q: ed(), M: !O(), R: J }
            );
          }
        })),
          (ei = L()),
          (ea = new Map());
        let ep = T()
          .concat(e6(ei))
          .sort((O, T) => O - T);
        for (let { V: T, M: L } of (ep.forEach((T, L) => {
          let J = O(),
            W = (ep[L] = J ? ep[L - J] : { V: [], M: new Map() });
          W.V.push(T), ei.has(T) || ea.set(T, W);
        }),
        new Set(ea.values()))) {
          let O = [];
          for (let L of T) {
            let T = es.filter((O) => e5(O, L)),
              W = O.find(({ G: O }) => T.some((T) => O.has(T)));
            W || ((W = { G: new Set(), V: [] }), O.push(W)),
              W.V.push(L),
              J(W.G, T);
          }
          let W = O.flatMap((O) => e6(O.G));
          for (let { G: T, V: J } of O) {
            let O = new Set(W.filter((O) => !T.has(O)));
            for (let T of J) L.set(T, O);
          }
        }
        eo = new Set();
        let eg = new Set(),
          ey = (O) => (eo.has(O) ? eg.add(O) : eo.add(O));
        for (let O of es) {
          for (let T of O.P) ey(T);
          for (let T of O.Q) ey(T);
        }
        for (let O of eo) ea.has(O) || eg.has(O) || ea.set(O, e8);
        for (let T of (J(eo, eX(eo)),
        (ec = eO(O)
          .map((O) => e7.from(O))
          .sort(eM)),
        (eu = new Map()),
        ec)) {
          let O = [eu];
          for (let L of T) {
            let T = O.map((O) => {
              let T = O.get(L);
              return T || ((T = new Map()), O.set(L, T)), T;
            });
            L === e4 ? O.push(...T) : (O = T);
          }
          for (let L of O) L.V = T;
        }
      }
      function te(O) {
        return (th(O) ? "" : `${tr(tc([O]))} `) + eN(O);
      }
      function tr(O) {
        return `"${O}"\u200E`;
      }
      function tn(O) {
        if (O.length >= 4 && O[2] == e1 && O[3] == e1)
          throw Error(`invalid label extension: "${eI(O.slice(0, 4))}"`);
      }
      function ta(O) {
        let T = 95;
        for (let L = O.lastIndexOf(T); L > 0; )
          if (O[--L] !== T) throw Error("underscore allowed only at start");
      }
      function tl(O) {
        let T = O[0],
          L = ed.get(T);
        if (L) throw tP(`leading ${L}`);
        let J = O.length,
          W = -1;
        for (let Y = 1; Y < J; Y++) {
          T = O[Y];
          let J = ed.get(T);
          if (J) {
            if (W == Y) throw tP(`${L} + ${J}`);
            (W = Y + 1), (L = J);
          }
        }
        if (W == J) throw tP(`trailing ${L}`);
      }
      function tc(O, T = 1 / 0, L = eN) {
        let J = [];
        tu(O[0]) && J.push(""),
          O.length > T &&
            ((T >>= 1), (O = [...O.slice(0, T), 8230, ...O.slice(-T)]));
        let W = 0,
          Y = O.length;
        for (let T = 0; T < Y; T++) {
          let Y = O[T];
          th(Y) && (J.push(eI(O.slice(W, T))), J.push(L(Y)), (W = T + 1));
        }
        return J.push(eI(O.slice(W, Y))), J.join("");
      }
      function tu(O) {
        return e9(), ee.has(O);
      }
      function th(O) {
        return e9(), er.has(O);
      }
      function td() {
        return e9(), ec.map((O) => O.slice());
      }
      function tp(O, T) {
        e9();
        let L = T ? eX : e0;
        return O.split(e3)
          .map((O) => eI(tB(eR(O), L, tO).flat()))
          .join(e3);
      }
      function tf(O) {
        return tv(tb(O, e0, tO));
      }
      function tg(O) {
        let T = tb(O, e0, (O) => O);
        for (let { type: O, output: L, error: J } of T) {
          if (J) break;
          "Greek" !== O && ty(L, 958, 926);
        }
        return tv(T);
      }
      function ty(O, T, L) {
        let J = 0;
        for (;;) {
          let W = O.indexOf(T, J);
          if (W < 0) break;
          (O[W] = L), (J = W + 1);
        }
      }
      function tm(O, T) {
        return tb(O, e0, T ? (O) => O.slice() : tO);
      }
      function tb(O, T, L) {
        if (!O) return [];
        e9();
        let J = 0;
        return O.split(e3).map((O) => {
          let W = eR(O),
            Y = { input: W, offset: J };
          J += W.length + 1;
          try {
            let O,
              J = (Y.tokens = tB(W, T, L)),
              Z = J.length;
            if (!Z) throw Error("empty label");
            let X = (Y.output = J.flat());
            if (
              (ta(X),
              !(Y.emoji = Z > 1 || J[0].is_emoji) && X.every((O) => O < 128))
            )
              tn(X), (O = "ASCII");
            else {
              let T = J.flatMap((O) => (O.is_emoji ? [] : O));
              if (T.length) {
                if (ee.has(X[0])) throw tP("leading combining mark");
                for (let O = 1; O < Z; O++) {
                  let T = J[O];
                  if (!T.is_emoji && ee.has(T[0]))
                    throw tP(
                      `emoji + combining mark: "${eI(J[O - 1])} + ${tc([
                        T[0],
                      ])}"`
                    );
                }
                tl(X);
                let L = e6(new Set(T)),
                  [W] = tw(L);
                tC(W, T), tA(W, L), (O = W.N);
              } else O = "Emoji";
            }
            Y.type = O;
          } catch (O) {
            Y.error = O;
          }
          return Y;
        });
      }
      function tA(O, T) {
        let L;
        let J = [];
        for (let O of T) {
          let T = ea.get(O);
          if (T === e8) return;
          if (T) {
            let J = T.M.get(O);
            if (!(L = L ? L.filter((O) => J.has(O)) : e6(J)).length) return;
          } else J.push(O);
        }
        if (L) {
          for (let T of L)
            if (J.every((O) => e5(T, O)))
              throw Error(`whole-script confusable: ${O.N}/${T.N}`);
        }
      }
      function tw(O) {
        let T = es;
        for (let L of O) {
          let O = T.filter((O) => e5(O, L));
          if (!O.length) {
            if (es.some((O) => e5(O, L))) throw tS(T[0], L);
            throw tE(L);
          }
          if (((T = O), 1 == O.length)) break;
        }
        return T;
      }
      function tv(O) {
        return O.map(({ input: T, error: L, output: J }) => {
          if (L) {
            let J = L.message;
            throw Error(
              1 == O.length ? J : `Invalid label ${tr(tc(T, 63))}: ${J}`
            );
          }
          return eI(J);
        }).join(e3);
      }
      function tE(O) {
        return Error(`disallowed character: ${te(O)}`);
      }
      function tS(O, T) {
        let L = te(T),
          J = es.find((O) => O.P.has(T));
        return (
          J && (L = `${J.N} ${L}`), Error(`illegal mixture: ${O.N} + ${L}`)
        );
      }
      function tP(O) {
        return Error(`illegal placement: ${O}`);
      }
      function tC(O, T) {
        for (let L of T) if (!e5(O, L)) throw tS(O, L);
        if (O.M) {
          let O = eX(T);
          for (let T = 1, L = O.length; T < L; T++)
            if (et.has(O[T])) {
              let J = T + 1;
              for (let W; J < L && et.has((W = O[J])); J++)
                for (let L = T; L < J; L++)
                  if (O[L] == W)
                    throw Error(`duplicate non-spacing marks: ${te(W)}`);
              if (J - T > ep)
                throw Error(
                  `excessive non-spacing marks: ${tr(tc(O.slice(T - 1, J)))} (${
                    J - T
                  }/${ep})`
                );
              T = J;
            }
        }
      }
      function tB(O, T, L) {
        let J = [],
          W = [];
        for (O = O.slice().reverse(); O.length; ) {
          let Y = tT(O);
          if (Y) W.length && (J.push(T(W)), (W = [])), J.push(L(Y));
          else {
            let T = O.pop();
            if (eo.has(T)) W.push(T);
            else {
              let O = Z.get(T);
              if (O) W.push(...O);
              else if (!X.has(T)) throw tE(T);
            }
          }
        }
        return W.length && J.push(T(W)), J;
      }
      function tO(O) {
        return O.filter((O) => O != e4);
      }
      function tT(O, T) {
        let L,
          J = eu,
          W = O.length;
        for (; W && (J = J.get(O[--W])); ) {
          let { V: Y } = J;
          Y && ((L = Y), T && T.push(...O.slice(W).reverse()), (O.length = W));
        }
        return L;
      }
      let tN = "valid",
        tR = "mapped",
        tI = "ignored",
        tM = "disallowed",
        tU = "emoji",
        tL = "nfc",
        tD = "stop";
      function t_(O, { nf: T = !0 } = {}) {
        e9();
        let L = eR(O).reverse(),
          J = [],
          W = [];
        for (; L.length; ) {
          let O = tT(L, J);
          if (O)
            W.push({ type: tU, emoji: O.slice(), input: J, cps: tO(O) }),
              (J = []);
          else {
            let O = L.pop();
            if (O == e2) W.push({ type: tD, cp: O });
            else if (eo.has(O)) W.push({ type: tN, cps: [O] });
            else if (X.has(O)) W.push({ type: tI, cp: O });
            else {
              let T = Z.get(O);
              T
                ? W.push({ type: tR, cp: O, cps: T.slice() })
                : W.push({ type: tM, cp: O });
            }
          }
        }
        if (T)
          for (let O = 0, T = -1; O < W.length; O++) {
            let L = W[O];
            if (tF(L.type)) {
              if (tK(L.cps)) {
                let L = O + 1;
                for (let O = L; O < W.length; O++) {
                  let { type: T, cps: J } = W[O];
                  if (tF(T)) {
                    if (!tK(J)) break;
                    L = O + 1;
                  } else if (T !== tI) break;
                }
                T < 0 && (T = O);
                let J = W.slice(T, L),
                  Y = J.flatMap((O) => (tF(O.type) ? O.cps : [])),
                  Z = e0(Y);
                eM(Z, Y)
                  ? (W.splice(T, L - T, {
                      type: tL,
                      input: Y,
                      cps: Z,
                      tokens0: tj(J),
                      tokens: t_(eI(Z), { nf: !1 }),
                    }),
                    (O = T))
                  : (O = L - 1),
                  (T = -1);
              } else T = O;
            } else L.type !== tI && (T = -1);
          }
        return tj(W);
      }
      function tF(O) {
        return O == tN || O == tR;
      }
      function tK(O) {
        return O.some((O) => en.has(O));
      }
      function tj(O) {
        for (let T = 0; T < O.length; T++)
          if (O[T].type == tN) {
            let L = T + 1;
            for (; L < O.length && O[L].type == tN; ) L++;
            O.splice(T, L - T, {
              type: tN,
              cps: O.slice(T, L).flatMap((O) => O.cps),
            });
          }
        return O;
      }
      (T.ens_beautify = tg),
        (T.ens_emoji = td),
        (T.ens_normalize = tf),
        (T.ens_normalize_fragment = tp),
        (T.ens_split = tm),
        (T.ens_tokenize = t_),
        (T.is_combining_mark = tu),
        (T.nfc = e0),
        (T.nfd = eX),
        (T.safe_str_from_cps = tc),
        (T.should_escape = th);
    },
    40543: function (O, T) {
      // "use strict";
      /*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */ var L,
        J,
        W,
        Y =
          (this && this.__classPrivateFieldGet) ||
          function (O, T, L, J) {
            if ("a" === L && !J)
              throw TypeError("Private accessor was defined without a getter");
            if ("function" == typeof T ? O !== T || !J : !T.has(O))
              throw TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return "m" === L
              ? J
              : "a" === L
              ? J.call(O)
              : J
              ? J.value
              : T.get(O);
          },
        Z =
          (this && this.__classPrivateFieldSet) ||
          function (O, T, L, J, W) {
            if ("m" === J) throw TypeError("Private method is not writable");
            if ("a" === J && !W)
              throw TypeError("Private accessor was defined without a setter");
            if ("function" == typeof T ? O !== T || !W : !T.has(O))
              throw TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              "a" === J ? W.call(O, L) : W ? (W.value = L) : T.set(O, L), L
            );
          };
      Object.defineProperty(T, "__esModule", { value: !0 }), (T.AES = void 0);
      let X = { 16: 10, 24: 12, 32: 14 },
        ee = [
          1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94,
          188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145,
        ],
        et = [
          99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171,
          118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156,
          164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241,
          113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226,
          235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179,
          41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190,
          57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2,
          127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182,
          218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196,
          167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136,
          70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92,
          194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213,
          78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28,
          166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181,
          102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248,
          152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140,
          161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22,
        ],
        er = [
          82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215,
          251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222,
          233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66,
          250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73,
          109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164,
          92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94,
          21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10,
          247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2,
          193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234,
          151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173,
          53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29,
          41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75,
          198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221,
          168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81,
          127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160,
          224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97,
          23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125,
        ],
        en = [
          3328402341, 4168907908, 4000806809, 4135287693, 4294111757,
          3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241,
          1445669757, 3892248089, 3050821474, 1303096294, 3967186586,
          2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171,
          2387036105, 4226871307, 1101901292, 3017069671, 1604494077,
          1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402,
          3791519004, 1033081774, 1277568618, 1815492186, 2118074177,
          4126668546, 2211236943, 1748251740, 1369810420, 3521504564,
          4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908,
          2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135,
          798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438,
          1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972,
          874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614,
          1983593293, 3084310113, 2108928974, 1378429307, 3722699582,
          1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436,
          1075847264, 3825007647, 2041688520, 3059440621, 3563743934,
          2378943302, 1740553945, 1916352843, 2487896798, 2555137236,
          2958579944, 2244988746, 3151024235, 3320835882, 1336584933,
          3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663,
          3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106,
          1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413,
          563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573,
          1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300,
          403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436,
          773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572,
          3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905,
          2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882,
          3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493,
          2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571,
          201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935,
          3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010,
          2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682,
          1235855840, 3630984372, 2891339514, 4092916743, 3488279077,
          3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016,
          1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513,
          3421038627, 2715671932, 3899946140, 1042226977, 2521517021,
          1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956,
          3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891,
          1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535,
          664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707,
          2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602,
          3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671,
          1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982,
          3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163,
          2824099068, 1841019862, 739644986,
        ],
        es = [
          2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027,
          2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147,
          434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938,
          1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592,
          3963727277, 1739838676, 4250903202, 3930435503, 3206782108,
          4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059,
          1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980,
          4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049,
          1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536,
          2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848,
          1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793,
          2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018,
          4217086112, 4137964114, 1299594043, 1639438038, 3464344499,
          2068982057, 1054729187, 1901997871, 2534638724, 4121318227,
          1757008337, 0, 750906861, 1614815264, 535035132, 3363418545,
          3988151131, 3201591914, 1183697867, 3647454910, 1265776953,
          3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087,
          3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261,
          3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428,
          3123027871, 3813386408, 4087501137, 4267549603, 3229630528,
          2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548,
          3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083,
          1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855,
          2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534,
          1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144,
          2551808385, 3516813135, 2141445340, 1715741218, 2119445034,
          2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540,
          2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026,
          1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516,
          1570751170, 1857934291, 4014189740, 2797888098, 2822345105,
          2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319,
          3084545389, 2348912013, 1689376213, 3533459022, 3762923945,
          3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810,
          3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758,
          607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877,
          2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234,
          2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067,
          33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753,
          2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800,
          3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444,
          3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045,
          2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245,
          3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313,
          2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766,
        ],
        ei = [
          1671808611, 2089089148, 2006576759, 2072901243, 4061003762,
          1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671,
          729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426,
          2191335298, 3376449993, 2106063485, 4195741690, 1508618841,
          1204391495, 4027317232, 2917941677, 3563566036, 2734514082,
          2951366063, 2629772188, 2767672228, 1922491506, 3227229120,
          3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767,
          4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329,
          1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279,
          593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466,
          118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711,
          2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610,
          455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283,
          3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444,
          1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412,
          2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753,
          1256100938, 1289001036, 1491644504, 3477767631, 3496721360,
          4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739,
          2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960,
          1011120188, 2679776671, 2833468328, 1374921297, 2751356323,
          1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005,
          3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895,
          4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324,
          1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711,
          2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699,
          1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154,
          2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740,
          3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546,
          978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276,
          3260915650, 3547250131, 2901361580, 1655096418, 2443721105,
          2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799,
          1840765549, 2374762893, 3580146133, 1322425422, 2850048425,
          1823791212, 1459268694, 4094161908, 3928346602, 1706019429,
          2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469,
          779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072,
          3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315,
          2323976074, 1888542832, 1044544574, 3049550261, 1722469478,
          1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557,
          1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430,
          3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385,
          2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169,
          3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649,
          2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440,
          1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308,
          3151392187, 372911126,
        ],
        ea = [
          1667474886, 2088535288, 2004326894, 2071694838, 4075949567,
          1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926,
          724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711,
          2189597983, 3385409673, 2105378810, 4210693615, 1499065266,
          1195886990, 4042263547, 2913856577, 3570689971, 2728590687,
          2947541573, 2627518243, 2762274643, 1920112356, 3233831835,
          3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142,
          4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529,
          1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789,
          589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191,
          117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286,
          2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380,
          454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198,
          3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939,
          1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667,
          2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178,
          1246420628, 1280103576, 1482221744, 3486468741, 3503319995,
          4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214,
          2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760,
          1010582648, 2678045221, 2829640523, 1364325282, 2745433693,
          1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505,
          3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645,
          4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699,
          1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621,
          2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854,
          1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924,
          2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440,
          3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716,
          976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736,
          3267517855, 3553849021, 2897014595, 1650632388, 2442242105,
          2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254,
          1835907034, 2374863873, 3587531953, 1313788572, 2846482505,
          1819063512, 1448540844, 4109633523, 3941213647, 1701162954,
          2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314,
          774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627,
          3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845,
          2324333839, 1886425312, 1044267644, 3048588401, 1718004428,
          1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282,
          1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215,
          3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025,
          2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609,
          3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649,
          2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520,
          1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848,
          3149649517, 370555436,
        ],
        eo = [
          1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753,
          2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485,
          1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703,
          1172967064, 1576976609, 3274667266, 2169303058, 2370213795,
          1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213,
          1484005843, 1239443753, 2395588676, 1975683434, 4102977912,
          2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444,
          1675577880, 3843699074, 2538681184, 1649639237, 2976151520,
          3144396420, 4269907996, 4178062228, 1883793496, 2403728665,
          2497604743, 1383856311, 2876494627, 1917518562, 3810496343,
          1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610,
          599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432,
          1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293,
          2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582,
          3178106961, 1042385657, 2531067453, 3711829422, 1306967366,
          2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327,
          2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,
          2709260871, 2084704233, 4169408201, 0, 159417987, 841739592,
          504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415,
          168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535,
          3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374,
          3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893,
          766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109,
          4144047775, 1551037884, 1147550661, 1543208500, 2336434550,
          3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808,
          2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059,
          3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682,
          1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455,
          3644379585, 2362090238, 2564033334, 2801107407, 2776292904,
          3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698,
          4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924,
          1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923,
          3441850377, 1851332852, 3969562369, 2203032232, 3868552805,
          2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284,
          699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047,
          4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806,
          395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715,
          1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171,
          4211818798, 3009879386, 2463879762, 3910161971, 1842759443,
          2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029,
          3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775,
          1408749034, 1610459739, 3745345300, 2017778566, 3400528769,
          3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627,
          4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265,
          3576870512, 1215061108, 3501741890,
        ],
        ec = [
          1347548327, 1400783205, 3273267108, 2520393566, 3409685355,
          4045380933, 2880240216, 2471224067, 1428173050, 4138563181,
          2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155,
          1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728,
          2743944855, 3328955385, 3875770207, 2501218972, 3955191162,
          3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409,
          2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132,
          3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975,
          2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428,
          3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120,
          53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122,
          1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468,
          3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033,
          1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602,
          1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868,
          4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618,
          2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166,
          0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663,
          1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604,
          975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021,
          2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560,
          487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081,
          1286567175, 3152976349, 4255350624, 2683765030, 3160175349,
          3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617,
          3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061,
          296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347,
          1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879,
          3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419,
          3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554,
          2607439820, 1649704518, 3270937875, 3901806776, 1580087799,
          4118987695, 3198115200, 2087309459, 2842678573, 3016697106,
          1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472,
          32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392,
          3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259,
          818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840,
          1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904,
          1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889,
          77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242,
          870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476,
          4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235,
          2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891,
          2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253,
          2334669897, 1107234197, 1899603969, 3725069491, 2631447780,
          2422494913, 1635502980, 1893020342, 1950903388, 1120974935,
        ],
        eu = [
          2807058932, 1699970625, 2764249623, 1586903591, 1808481195,
          1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228,
          1277555970, 3623636965, 3419915562, 1149249077, 2744104290,
          1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588,
          2544078150, 4190530515, 1608975247, 2627016082, 2062270317,
          1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554,
          2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312,
          984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180,
          2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798,
          4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195,
          3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107,
          2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658,
          3201631749, 1646252340, 4270507174, 1402811438, 1436590835,
          3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366,
          2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892,
          3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497,
          1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938,
          516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170,
          4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260,
          1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075,
          3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128,
          3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854,
          428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354,
          1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452,
          3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051,
          840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177,
          376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744,
          752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444,
          2177869557, 3727205754, 2384911031, 3215212461, 2648976442,
          2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569,
          2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044,
          2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634,
          2594734927, 1852171925, 3867060991, 3473416636, 3907448597,
          2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639,
          2486224549, 1723872674, 3157750862, 3399941250, 3501252752,
          3625268135, 2555048196, 3673637356, 1343127501, 4130281361,
          3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410,
          532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963,
          492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225,
          344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695,
          3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069,
          1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571,
          3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716,
          3835484340, 3247465558, 2220981195, 3060847922, 1551124588,
          1463996600,
        ],
        eh = [
          4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623,
          4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885,
          3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053,
          3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835,
          2405426947, 2459735317, 1836772287, 1381620373, 3196267988,
          1948373848, 3764988233, 3385345166, 3263785589, 2390325492,
          1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789,
          3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355,
          2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426,
          1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895,
          3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221,
          3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454,
          878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212,
          2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718,
          1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912,
          2566595609, 3186202582, 1078185097, 3651041127, 3896688048,
          2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296,
          0, 2156299017, 736970802, 292596766, 1517440620, 251657213,
          2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339,
          908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416,
          3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620,
          454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591,
          1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156,
          4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431,
          1669664834, 2535604243, 3323011204, 1243905413, 3141400786,
          4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727,
          3004591147, 1891211689, 2487810577, 3915653703, 4237083816,
          4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628,
          3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092,
          2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814,
          3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464,
          410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844,
          1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714,
          1865862730, 2668221674, 2960971305, 2763173681, 1059270954,
          2777952454, 2724642869, 1320957812, 2194319100, 2429595872,
          2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550,
          4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417,
          1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011,
          3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729,
          322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828,
          4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015,
          1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990,
          3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240,
          1455525988, 3414450555, 850817237, 1817998408, 3092726480,
        ],
        ed = [
          0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554,
          708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108,
          1181045119, 1417561698, 1517767529, 3767586992, 4003061179,
          4236429990, 4069246893, 3635733660, 3602770327, 3299278474,
          3400528769, 2430122216, 2664543715, 2362090238, 2193862645,
          2835123396, 2801107407, 3035535058, 3135740889, 3678124923,
          3576870512, 3341394285, 3374361702, 3810496343, 3977675356,
          4279080257, 4043610186, 2876494627, 2776292904, 3076639029,
          3110650942, 2472011535, 2640243204, 2403728665, 2169303058,
          1001089995, 899835584, 666464733, 699432150, 59727847, 226906860,
          530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414,
          1942435775, 2110667444, 1876241833, 1641816226, 2910219766,
          2743034109, 2976151520, 3211623147, 2505202138, 2606453969,
          2302690252, 2269728455, 3711829422, 3543599269, 3240894392,
          3475313331, 3843699074, 3943906441, 4178062228, 4144047775,
          1306967366, 1139781709, 1374988112, 1610459739, 1975683434,
          2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896,
          800440835, 92987698, 193195065, 429456164, 395441711, 1984812685,
          2017778566, 1784663195, 1683407248, 1315562145, 1080094634,
          1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864,
          1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334,
          2328828971, 2227573024, 2935566865, 2700099354, 3001755655,
          3168937228, 3868552805, 3902563182, 4203181171, 4102977912,
          3736164937, 3501741890, 3265478751, 3433712980, 1106041591,
          1340463100, 1576976609, 1408749034, 2043211483, 2009195472,
          1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354,
          159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380,
          3178106961, 3009879386, 2572697195, 2538681184, 2236228733,
          2336434550, 3509871135, 3745345300, 3441850377, 3274667266,
          3910161971, 3877198648, 4110568485, 4211818798, 2597806476,
          2497604743, 2261089178, 2295101073, 2733856160, 2902087851,
          3202437046, 2968011453, 3936291284, 3835036895, 4136440770,
          4169408201, 3535486456, 3702665459, 3467192302, 3231722213,
          2051518780, 1951317047, 1716890410, 1750902305, 1113818384,
          1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330,
          404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369,
          3801332234, 4035489047, 4269907996, 3569255213, 3669462566,
          3366754619, 3332740144, 2631065433, 2463879762, 2160117071,
          2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497,
          33778362, 270040487, 504459436, 875451293, 975658646, 675039627,
          641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661,
          1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972,
          632953703, 260388950, 25965917, 328671808, 496906059, 1206477858,
          1239443753, 1543208500, 1441952575, 2144161806, 1908694277,
          1675577880, 1842759443, 3610369226, 3644379585, 3408119516,
          3307916247, 4011190502, 3776767469, 4077384432, 4245618683,
          2809771154, 2842737049, 3144396420, 3043140495, 2673705150,
          2438237621, 2203032232, 2370213795,
        ],
        ep = [
          0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694,
          824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388,
          2135319889, 1649704518, 1767536459, 2967507152, 3152976349,
          2801566410, 2918353863, 2631447780, 2547432937, 2328143614,
          2177544179, 3901806776, 3818836405, 4270639778, 4118987695,
          3299409036, 3483825537, 3535072918, 3652904859, 2077965243,
          1893020342, 1841768865, 1724457132, 1474502543, 1559041666,
          1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372,
          261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454,
          3710368113, 3593056380, 3875770207, 3960309330, 4045380933,
          4195456072, 2471224067, 2554718734, 2237133081, 2388260884,
          3212035895, 3028143674, 2842678573, 2724322336, 4138563181,
          4255350624, 3769721975, 3955191162, 3667219033, 3516619604,
          3431546947, 3347532110, 2933734917, 2782082824, 3099667487,
          3016697106, 2196052529, 2313884476, 2499348523, 2683765030,
          1179510461, 1296297904, 1347548327, 1533017514, 1786102409,
          1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751,
          53458370, 839224033, 957055980, 605657339, 790073846, 2373340630,
          2256028891, 2607439820, 2422494913, 2706270690, 2856345839,
          3075636216, 3160175349, 3573941694, 3725069491, 3273267108,
          3356761769, 4181598602, 4063242375, 4011996048, 3828103837,
          1033297158, 915985419, 730517276, 545572369, 296679730, 446754879,
          129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177,
          1239331162, 1120974935, 1606591296, 1422699085, 4148292826,
          4233094615, 3781033664, 3931371469, 3682191598, 3497509347,
          3446004468, 3328955385, 2939266226, 2755636671, 3106780840,
          2988687269, 2198438022, 2282195339, 2501218972, 2652609425,
          1201765386, 1286567175, 1371368976, 1521706781, 1805211710,
          1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672,
          46346101, 870912086, 954669403, 636813900, 788204353, 2358957921,
          2274680428, 2592523643, 2441661558, 2695033685, 2880240216,
          3065962831, 3182487618, 3572145929, 3756299780, 3270937875,
          3388507166, 4174560061, 4091327024, 4006521127, 3854606378,
          1014646705, 930369212, 711349675, 560487590, 272786309, 457992840,
          106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326,
          1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114,
          401639597, 486441376, 768917123, 651868046, 1003007129, 818324884,
          1503449823, 1385356242, 1333838021, 1150208456, 1973745387,
          2125135846, 1673061617, 1756818940, 2970356327, 3120694122,
          2802849917, 2887651696, 2637442643, 2520393566, 2334669897,
          2149987652, 3917234703, 3799141122, 4284502037, 4100872472,
          3309594171, 3460984630, 3545789473, 3629546796, 2050466060,
          1899603969, 1814803222, 1730525723, 1443857720, 1560382517,
          1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235,
          243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545,
          3704300486, 3620022987, 3874428392, 3990953189, 4042459122,
          4227665663, 2460449204, 2578018489, 2226875310, 2411029155,
          3198115200, 3046200461, 2827177882, 2743944855,
        ],
        eg = [
          0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294,
          590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588,
          1367295589, 1180849278, 1265195639, 3501252752, 3720081049,
          3399941250, 3350065803, 3835484340, 3919042237, 4270507174,
          4085369519, 3102249176, 3051593425, 2734591178, 2952102595,
          2361698556, 2177869557, 2530391278, 2614737639, 3145456443,
          3060847922, 2708326185, 2892417312, 2404901663, 2187128086,
          2504130317, 2555048196, 3542330227, 3727205754, 3375740769,
          3292445032, 3876557655, 3926170974, 4246310725, 4027744588,
          1808481195, 1723872674, 1910319033, 2094410160, 1608975247,
          1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201,
          344873464, 935293895, 984907214, 766078933, 547512796, 1844882806,
          1627235199, 2011214180, 2062270317, 1507497298, 1423022939,
          1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861,
          830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679,
          2807058932, 2858115069, 2305455554, 2220981195, 2474404304,
          2658625497, 3575528878, 3625268135, 3473416636, 3254988725,
          3778151818, 3963161475, 4213447064, 4130281361, 3599595085,
          3683022916, 3432737375, 3247465558, 3802222185, 4020912224,
          4172763771, 4122762354, 3201631749, 3017672716, 2764249623,
          2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613,
          188127444, 472615631, 287343814, 840019705, 1058709744, 671593195,
          621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577,
          1463996600, 1080017571, 1297403050, 3673637356, 3623636965,
          3235995134, 3454686199, 4007360968, 3822090177, 4107101658,
          4190530515, 2997825956, 3215212461, 2830708150, 2779915199,
          2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165,
          273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755,
          1646252340, 1863638845, 2013908262, 1963115311, 1446242576,
          1530455833, 1277555970, 1093597963, 1636604631, 1820824798,
          2073724613, 1989249228, 1436590835, 1487645946, 1337376481,
          1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051,
          821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645,
          2787207260, 2232435299, 2283490410, 2667994737, 2450346104,
          3647212047, 3564045318, 3279033885, 3464042516, 3980931627,
          3762502690, 4150144569, 4199882800, 3070356634, 3121275539,
          2904027272, 2686254721, 2200818878, 2384911031, 2570832044,
          2486224549, 3747192018, 3528626907, 3310321856, 3359936201,
          3950355702, 3867060991, 4049844452, 4234721005, 1739656202,
          1790575107, 2108100632, 1890328081, 1402811438, 1586903591,
          1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217,
          1002783846, 919489135, 567498868, 752375421, 209336225, 24197544,
          376187827, 459744698, 945164165, 895287692, 574624663, 793451934,
          1679968233, 1764313568, 2117360635, 1933530610, 1343127501,
          1560637892, 1243112415, 1192455638, 3704280881, 3519142200,
          3336358691, 3419915562, 3907448597, 3857572124, 4075877127,
          4294704398, 3029510009, 3113855344, 2927934315, 2744104290,
          2159976285, 2377486676, 2594734927, 2544078150,
        ],
        ey = [
          0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204,
          1059270954, 1214797936, 1097159550, 1517440620, 1400849762,
          1817998408, 1699839814, 2118541908, 2001430874, 2429595872,
          2581445614, 2194319100, 2345119218, 3034881240, 3186202582,
          2801699524, 2951971274, 3635996816, 3518358430, 3399679628,
          3283088770, 4237083816, 4118925222, 4002861748, 3885750714,
          1002142683, 850817237, 698445255, 548169417, 529487843, 377642221,
          227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577,
          1474760595, 1592394909, 1174215055, 1290801793, 2875968315,
          2724642869, 3111247143, 2960971305, 2405426947, 2253581325,
          2638606623, 2487810577, 3808662347, 3926825029, 4044981591,
          4162096729, 3342319475, 3459953789, 3576539503, 3693126241,
          1986918061, 2137062819, 1685577905, 1836772287, 1381620373,
          1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417,
          621982671, 439452389, 322734571, 137073913, 19308535, 3871163981,
          4021308739, 4104605777, 4255800159, 3263785589, 3414450555,
          3499326569, 3651041127, 2933202493, 2815956275, 3167684641,
          3049390895, 2330014213, 2213296395, 2566595609, 2448830231,
          1305906550, 1155237496, 1607244650, 1455525988, 1776460110,
          1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818,
          514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718,
          3557504664, 3474729866, 3323011204, 4180808110, 4030667424,
          3945269170, 3794078908, 2507040230, 2623762152, 2272556026,
          2390325492, 2975484382, 3092726480, 2738905026, 2857194700,
          3973773121, 3856137295, 4274053469, 4157467219, 3371096953,
          3252932727, 3673476453, 3556361835, 2763173681, 2915017791,
          3064510765, 3215307299, 2156299017, 2307622919, 2459735317,
          2610011675, 2081048481, 1963412655, 1846563261, 1729977011,
          1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015,
          645401037, 796197571, 274084841, 425408743, 38544885, 188821243,
          3613494426, 3731654548, 3313212038, 3430322568, 4082475170,
          4200115116, 3780097726, 3896688048, 2668221674, 2516901860,
          2366882550, 2216610296, 3141400786, 2989552604, 2837966542,
          2687165888, 1202797690, 1320957812, 1437280870, 1554391400,
          1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348,
          499347990, 349075736, 736970802, 585122620, 972512814, 821712160,
          2595684844, 2478443234, 2293045232, 2174754046, 3196267988,
          3079546586, 2895723464, 2777952454, 3537852828, 3687994002,
          3234156416, 3385345166, 4142626212, 4293295786, 3841024952,
          3992742070, 174567692, 57326082, 410887952, 292596766, 777231668,
          660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912,
          1494807662, 1715193156, 1865862730, 1948373848, 2100090966,
          2701949495, 2818666809, 3004591147, 3122358053, 2235061775,
          2352307457, 2535604243, 2653899549, 3915653703, 3764988233,
          4219352155, 4067639125, 3444575871, 3294430577, 3746175075,
          3594982253, 836553431, 953270745, 600235211, 718002117, 367585007,
          484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355,
          1654886325, 1568718495, 1418573201, 1335535747, 1184342925,
        ];
      function em(O) {
        let T = [];
        for (let L = 0; L < O.length; L += 4)
          T.push((O[L] << 24) | (O[L + 1] << 16) | (O[L + 2] << 8) | O[L + 3]);
        return T;
      }
      class eb {
        get key() {
          return Y(this, L, "f").slice();
        }
        constructor(O) {
          let T;
          if (
            (L.set(this, void 0),
            J.set(this, void 0),
            W.set(this, void 0),
            !(this instanceof eb))
          )
            throw Error("AES must be instanitated with `new`");
          Z(this, L, new Uint8Array(O), "f");
          let er = X[this.key.length];
          if (null == er)
            throw TypeError("invalid key size (must be 16, 24 or 32 bytes)");
          Z(this, W, [], "f"), Z(this, J, [], "f");
          for (let O = 0; O <= er; O++)
            Y(this, W, "f").push([0, 0, 0, 0]),
              Y(this, J, "f").push([0, 0, 0, 0]);
          let en = (er + 1) * 4,
            es = this.key.length / 4,
            ei = em(this.key);
          for (let O = 0; O < es; O++)
            (T = O >> 2),
              (Y(this, W, "f")[T][O % 4] = ei[O]),
              (Y(this, J, "f")[er - T][O % 4] = ei[O]);
          let ea = 0,
            eo = es,
            ec;
          for (; eo < en; ) {
            if (
              ((ec = ei[es - 1]),
              (ei[0] ^=
                (et[(ec >> 16) & 255] << 24) ^
                (et[(ec >> 8) & 255] << 16) ^
                (et[255 & ec] << 8) ^
                et[(ec >> 24) & 255] ^
                (ee[ea] << 24)),
              (ea += 1),
              8 != es)
            )
              for (let O = 1; O < es; O++) ei[O] ^= ei[O - 1];
            else {
              for (let O = 1; O < es / 2; O++) ei[O] ^= ei[O - 1];
              (ec = ei[es / 2 - 1]),
                (ei[es / 2] ^=
                  et[255 & ec] ^
                  (et[(ec >> 8) & 255] << 8) ^
                  (et[(ec >> 16) & 255] << 16) ^
                  (et[(ec >> 24) & 255] << 24));
              for (let O = es / 2 + 1; O < es; O++) ei[O] ^= ei[O - 1];
            }
            let O = 0,
              T,
              L;
            for (; O < es && eo < en; )
              (T = eo >> 2),
                (L = eo % 4),
                (Y(this, W, "f")[T][L] = ei[O]),
                (Y(this, J, "f")[er - T][L] = ei[O++]),
                eo++;
          }
          for (let O = 1; O < er; O++)
            for (let T = 0; T < 4; T++)
              (ec = Y(this, J, "f")[O][T]),
                (Y(this, J, "f")[O][T] =
                  ed[(ec >> 24) & 255] ^
                  ep[(ec >> 16) & 255] ^
                  eg[(ec >> 8) & 255] ^
                  ey[255 & ec]);
        }
        encrypt(O) {
          if (16 != O.length)
            throw TypeError("invalid plaintext size (must be 16 bytes)");
          let T = Y(this, W, "f").length - 1,
            L = [0, 0, 0, 0],
            J = em(O);
          for (let O = 0; O < 4; O++) J[O] ^= Y(this, W, "f")[0][O];
          for (let O = 1; O < T; O++) {
            for (let T = 0; T < 4; T++)
              L[T] =
                en[(J[T] >> 24) & 255] ^
                es[(J[(T + 1) % 4] >> 16) & 255] ^
                ei[(J[(T + 2) % 4] >> 8) & 255] ^
                ea[255 & J[(T + 3) % 4]] ^
                Y(this, W, "f")[O][T];
            J = L.slice();
          }
          let Z = new Uint8Array(16),
            X = 0;
          for (let O = 0; O < 4; O++)
            (X = Y(this, W, "f")[T][O]),
              (Z[4 * O] = (et[(J[O] >> 24) & 255] ^ (X >> 24)) & 255),
              (Z[4 * O + 1] =
                (et[(J[(O + 1) % 4] >> 16) & 255] ^ (X >> 16)) & 255),
              (Z[4 * O + 2] =
                (et[(J[(O + 2) % 4] >> 8) & 255] ^ (X >> 8)) & 255),
              (Z[4 * O + 3] = (et[255 & J[(O + 3) % 4]] ^ X) & 255);
          return Z;
        }
        decrypt(O) {
          if (16 != O.length)
            throw TypeError("invalid ciphertext size (must be 16 bytes)");
          let T = Y(this, J, "f").length - 1,
            L = [0, 0, 0, 0],
            W = em(O);
          for (let O = 0; O < 4; O++) W[O] ^= Y(this, J, "f")[0][O];
          for (let O = 1; O < T; O++) {
            for (let T = 0; T < 4; T++)
              L[T] =
                eo[(W[T] >> 24) & 255] ^
                ec[(W[(T + 3) % 4] >> 16) & 255] ^
                eu[(W[(T + 2) % 4] >> 8) & 255] ^
                eh[255 & W[(T + 1) % 4]] ^
                Y(this, J, "f")[O][T];
            W = L.slice();
          }
          let Z = new Uint8Array(16),
            X = 0;
          for (let O = 0; O < 4; O++)
            (X = Y(this, J, "f")[T][O]),
              (Z[4 * O] = (er[(W[O] >> 24) & 255] ^ (X >> 24)) & 255),
              (Z[4 * O + 1] =
                (er[(W[(O + 3) % 4] >> 16) & 255] ^ (X >> 16)) & 255),
              (Z[4 * O + 2] =
                (er[(W[(O + 2) % 4] >> 8) & 255] ^ (X >> 8)) & 255),
              (Z[4 * O + 3] = (er[255 & W[(O + 1) % 4]] ^ X) & 255);
          return Z;
        }
      }
      (T.AES = eb),
        (L = new WeakMap()),
        (J = new WeakMap()),
        (W = new WeakMap());
    },
    63107: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.pkcs7Strip =
          T.pkcs7Pad =
          T.OFB =
          T.ECB =
          T.CTR =
          T.CFB =
          T.CBC =
          T.ModeOfOperation =
          T.AES =
            void 0);
      var J = L(40543);
      Object.defineProperty(T, "AES", {
        enumerable: !0,
        get: function () {
          return J.AES;
        },
      });
      var W = L(96943);
      Object.defineProperty(T, "ModeOfOperation", {
        enumerable: !0,
        get: function () {
          return W.ModeOfOperation;
        },
      });
      var Y = L(59718);
      Object.defineProperty(T, "CBC", {
        enumerable: !0,
        get: function () {
          return Y.CBC;
        },
      });
      var Z = L(54963);
      Object.defineProperty(T, "CFB", {
        enumerable: !0,
        get: function () {
          return Z.CFB;
        },
      });
      var X = L(30272);
      Object.defineProperty(T, "CTR", {
        enumerable: !0,
        get: function () {
          return X.CTR;
        },
      });
      var ee = L(15891);
      Object.defineProperty(T, "ECB", {
        enumerable: !0,
        get: function () {
          return ee.ECB;
        },
      });
      var et = L(89581);
      Object.defineProperty(T, "OFB", {
        enumerable: !0,
        get: function () {
          return et.OFB;
        },
      });
      var er = L(86426);
      Object.defineProperty(T, "pkcs7Pad", {
        enumerable: !0,
        get: function () {
          return er.pkcs7Pad;
        },
      }),
        Object.defineProperty(T, "pkcs7Strip", {
          enumerable: !0,
          get: function () {
            return er.pkcs7Strip;
          },
        });
    },
    59718: function (O, T, L) {
      // "use strict";
      var J,
        W,
        Y =
          (this && this.__classPrivateFieldSet) ||
          function (O, T, L, J, W) {
            if ("m" === J) throw TypeError("Private method is not writable");
            if ("a" === J && !W)
              throw TypeError("Private accessor was defined without a setter");
            if ("function" == typeof T ? O !== T || !W : !T.has(O))
              throw TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              "a" === J ? W.call(O, L) : W ? (W.value = L) : T.set(O, L), L
            );
          },
        Z =
          (this && this.__classPrivateFieldGet) ||
          function (O, T, L, J) {
            if ("a" === L && !J)
              throw TypeError("Private accessor was defined without a getter");
            if ("function" == typeof T ? O !== T || !J : !T.has(O))
              throw TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return "m" === L
              ? J
              : "a" === L
              ? J.call(O)
              : J
              ? J.value
              : T.get(O);
          };
      Object.defineProperty(T, "__esModule", { value: !0 }), (T.CBC = void 0);
      let X = L(96943);
      class ee extends X.ModeOfOperation {
        constructor(O, T) {
          if (
            (super("ECC", O, ee), J.set(this, void 0), W.set(this, void 0), T)
          ) {
            if (T.length % 16)
              throw TypeError("invalid iv size (must be 16 bytes)");
            Y(this, J, new Uint8Array(T), "f");
          } else Y(this, J, new Uint8Array(16), "f");
          Y(this, W, this.iv, "f");
        }
        get iv() {
          return new Uint8Array(Z(this, J, "f"));
        }
        encrypt(O) {
          if (O.length % 16)
            throw TypeError(
              "invalid plaintext size (must be multiple of 16 bytes)"
            );
          let T = new Uint8Array(O.length);
          for (let L = 0; L < O.length; L += 16) {
            for (let T = 0; T < 16; T++) Z(this, W, "f")[T] ^= O[L + T];
            Y(this, W, this.aes.encrypt(Z(this, W, "f")), "f"),
              T.set(Z(this, W, "f"), L);
          }
          return T;
        }
        decrypt(O) {
          if (O.length % 16)
            throw TypeError(
              "invalid ciphertext size (must be multiple of 16 bytes)"
            );
          let T = new Uint8Array(O.length);
          for (let L = 0; L < O.length; L += 16) {
            let J = this.aes.decrypt(O.subarray(L, L + 16));
            for (let Y = 0; Y < 16; Y++)
              (T[L + Y] = J[Y] ^ Z(this, W, "f")[Y]),
                (Z(this, W, "f")[Y] = O[L + Y]);
          }
          return T;
        }
      }
      (T.CBC = ee), (J = new WeakMap()), (W = new WeakMap());
    },
    54963: function (O, T, L) {
      // "use strict";
      var J,
        W,
        Y,
        Z,
        X =
          (this && this.__classPrivateFieldSet) ||
          function (O, T, L, J, W) {
            if ("m" === J) throw TypeError("Private method is not writable");
            if ("a" === J && !W)
              throw TypeError("Private accessor was defined without a setter");
            if ("function" == typeof T ? O !== T || !W : !T.has(O))
              throw TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              "a" === J ? W.call(O, L) : W ? (W.value = L) : T.set(O, L), L
            );
          },
        ee =
          (this && this.__classPrivateFieldGet) ||
          function (O, T, L, J) {
            if ("a" === L && !J)
              throw TypeError("Private accessor was defined without a getter");
            if ("function" == typeof T ? O !== T || !J : !T.has(O))
              throw TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return "m" === L
              ? J
              : "a" === L
              ? J.call(O)
              : J
              ? J.value
              : T.get(O);
          };
      Object.defineProperty(T, "__esModule", { value: !0 }), (T.CFB = void 0);
      let et = L(96943);
      class er extends et.ModeOfOperation {
        constructor(O, T, L = 8) {
          if (
            (super("CFB", O, er),
            J.add(this),
            W.set(this, void 0),
            Y.set(this, void 0),
            !Number.isInteger(L) || L % 8)
          )
            throw TypeError("invalid segmentSize");
          if (
            (Object.defineProperties(this, {
              segmentSize: { enumerable: !0, value: L },
            }),
            T)
          ) {
            if (T.length % 16)
              throw TypeError("invalid iv size (must be 16 bytes)");
            X(this, W, new Uint8Array(T), "f");
          } else X(this, W, new Uint8Array(16), "f");
          X(this, Y, this.iv, "f");
        }
        get iv() {
          return new Uint8Array(ee(this, W, "f"));
        }
        encrypt(O) {
          if ((8 * O.length) % this.segmentSize)
            throw TypeError(
              "invalid plaintext size (must be multiple of segmentSize bytes)"
            );
          let T = this.segmentSize / 8,
            L = new Uint8Array(O);
          for (let O = 0; O < L.length; O += T) {
            let W = this.aes.encrypt(ee(this, Y, "f"));
            for (let J = 0; J < T; J++) L[O + J] ^= W[J];
            ee(this, J, "m", Z).call(this, L.subarray(O));
          }
          return L;
        }
        decrypt(O) {
          if ((8 * O.length) % this.segmentSize)
            throw TypeError(
              "invalid ciphertext size (must be multiple of segmentSize bytes)"
            );
          let T = this.segmentSize / 8,
            L = new Uint8Array(O);
          for (let W = 0; W < L.length; W += T) {
            let X = this.aes.encrypt(ee(this, Y, "f"));
            for (let O = 0; O < T; O++) L[W + O] ^= X[O];
            ee(this, J, "m", Z).call(this, O.subarray(W));
          }
          return L;
        }
      }
      (T.CFB = er),
        (W = new WeakMap()),
        (Y = new WeakMap()),
        (J = new WeakSet()),
        (Z = function (O) {
          let T = this.segmentSize / 8;
          ee(this, Y, "f").set(ee(this, Y, "f").subarray(T)),
            ee(this, Y, "f").set(O.subarray(0, T), 16 - T);
        });
    },
    30272: function (O, T, L) {
      // "use strict";
      var J,
        W,
        Y,
        Z =
          (this && this.__classPrivateFieldSet) ||
          function (O, T, L, J, W) {
            if ("m" === J) throw TypeError("Private method is not writable");
            if ("a" === J && !W)
              throw TypeError("Private accessor was defined without a setter");
            if ("function" == typeof T ? O !== T || !W : !T.has(O))
              throw TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              "a" === J ? W.call(O, L) : W ? (W.value = L) : T.set(O, L), L
            );
          },
        X =
          (this && this.__classPrivateFieldGet) ||
          function (O, T, L, J) {
            if ("a" === L && !J)
              throw TypeError("Private accessor was defined without a getter");
            if ("function" == typeof T ? O !== T || !J : !T.has(O))
              throw TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return "m" === L
              ? J
              : "a" === L
              ? J.call(O)
              : J
              ? J.value
              : T.get(O);
          };
      Object.defineProperty(T, "__esModule", { value: !0 }), (T.CTR = void 0);
      let ee = L(96943);
      class et extends ee.ModeOfOperation {
        constructor(O, T) {
          super("CTR", O, et),
            J.set(this, void 0),
            W.set(this, void 0),
            Y.set(this, void 0),
            Z(this, Y, new Uint8Array(16), "f"),
            X(this, Y, "f").fill(0),
            Z(this, J, X(this, Y, "f"), "f"),
            Z(this, W, 16, "f"),
            null == T && (T = 1),
            "number" == typeof T
              ? this.setCounterValue(T)
              : this.setCounterBytes(T);
        }
        get counter() {
          return new Uint8Array(X(this, Y, "f"));
        }
        setCounterValue(O) {
          if (!Number.isInteger(O) || O < 0 || O > Number.MAX_SAFE_INTEGER)
            throw TypeError("invalid counter initial integer value");
          for (let T = 15; T >= 0; --T)
            (X(this, Y, "f")[T] = O % 256), (O = Math.floor(O / 256));
        }
        setCounterBytes(O) {
          if (16 !== O.length)
            throw TypeError("invalid counter initial Uint8Array value length");
          X(this, Y, "f").set(O);
        }
        increment() {
          for (let O = 15; O >= 0; O--)
            if (255 === X(this, Y, "f")[O]) X(this, Y, "f")[O] = 0;
            else {
              X(this, Y, "f")[O]++;
              break;
            }
        }
        encrypt(O) {
          var T, L;
          let ee = new Uint8Array(O);
          for (let O = 0; O < ee.length; O++)
            16 === X(this, W, "f") &&
              (Z(this, J, this.aes.encrypt(X(this, Y, "f")), "f"),
              Z(this, W, 0, "f"),
              this.increment()),
              (ee[O] ^= X(this, J, "f")[
                (Z(this, W, ((L = X(this, W, "f")), (T = L++), L), "f"), T)
              ]);
          return ee;
        }
        decrypt(O) {
          return this.encrypt(O);
        }
      }
      (T.CTR = et),
        (J = new WeakMap()),
        (W = new WeakMap()),
        (Y = new WeakMap());
    },
    15891: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }), (T.ECB = void 0);
      let J = L(96943);
      class W extends J.ModeOfOperation {
        constructor(O) {
          super("ECB", O, W);
        }
        encrypt(O) {
          if (O.length % 16)
            throw TypeError(
              "invalid plaintext size (must be multiple of 16 bytes)"
            );
          let T = new Uint8Array(O.length);
          for (let L = 0; L < O.length; L += 16)
            T.set(this.aes.encrypt(O.subarray(L, L + 16)), L);
          return T;
        }
        decrypt(O) {
          if (O.length % 16)
            throw TypeError(
              "invalid ciphertext size (must be multiple of 16 bytes)"
            );
          let T = new Uint8Array(O.length);
          for (let L = 0; L < O.length; L += 16)
            T.set(this.aes.decrypt(O.subarray(L, L + 16)), L);
          return T;
        }
      }
      T.ECB = W;
    },
    89581: function (O, T, L) {
      // "use strict";
      var J,
        W,
        Y,
        Z =
          (this && this.__classPrivateFieldSet) ||
          function (O, T, L, J, W) {
            if ("m" === J) throw TypeError("Private method is not writable");
            if ("a" === J && !W)
              throw TypeError("Private accessor was defined without a setter");
            if ("function" == typeof T ? O !== T || !W : !T.has(O))
              throw TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              "a" === J ? W.call(O, L) : W ? (W.value = L) : T.set(O, L), L
            );
          },
        X =
          (this && this.__classPrivateFieldGet) ||
          function (O, T, L, J) {
            if ("a" === L && !J)
              throw TypeError("Private accessor was defined without a getter");
            if ("function" == typeof T ? O !== T || !J : !T.has(O))
              throw TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return "m" === L
              ? J
              : "a" === L
              ? J.call(O)
              : J
              ? J.value
              : T.get(O);
          };
      Object.defineProperty(T, "__esModule", { value: !0 }), (T.OFB = void 0);
      let ee = L(96943);
      class et extends ee.ModeOfOperation {
        constructor(O, T) {
          if (
            (super("OFB", O, et),
            J.set(this, void 0),
            W.set(this, void 0),
            Y.set(this, void 0),
            T)
          ) {
            if (T.length % 16)
              throw TypeError("invalid iv size (must be 16 bytes)");
            Z(this, J, new Uint8Array(T), "f");
          } else Z(this, J, new Uint8Array(16), "f");
          Z(this, W, this.iv, "f"), Z(this, Y, 16, "f");
        }
        get iv() {
          return new Uint8Array(X(this, J, "f"));
        }
        encrypt(O) {
          var T, L;
          if (O.length % 16)
            throw TypeError(
              "invalid plaintext size (must be multiple of 16 bytes)"
            );
          let J = new Uint8Array(O);
          for (let O = 0; O < J.length; O++)
            16 === X(this, Y, "f") &&
              (Z(this, W, this.aes.encrypt(X(this, W, "f")), "f"),
              Z(this, Y, 0, "f")),
              (J[O] ^= X(this, W, "f")[
                (Z(this, Y, ((L = X(this, Y, "f")), (T = L++), L), "f"), T)
              ]);
          return J;
        }
        decrypt(O) {
          if (O.length % 16)
            throw TypeError(
              "invalid ciphertext size (must be multiple of 16 bytes)"
            );
          return this.encrypt(O);
        }
      }
      (T.OFB = et),
        (J = new WeakMap()),
        (W = new WeakMap()),
        (Y = new WeakMap());
    },
    96943: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ModeOfOperation = void 0);
      let J = L(40543);
      class W {
        constructor(O, T, L) {
          if (L && !(this instanceof L))
            throw Error(`${O} must be instantiated with "new"`);
          Object.defineProperties(this, {
            aes: { enumerable: !0, value: new J.AES(T) },
            name: { enumerable: !0, value: O },
          });
        }
      }
      T.ModeOfOperation = W;
    },
    86426: function (O, T) {
      // "use strict";
      function L(O) {
        let T = 16 - (O.length % 16),
          L = new Uint8Array(O.length + T);
        L.set(O);
        for (let J = O.length; J < L.length; J++) L[J] = T;
        return L;
      }
      function J(O) {
        if (O.length < 16) throw TypeError("PKCS#7 invalid length");
        let T = O[O.length - 1];
        if (T > 16) throw TypeError("PKCS#7 padding byte out of range");
        let L = O.length - T;
        for (let J = 0; J < T; J++)
          if (O[L + J] !== T) throw TypeError("PKCS#7 invalid padding byte");
        return new Uint8Array(O.subarray(0, L));
      }
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.pkcs7Strip = T.pkcs7Pad = void 0),
        (T.pkcs7Pad = L),
        (T.pkcs7Strip = J);
    },
    73661: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.version = void 0),
        (T.version = "6.11.1");
    },
    79934: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.AbiCoder = void 0);
      let J = L(38478),
        W = L(31458),
        Y = L(97398),
        Z = L(19702),
        X = L(8995),
        ee = L(45719),
        et = L(62905),
        er = L(91415),
        en = L(7883),
        es = L(4911),
        ei = L(75319),
        ea = L(4411),
        eo = L(40431),
        ec = L(38478),
        eu = new Map();
      eu.set(0, "GENERIC_PANIC"),
        eu.set(1, "ASSERT_FALSE"),
        eu.set(17, "OVERFLOW"),
        eu.set(18, "DIVIDE_BY_ZERO"),
        eu.set(33, "ENUM_RANGE_ERROR"),
        eu.set(34, "BAD_STORAGE_DATA"),
        eu.set(49, "STACK_UNDERFLOW"),
        eu.set(50, "ARRAY_RANGE_ERROR"),
        eu.set(65, "OUT_OF_MEMORY"),
        eu.set(81, "UNINITIALIZED_FUNCTION_CALL");
      let eh = new RegExp(/^bytes([0-9]*)$/),
        ed = new RegExp(/^(u?int)([0-9]*)$/),
        ep = null,
        eg = 1024;
      function ey(O, T, L, J) {
        let W = "missing revert data",
          Y = null,
          Z = null,
          X = null;
        if (L) {
          W = "execution reverted";
          let O = (0, ec.getBytes)(L);
          if (((L = (0, ec.hexlify)(L)), 0 === O.length))
            (W += " (no data present; likely require(false) occurred"),
              (Y = "require(false)");
          else if (O.length % 32 != 4)
            W += " (could not decode reason; invalid data length)";
          else if ("0x08c379a0" === (0, ec.hexlify)(O.slice(0, 4)))
            try {
              (Y = J.decode(["string"], O.slice(4))[0]),
                (X = { signature: "Error(string)", name: "Error", args: [Y] }),
                (W += `: ${JSON.stringify(Y)}`);
            } catch (O) {
              W += " (could not decode reason; invalid string data)";
            }
          else if ("0x4e487b71" === (0, ec.hexlify)(O.slice(0, 4)))
            try {
              let T = Number(J.decode(["uint256"], O.slice(4))[0]);
              (X = { signature: "Panic(uint256)", name: "Panic", args: [T] }),
                (Y = `Panic due to ${eu.get(T) || "UNKNOWN"}(${T})`),
                (W += `: ${Y}`);
            } catch (O) {
              W += " (could not decode panic code)";
            }
          else W += " (unknown custom error)";
        }
        let ee = {
          to: T.to ? (0, eo.getAddress)(T.to) : null,
          data: T.data || "0x",
        };
        return (
          T.from && (ee.from = (0, eo.getAddress)(T.from)),
          (0, ec.makeError)(W, "CALL_EXCEPTION", {
            action: O,
            data: L,
            reason: Y,
            transaction: ee,
            invocation: Z,
            revert: X,
          })
        );
      }
      class em {
        e__0(O) {
          if (O.isArray())
            return new Z.ArrayCoder(
              this.e__0(O.arrayChildren),
              O.arrayLength,
              O.name
            );
          if (O.isTuple())
            return new ei.TupleCoder(
              O.components.map((O) => this.e__0(O)),
              O.name
            );
          switch (O.baseType) {
            case "address":
              return new Y.AddressCoder(O.name);
            case "bool":
              return new X.BooleanCoder(O.name);
            case "string":
              return new es.StringCoder(O.name);
            case "bytes":
              return new ee.BytesCoder(O.name);
            case "":
              return new er.NullCoder(O.name);
          }
          let T = O.type.match(ed);
          if (T) {
            let L = parseInt(T[2] || "256");
            return (
              (0, J.assertArgument)(
                0 !== L && L <= 256 && L % 8 == 0,
                "invalid " + T[1] + " bit length",
                "param",
                O
              ),
              new en.NumberCoder(L / 8, "int" === T[1], O.name)
            );
          }
          if ((T = O.type.match(eh))) {
            let L = parseInt(T[1]);
            return (
              (0, J.assertArgument)(
                0 !== L && L <= 32,
                "invalid bytes length",
                "param",
                O
              ),
              new et.FixedBytesCoder(L, O.name)
            );
          }
          (0, J.assertArgument)(!1, "invalid type", "type", O.type);
        }
        getDefaultValue(O) {
          let T = O.map((O) => this.e__0(ea.ParamType.from(O)));
          return new ei.TupleCoder(T, "_").defaultValue();
        }
        encode(O, T) {
          (0, J.assertArgumentCount)(
            T.length,
            O.length,
            "types/values length mismatch"
          );
          let L = O.map((O) => this.e__0(ea.ParamType.from(O))),
            Y = new ei.TupleCoder(L, "_"),
            Z = new W.Writer();
          return Y.encode(Z, T), Z.data;
        }
        decode(O, T, L) {
          let J = O.map((O) => this.e__0(ea.ParamType.from(O)));
          return new ei.TupleCoder(J, "_").decode(new W.Reader(T, L, eg));
        }
        static _setDefaultMaxInflation(O) {
          (0, J.assertArgument)(
            "number" == typeof O && Number.isInteger(O),
            "invalid defaultMaxInflation factor",
            "value",
            O
          ),
            (eg = O);
        }
        static defaultAbiCoder() {
          return null == ep && (ep = new em()), ep;
        }
        static getBuiltinCallException(O, T, L) {
          return ey(O, T, L, em.defaultAbiCoder());
        }
      }
      T.AbiCoder = em;
    },
    30657: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.decodeBytes32String = T.encodeBytes32String = void 0);
      let J = L(38478);
      function W(O) {
        let T = (0, J.toUtf8Bytes)(O);
        if (T.length > 31)
          throw Error("bytes32 string must be less than 32 bytes");
        return (0, J.zeroPadBytes)(T, 32);
      }
      function Y(O) {
        let T = (0, J.getBytes)(O, "bytes");
        if (32 !== T.length) throw Error("invalid bytes32 - not 32 bytes long");
        if (0 !== T[31])
          throw Error("invalid bytes32 string - no null terminator");
        let L = 31;
        for (; 0 === T[L - 1]; ) L--;
        return (0, J.toUtf8String)(T.slice(0, L));
      }
      (T.encodeBytes32String = W), (T.decodeBytes32String = Y);
    },
    31458: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Reader =
          T.Writer =
          T.Coder =
          T.checkResultErrors =
          T.Result =
          T.WordSize =
            void 0);
      let J = L(38478);
      T.WordSize = 32;
      let W = new Uint8Array(T.WordSize),
        Y = ["then"],
        Z = {};
      function X(O, T) {
        let L = Error(
          `deferred error during ABI decoding triggered accessing ${O}`
        );
        throw ((L.error = T), L);
      }
      class ee extends Array {
        constructor(...O) {
          let T = O[0],
            L = O[1],
            W = (O[2] || []).slice(),
            ee = !0;
          T !== Z && ((L = O), (W = []), (ee = !1)),
            super(L.length),
            L.forEach((O, T) => {
              this[T] = O;
            });
          let et = W.reduce(
            (O, T) => (
              "string" == typeof T && O.set(T, (O.get(T) || 0) + 1), O
            ),
            new Map()
          );
          if (
            ((this.t__0 = Object.freeze(
              L.map((O, T) => {
                let L = W[T];
                return null != L && 1 === et.get(L) ? L : null;
              })
            )),
            !ee)
          )
            return;
          return (
            Object.freeze(this),
            new Proxy(this, {
              get: (O, T, L) => {
                if ("string" == typeof T) {
                  if (T.match(/^[0-9]+$/)) {
                    let L = (0, J.getNumber)(T, "%index");
                    if (L < 0 || L >= this.length)
                      throw RangeError("out of result range");
                    let W = O[L];
                    return W instanceof Error && X(`index ${L}`, W), W;
                  }
                  if (Y.indexOf(T) >= 0) return Reflect.get(O, T, L);
                  let W = O[T];
                  if (W instanceof Function)
                    return function (...T) {
                      return W.apply(this === L ? O : this, T);
                    };
                  if (!(T in O))
                    return O.getValue.apply(this === L ? O : this, [T]);
                }
                return Reflect.get(O, T, L);
              },
            })
          );
        }
        toArray() {
          let O = [];
          return (
            this.forEach((T, L) => {
              T instanceof Error && X(`index ${L}`, T), O.push(T);
            }),
            O
          );
        }
        toObject() {
          return this.t__0.reduce(
            (O, T, L) => (
              (0, J.assert)(
                null != T,
                "value at index ${ index } unnamed",
                "UNSUPPORTED_OPERATION",
                { operation: "toObject()" }
              ),
              T in O || (O[T] = this.getValue(T)),
              O
            ),
            {}
          );
        }
        slice(O, T) {
          null == O && (O = 0),
            O < 0 && (O += this.length) < 0 && (O = 0),
            null == T && (T = this.length),
            T < 0 && (T += this.length) < 0 && (T = 0),
            T > this.length && (T = this.length);
          let L = [],
            J = [];
          for (let W = O; W < T; W++) L.push(this[W]), J.push(this.t__0[W]);
          return new ee(Z, L, J);
        }
        filter(O, T) {
          let L = [],
            J = [];
          for (let W = 0; W < this.length; W++) {
            let Y = this[W];
            Y instanceof Error && X(`index ${W}`, Y),
              O.call(T, Y, W, this) && (L.push(Y), J.push(this.t__0[W]));
          }
          return new ee(Z, L, J);
        }
        map(O, T) {
          let L = [];
          for (let J = 0; J < this.length; J++) {
            let W = this[J];
            W instanceof Error && X(`index ${J}`, W),
              L.push(O.call(T, W, J, this));
          }
          return L;
        }
        getValue(O) {
          let T = this.t__0.indexOf(O);
          if (-1 === T) return;
          let L = this[T];
          return (
            L instanceof Error && X(`property ${JSON.stringify(O)}`, L.error), L
          );
        }
        static fromItems(O, T) {
          return new ee(Z, O, T);
        }
      }
      function et(O) {
        let T = [],
          L = function (O, J) {
            if (Array.isArray(J))
              for (let W in J) {
                let Y = O.slice();
                Y.push(W);
                try {
                  L(Y, J[W]);
                } catch (O) {
                  T.push({ path: Y, error: O });
                }
              }
          };
        return L([], O), T;
      }
      function er(O) {
        let L = (0, J.toBeArray)(O);
        return (
          (0, J.assert)(
            L.length <= T.WordSize,
            "value out-of-bounds",
            "BUFFER_OVERRUN",
            { buffer: L, length: T.WordSize, offset: L.length }
          ),
          L.length !== T.WordSize &&
            (L = (0, J.getBytesCopy)(
              (0, J.concat)([W.slice(L.length % T.WordSize), L])
            )),
          L
        );
      }
      (T.Result = ee), (T.checkResultErrors = et);
      class en {
        constructor(O, T, L, W) {
          (0, J.defineProperties)(
            this,
            { name: O, type: T, localName: L, dynamic: W },
            {
              name: "string",
              type: "string",
              localName: "string",
              dynamic: "boolean",
            }
          );
        }
        _throwError(O, T) {
          (0, J.assertArgument)(!1, O, this.localName, T);
        }
      }
      T.Coder = en;
      class es {
        constructor() {
          (this._r = []), (this.n__0 = 0);
        }
        get data() {
          return (0, J.concat)(this._r);
        }
        get length() {
          return this.n__0;
        }
        s__0(O) {
          return this._r.push(O), (this.n__0 += O.length), O.length;
        }
        appendWriter(O) {
          return this.s__0((0, J.getBytesCopy)(O.data));
        }
        writeBytes(O) {
          let L = (0, J.getBytesCopy)(O),
            Y = L.length % T.WordSize;
          return (
            Y && (L = (0, J.getBytesCopy)((0, J.concat)([L, W.slice(Y)]))),
            this.s__0(L)
          );
        }
        writeValue(O) {
          return this.s__0(er(O));
        }
        writeUpdatableValue() {
          let O = this._r.length;
          return (
            this._r.push(W),
            (this.n__0 += T.WordSize),
            (T) => {
              this._r[O] = er(T);
            }
          );
        }
      }
      T.Writer = es;
      class ei {
        constructor(O, T, L) {
          (0, J.defineProperties)(this, { allowLoose: !!T }),
            (this._r = (0, J.getBytesCopy)(O)),
            (this.a__0 = 0),
            (this.o__0 = null),
            (this.l__0 = null != L ? L : 1024),
            (this.i__0 = 0);
        }
        get data() {
          return (0, J.hexlify)(this._r);
        }
        get dataLength() {
          return this._r.length;
        }
        get consumed() {
          return this.i__0;
        }
        get bytes() {
          return new Uint8Array(this._r);
        }
        c__0(O) {
          if (this.o__0) return this.o__0.c__0(O);
          (this.a__0 += O),
            (0, J.assert)(
              this.l__0 < 1 || this.a__0 <= this.l__0 * this.dataLength,
              `compressed ABI data exceeds inflation ratio of ${
                this.l__0
              } ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`,
              "BUFFER_OVERRUN",
              {
                buffer: (0, J.getBytesCopy)(this._r),
                offset: this.i__0,
                length: O,
                info: { bytesRead: this.a__0, dataLength: this.dataLength },
              }
            );
        }
        u__0(O, L, W) {
          let Y = Math.ceil(L / T.WordSize) * T.WordSize;
          return (
            this.i__0 + Y > this._r.length &&
              (this.allowLoose && W && this.i__0 + L <= this._r.length
                ? (Y = L)
                : (0, J.assert)(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                    buffer: (0, J.getBytesCopy)(this._r),
                    length: this._r.length,
                    offset: this.i__0 + Y,
                  })),
            this._r.slice(this.i__0, this.i__0 + Y)
          );
        }
        subReader(O) {
          let T = new ei(this._r.slice(this.i__0 + O), this.allowLoose, this.l__0);
          return (T.o__0 = this), T;
        }
        readBytes(O, T) {
          let L = this.u__0(0, O, !!T);
          return this.c__0(O), (this.i__0 += L.length), L.slice(0, O);
        }
        readValue() {
          return (0, J.toBigInt)(this.readBytes(T.WordSize));
        }
        readIndex() {
          return (0, J.toNumber)(this.readBytes(T.WordSize));
        }
      }
      T.Reader = ei;
    },
    97398: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.AddressCoder = void 0);
      let J = L(40431),
        W = L(31112),
        Y = L(29970),
        Z = L(31458);
      class X extends Z.Coder {
        constructor(O) {
          super("address", "address", O, !1);
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000";
        }
        encode(O, T) {
          let L = Y.Typed.dereference(T, "string");
          try {
            L = (0, J.getAddress)(L);
          } catch (O) {
            return this._throwError(O.message, T);
          }
          return O.writeValue(L);
        }
        decode(O) {
          return (0, J.getAddress)((0, W.toBeHex)(O.readValue(), 20));
        }
      }
      T.AddressCoder = X;
    },
    20313: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.AnonymousCoder = void 0);
      let J = L(31458);
      class W extends J.Coder {
        constructor(O) {
          super(O.name, O.type, "_", O.dynamic), (this.coder = O);
        }
        defaultValue() {
          return this.coder.defaultValue();
        }
        encode(O, T) {
          return this.coder.encode(O, T);
        }
        decode(O) {
          return this.coder.decode(O);
        }
      }
      T.AnonymousCoder = W;
    },
    19702: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ArrayCoder = T.unpack = T.pack = void 0);
      let J = L(38478),
        W = L(29970),
        Y = L(31458),
        Z = L(20313);
      function X(O, T, L) {
        let W = [];
        if (Array.isArray(L)) W = L;
        else if (L && "object" == typeof L) {
          let O = {};
          W = T.map((T) => {
            let W = T.localName;
            return (
              (0, J.assert)(
                W,
                "cannot encode object for signature with missing names",
                "INVALID_ARGUMENT",
                { argument: "values", info: { coder: T }, value: L }
              ),
              (0, J.assert)(
                !O[W],
                "cannot encode object for signature with duplicate names",
                "INVALID_ARGUMENT",
                { argument: "values", info: { coder: T }, value: L }
              ),
              (O[W] = !0),
              L[W]
            );
          });
        } else (0, J.assertArgument)(!1, "invalid tuple value", "tuple", L);
        (0, J.assertArgument)(
          T.length === W.length,
          "types/value length mismatch",
          "tuple",
          L
        );
        let Z = new Y.Writer(),
          X = new Y.Writer(),
          ee = [];
        return (
          T.forEach((O, T) => {
            let L = W[T];
            if (O.dynamic) {
              let T = X.length;
              O.encode(X, L);
              let J = Z.writeUpdatableValue();
              ee.push((O) => {
                J(O + T);
              });
            } else O.encode(Z, L);
          }),
          ee.forEach((O) => {
            O(Z.length);
          }),
          O.appendWriter(Z) + O.appendWriter(X)
        );
      }
      function ee(O, T) {
        let L = [],
          W = [],
          Z = O.subReader(0);
        return (
          T.forEach((T) => {
            let Y = null;
            if (T.dynamic) {
              let L = O.readIndex(),
                W = Z.subReader(L);
              try {
                Y = T.decode(W);
              } catch (O) {
                if ((0, J.isError)(O, "BUFFER_OVERRUN")) throw O;
                ((Y = O).baseType = T.name),
                  (Y.name = T.localName),
                  (Y.type = T.type);
              }
            } else
              try {
                Y = T.decode(O);
              } catch (O) {
                if ((0, J.isError)(O, "BUFFER_OVERRUN")) throw O;
                ((Y = O).baseType = T.name),
                  (Y.name = T.localName),
                  (Y.type = T.type);
              }
            if (void 0 == Y) throw Error("investigate");
            L.push(Y), W.push(T.localName || null);
          }),
          Y.Result.fromItems(L, W)
        );
      }
      (T.pack = X), (T.unpack = ee);
      class et extends Y.Coder {
        constructor(O, T, L) {
          super(
            "array",
            O.type + "[" + (T >= 0 ? T : "") + "]",
            L,
            -1 === T || O.dynamic
          ),
            (0, J.defineProperties)(this, { coder: O, length: T });
        }
        defaultValue() {
          let O = this.coder.defaultValue(),
            T = [];
          for (let L = 0; L < this.length; L++) T.push(O);
          return T;
        }
        encode(O, T) {
          let L = W.Typed.dereference(T, "array");
          Array.isArray(L) || this._throwError("expected array value", L);
          let Y = this.length;
          -1 === Y && ((Y = L.length), O.writeValue(L.length)),
            (0, J.assertArgumentCount)(
              L.length,
              Y,
              "coder array" + (this.localName ? " " + this.localName : "")
            );
          let Z = [];
          for (let O = 0; O < L.length; O++) Z.push(this.coder);
          return X(O, Z, L);
        }
        decode(O) {
          let T = this.length;
          -1 === T &&
            ((T = O.readIndex()),
            (0, J.assert)(
              T * Y.WordSize <= O.dataLength,
              "insufficient data length",
              "BUFFER_OVERRUN",
              { buffer: O.bytes, offset: T * Y.WordSize, length: O.dataLength }
            ));
          let L = [];
          for (let O = 0; O < T; O++) L.push(new Z.AnonymousCoder(this.coder));
          return ee(O, L);
        }
      }
      T.ArrayCoder = et;
    },
    8995: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.BooleanCoder = void 0);
      let J = L(29970),
        W = L(31458);
      class Y extends W.Coder {
        constructor(O) {
          super("bool", "bool", O, !1);
        }
        defaultValue() {
          return !1;
        }
        encode(O, T) {
          let L = J.Typed.dereference(T, "bool");
          return O.writeValue(L ? 1 : 0);
        }
        decode(O) {
          return !!O.readValue();
        }
      }
      T.BooleanCoder = Y;
    },
    45719: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.BytesCoder = T.DynamicBytesCoder = void 0);
      let J = L(38478),
        W = L(31458);
      class Y extends W.Coder {
        constructor(O, T) {
          super(O, O, T, !0);
        }
        defaultValue() {
          return "0x";
        }
        encode(O, T) {
          return (
            (T = (0, J.getBytesCopy)(T)),
            O.writeValue(T.length) + O.writeBytes(T)
          );
        }
        decode(O) {
          return O.readBytes(O.readIndex(), !0);
        }
      }
      T.DynamicBytesCoder = Y;
      class Z extends Y {
        constructor(O) {
          super("bytes", O);
        }
        decode(O) {
          return (0, J.hexlify)(super.decode(O));
        }
      }
      T.BytesCoder = Z;
    },
    62905: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.FixedBytesCoder = void 0);
      let J = L(38478),
        W = L(29970),
        Y = L(31458);
      class Z extends Y.Coder {
        constructor(O, T) {
          let L = "bytes" + String(O);
          super(L, L, T, !1),
            (0, J.defineProperties)(this, { size: O }, { size: "number" });
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
            0,
            2 + 2 * this.size
          );
        }
        encode(O, T) {
          let L = (0, J.getBytesCopy)(W.Typed.dereference(T, this.type));
          return (
            L.length !== this.size &&
              this._throwError("incorrect data length", T),
            O.writeBytes(L)
          );
        }
        decode(O) {
          return (0, J.hexlify)(O.readBytes(this.size));
        }
      }
      T.FixedBytesCoder = Z;
    },
    91415: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.NullCoder = void 0);
      let J = L(31458),
        W = new Uint8Array([]);
      class Y extends J.Coder {
        constructor(O) {
          super("null", "", O, !1);
        }
        defaultValue() {
          return null;
        }
        encode(O, T) {
          return null != T && this._throwError("not null", T), O.writeBytes(W);
        }
        decode(O) {
          return O.readBytes(0), null;
        }
      }
      T.NullCoder = Y;
    },
    7883: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.NumberCoder = void 0);
      let J = L(38478),
        W = L(29970),
        Y = L(31458),
        Z = BigInt(0),
        X = BigInt(1),
        ee = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
      class et extends Y.Coder {
        constructor(O, T, L) {
          let W = (T ? "int" : "uint") + 8 * O;
          super(W, W, L, !1),
            (0, J.defineProperties)(
              this,
              { size: O, signed: T },
              { size: "number", signed: "boolean" }
            );
        }
        defaultValue() {
          return 0;
        }
        encode(O, T) {
          let L = (0, J.getBigInt)(W.Typed.dereference(T, this.type)),
            et = (0, J.mask)(ee, 8 * Y.WordSize);
          if (this.signed) {
            let O = (0, J.mask)(et, 8 * this.size - 1);
            (L > O || L < -(O + X)) &&
              this._throwError("value out-of-bounds", T),
              (L = (0, J.toTwos)(L, 8 * Y.WordSize));
          } else
            (L < Z || L > (0, J.mask)(et, 8 * this.size)) &&
              this._throwError("value out-of-bounds", T);
          return O.writeValue(L);
        }
        decode(O) {
          let T = (0, J.mask)(O.readValue(), 8 * this.size);
          return this.signed && (T = (0, J.fromTwos)(T, 8 * this.size)), T;
        }
      }
      T.NumberCoder = et;
    },
    4911: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.StringCoder = void 0);
      let J = L(42822),
        W = L(29970),
        Y = L(45719);
      class Z extends Y.DynamicBytesCoder {
        constructor(O) {
          super("string", O);
        }
        defaultValue() {
          return "";
        }
        encode(O, T) {
          return super.encode(
            O,
            (0, J.toUtf8Bytes)(W.Typed.dereference(T, "string"))
          );
        }
        decode(O) {
          return (0, J.toUtf8String)(super.decode(O));
        }
      }
      T.StringCoder = Z;
    },
    75319: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.TupleCoder = void 0);
      let J = L(43980),
        W = L(29970),
        Y = L(31458),
        Z = L(19702);
      class X extends Y.Coder {
        constructor(O, T) {
          let L = !1,
            W = [];
          O.forEach((O) => {
            O.dynamic && (L = !0), W.push(O.type);
          }),
            super("tuple", "tuple(" + W.join(",") + ")", T, L),
            (0, J.defineProperties)(this, { coders: Object.freeze(O.slice()) });
        }
        defaultValue() {
          let O = [];
          this.coders.forEach((T) => {
            O.push(T.defaultValue());
          });
          let T = this.coders.reduce((O, T) => {
            let L = T.localName;
            return L && (O[L] || (O[L] = 0), O[L]++), O;
          }, {});
          return (
            this.coders.forEach((L, J) => {
              let W = L.localName;
              W &&
                1 === T[W] &&
                ("length" === W && (W = "_length"),
                null == O[W] && (O[W] = O[J]));
            }),
            Object.freeze(O)
          );
        }
        encode(O, T) {
          let L = W.Typed.dereference(T, "tuple");
          return (0, Z.pack)(O, this.coders, L);
        }
        decode(O) {
          return (0, Z.unpack)(O, this.coders);
        }
      }
      T.TupleCoder = X;
    },
    4411: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.StructFragment =
          T.FunctionFragment =
          T.FallbackFragment =
          T.ConstructorFragment =
          T.EventFragment =
          T.ErrorFragment =
          T.NamedFragment =
          T.Fragment =
          T.ParamType =
            void 0);
      let J = L(38478),
        W = L(41648);
      function Y(O) {
        let T = new Set();
        return O.forEach((O) => T.add(O)), Object.freeze(T);
      }
      let Z = Y("external public payable override".split(" ")),
        X =
          "constant external internal payable private public pure view override",
        ee = Y(X.split(" ")),
        et = "constructor error event fallback function receive struct",
        er = Y(et.split(" ")),
        en = "calldata memory storage payable indexed",
        es = Y(en.split(" ")),
        ei = Y([et, en, "tuple returns", X].join(" ").split(" ")),
        ea = {
          "(": "OPEN_PAREN",
          ")": "CLOSE_PAREN",
          "[": "OPEN_BRACKET",
          "]": "CLOSE_BRACKET",
          ",": "COMMA",
          "@": "AT",
        },
        eo = RegExp("^(\\s*)"),
        ec = RegExp("^([0-9]+)"),
        eu = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
        eh = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
        ed = RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
      class ep {
        get offset() {
          return this.i__0;
        }
        get length() {
          return this.h__0.length - this.i__0;
        }
        constructor(O) {
          (this.i__0 = 0), (this.h__0 = O.slice());
        }
        clone() {
          return new ep(this.h__0);
        }
        reset() {
          this.i__0 = 0;
        }
        d__0(O = 0, T = 0) {
          return new ep(
            this.h__0
              .slice(O, T)
              .map((T) =>
                Object.freeze(
                  Object.assign({}, T, {
                    match: T.match - O,
                    linkBack: T.linkBack - O,
                    linkNext: T.linkNext - O,
                  })
                )
              )
          );
        }
        popKeyword(O) {
          let T = this.peek();
          if ("KEYWORD" !== T.type || !O.has(T.text))
            throw Error(`expected keyword ${T.text}`);
          return this.pop().text;
        }
        popType(O) {
          if (this.peek().type !== O) {
            let T = this.peek();
            throw Error(
              `expected ${O}; got ${T.type} ${JSON.stringify(T.text)}`
            );
          }
          return this.pop().text;
        }
        popParen() {
          let O = this.peek();
          if ("OPEN_PAREN" !== O.type) throw Error("bad start");
          let T = this.d__0(this.i__0 + 1, O.match + 1);
          return (this.i__0 = O.match + 1), T;
        }
        popParams() {
          let O = this.peek();
          if ("OPEN_PAREN" !== O.type) throw Error("bad start");
          let T = [];
          for (; this.i__0 < O.match - 1; ) {
            let O = this.peek().linkNext;
            T.push(this.d__0(this.i__0 + 1, O)), (this.i__0 = O);
          }
          return (this.i__0 = O.match + 1), T;
        }
        peek() {
          if (this.i__0 >= this.h__0.length) throw Error("out-of-bounds");
          return this.h__0[this.i__0];
        }
        peekKeyword(O) {
          let T = this.peekType("KEYWORD");
          return null != T && O.has(T) ? T : null;
        }
        peekType(O) {
          if (0 === this.length) return null;
          let T = this.peek();
          return T.type === O ? T.text : null;
        }
        pop() {
          let O = this.peek();
          return this.i__0++, O;
        }
        toString() {
          let O = [];
          for (let T = this.i__0; T < this.h__0.length; T++) {
            let L = this.h__0[T];
            O.push(`${L.type}:${L.text}`);
          }
          return `<TokenString ${O.join(" ")}>`;
        }
      }
      function eg(O) {
        let T = [],
          L = (T) => {
            let L = Z < O.length ? JSON.stringify(O[Z]) : "$EOI";
            throw Error(`invalid token ${L} at ${Z}: ${T}`);
          },
          W = [],
          Y = [],
          Z = 0;
        for (; Z < O.length; ) {
          let X = O.substring(Z),
            ee = X.match(eo);
          ee && ((Z += ee[1].length), (X = O.substring(Z)));
          let et = {
            depth: W.length,
            linkBack: -1,
            linkNext: -1,
            match: -1,
            type: "",
            text: "",
            offset: Z,
            value: -1,
          };
          T.push(et);
          let er = ea[X[0]] || "";
          if (er) {
            if (((et.type = er), (et.text = X[0]), Z++, "OPEN_PAREN" === er))
              W.push(T.length - 1), Y.push(T.length - 1);
            else if ("CLOSE_PAREN" == er)
              0 === W.length && L("no matching open bracket"),
                (et.match = W.pop()),
                (T[et.match].match = T.length - 1),
                et.depth--,
                (et.linkBack = Y.pop()),
                (T[et.linkBack].linkNext = T.length - 1);
            else if ("COMMA" === er)
              (et.linkBack = Y.pop()),
                (T[et.linkBack].linkNext = T.length - 1),
                Y.push(T.length - 1);
            else if ("OPEN_BRACKET" === er) et.type = "BRACKET";
            else if ("CLOSE_BRACKET" === er) {
              let O = T.pop().text;
              if (T.length > 0 && "NUMBER" === T[T.length - 1].type) {
                let L = T.pop().text;
                (O = L + O), (T[T.length - 1].value = (0, J.getNumber)(L));
              }
              if (0 === T.length || "BRACKET" !== T[T.length - 1].type)
                throw Error("missing opening bracket");
              T[T.length - 1].text += O;
            }
            continue;
          }
          if ((ee = X.match(eu))) {
            if (((et.text = ee[1]), (Z += et.text.length), ei.has(et.text))) {
              et.type = "KEYWORD";
              continue;
            }
            if (et.text.match(ed)) {
              et.type = "TYPE";
              continue;
            }
            et.type = "ID";
            continue;
          }
          if ((ee = X.match(ec))) {
            (et.text = ee[1]), (et.type = "NUMBER"), (Z += et.text.length);
            continue;
          }
          throw Error(
            `unexpected token ${JSON.stringify(X[0])} at position ${Z}`
          );
        }
        return new ep(T.map((O) => Object.freeze(O)));
      }
      function ey(O, T) {
        let L = [];
        for (let J in T.keys()) O.has(J) && L.push(J);
        if (L.length > 1) throw Error(`conflicting types: ${L.join(", ")}`);
      }
      function em(O, T) {
        if (T.peekKeyword(er)) {
          let L = T.pop().text;
          if (L !== O) throw Error(`expected ${O}, got ${L}`);
        }
        return T.popType("ID");
      }
      function eb(O, T) {
        let L = new Set();
        for (;;) {
          let J = O.peekType("KEYWORD");
          if (null == J || (T && !T.has(J))) break;
          if ((O.pop(), L.has(J)))
            throw Error(`duplicate keywords: ${JSON.stringify(J)}`);
          L.add(J);
        }
        return Object.freeze(L);
      }
      function eA(O) {
        let T = eb(O, ee);
        return (ey(T, Y("constant payable nonpayable".split(" "))),
        ey(T, Y("pure view payable nonpayable".split(" "))),
        T.has("view"))
          ? "view"
          : T.has("pure")
          ? "pure"
          : T.has("payable")
          ? "payable"
          : T.has("nonpayable")
          ? "nonpayable"
          : T.has("constant")
          ? "view"
          : "nonpayable";
      }
      function ew(O, T) {
        return O.popParams().map((O) => eU.from(O, T));
      }
      function ev(O) {
        if (O.peekType("AT")) {
          if ((O.pop(), O.peekType("NUMBER")))
            return (0, J.getBigInt)(O.pop().text);
          throw Error("invalid gas");
        }
        return null;
      }
      function ek(O) {
        if (O.length)
          throw Error(
            `unexpected tokens at offset ${O.offset}: ${O.toString()}`
          );
      }
      let eE = new RegExp(/^(.*)\[([0-9]*)\]$/);
      function eS(O) {
        let T = O.match(ed);
        if (((0, J.assertArgument)(T, "invalid type", "type", O), "uint" === O))
          return "uint256";
        if ("int" === O) return "int256";
        if (T[2]) {
          let L = parseInt(T[2]);
          (0, J.assertArgument)(
            0 !== L && L <= 32,
            "invalid bytes length",
            "type",
            O
          );
        } else if (T[3]) {
          let L = parseInt(T[3]);
          (0, J.assertArgument)(
            0 !== L && L <= 256 && L % 8 == 0,
            "invalid numeric width",
            "type",
            O
          );
        }
        return O;
      }
      let eP = {},
        eC = Symbol.for("_ethers_internal"),
        eB = "_ParamTypeInternal",
        eO = "_ErrorInternal",
        eT = "_EventInternal",
        eN = "_ConstructorInternal",
        eR = "_FallbackInternal",
        eI = "_FunctionInternal",
        eM = "_StructInternal";
      class eU {
        constructor(O, T, L, W, Y, Z, X, ee) {
          if (
            ((0, J.assertPrivate)(O, eP, "ParamType"),
            Object.defineProperty(this, eC, { value: eB }),
            Z && (Z = Object.freeze(Z.slice())),
            "array" === W)
          ) {
            if (null == X || null == ee) throw Error("");
          } else if (null != X || null != ee) throw Error("");
          if ("tuple" === W) {
            if (null == Z) throw Error("");
          } else if (null != Z) throw Error("");
          (0, J.defineProperties)(this, {
            name: T,
            type: L,
            baseType: W,
            indexed: Y,
            components: Z,
            arrayLength: X,
            arrayChildren: ee,
          });
        }
        format(O) {
          if ((null == O && (O = "sighash"), "json" === O)) {
            let T = this.name || "";
            if (this.isArray()) {
              let O = JSON.parse(this.arrayChildren.format("json"));
              return (
                (O.name = T),
                (O.type += `[${
                  this.arrayLength < 0 ? "" : String(this.arrayLength)
                }]`),
                JSON.stringify(O)
              );
            }
            let L = {
              type: "tuple" === this.baseType ? "tuple" : this.type,
              name: T,
            };
            return (
              "boolean" == typeof this.indexed && (L.indexed = this.indexed),
              this.isTuple() &&
                (L.components = this.components.map((T) =>
                  JSON.parse(T.format(O))
                )),
              JSON.stringify(L)
            );
          }
          let T = "";
          return (
            this.isArray()
              ? (T +=
                  this.arrayChildren.format(O) +
                  `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`)
              : this.isTuple()
              ? (T +=
                  "(" +
                  this.components
                    .map((T) => T.format(O))
                    .join("full" === O ? ", " : ",") +
                  ")")
              : (T += this.type),
            "sighash" !== O &&
              (!0 === this.indexed && (T += " indexed"),
              "full" === O && this.name && (T += " " + this.name)),
            T
          );
        }
        isArray() {
          return "array" === this.baseType;
        }
        isTuple() {
          return "tuple" === this.baseType;
        }
        isIndexable() {
          return null != this.indexed;
        }
        walk(O, T) {
          if (this.isArray()) {
            if (!Array.isArray(O)) throw Error("invalid array value");
            if (-1 !== this.arrayLength && O.length !== this.arrayLength)
              throw Error("array is wrong length");
            let L = this;
            return O.map((O) => L.arrayChildren.walk(O, T));
          }
          if (this.isTuple()) {
            if (!Array.isArray(O)) throw Error("invalid tuple value");
            if (O.length !== this.components.length)
              throw Error("array is wrong length");
            let L = this;
            return O.map((O, J) => L.components[J].walk(O, T));
          }
          return T(this.type, O);
        }
        p__0(O, T, L, J) {
          if (this.isArray()) {
            if (!Array.isArray(T)) throw Error("invalid array value");
            if (-1 !== this.arrayLength && T.length !== this.arrayLength)
              throw Error("array is wrong length");
            let W = this.arrayChildren,
              Y = T.slice();
            Y.forEach((T, J) => {
              W.p__0(O, T, L, (O) => {
                Y[J] = O;
              });
            }),
              J(Y);
            return;
          }
          if (this.isTuple()) {
            let W;
            let Y = this.components;
            if (Array.isArray(T)) W = T.slice();
            else {
              if (null == T || "object" != typeof T)
                throw Error("invalid tuple value");
              W = Y.map((O) => {
                if (!O.name)
                  throw Error(
                    "cannot use object value with unnamed components"
                  );
                if (!(O.name in T))
                  throw Error(`missing value for component ${O.name}`);
                return T[O.name];
              });
            }
            if (W.length !== this.components.length)
              throw Error("array is wrong length");
            W.forEach((T, J) => {
              Y[J].p__0(O, T, L, (O) => {
                W[J] = O;
              });
            }),
              J(W);
            return;
          }
          let W = L(this.type, T);
          W.then
            ? O.push(
                (async function () {
                  J(await W);
                })()
              )
            : J(W);
        }
        async walkAsync(O, T) {
          let L = [],
            J = [O];
          return (
            this.p__0(L, O, T, (O) => {
              J[0] = O;
            }),
            L.length && (await Promise.all(L)),
            J[0]
          );
        }
        static from(O, T) {
          if (eU.isParamType(O)) return O;
          if ("string" == typeof O)
            try {
              return eU.from(eg(O), T);
            } catch (T) {
              (0, J.assertArgument)(!1, "invalid param type", "obj", O);
            }
          else if (O instanceof ep) {
            let L = "",
              J = "",
              W = null;
            eb(O, Y(["tuple"])).has("tuple") || O.peekType("OPEN_PAREN")
              ? ((J = "tuple"),
                (W = O.popParams().map((O) => eU.from(O))),
                (L = `tuple(${W.map((O) => O.format()).join(",")})`))
              : (J = L = eS(O.popType("TYPE")));
            let Z = null,
              X = null;
            for (; O.length && O.peekType("BRACKET"); ) {
              let T = O.pop();
              (Z = new eU(eP, "", L, J, null, W, X, Z)),
                (X = T.value),
                (L += T.text),
                (J = "array"),
                (W = null);
            }
            let ee = null;
            if (eb(O, es).has("indexed")) {
              if (!T) throw Error("");
              ee = !0;
            }
            let et = O.peekType("ID") ? O.pop().text : "";
            if (O.length) throw Error("leftover tokens");
            return new eU(eP, et, L, J, ee, W, X, Z);
          }
          let L = O.name;
          (0, J.assertArgument)(
            !L || ("string" == typeof L && L.match(eh)),
            "invalid name",
            "obj.name",
            L
          );
          let W = O.indexed;
          null != W &&
            ((0, J.assertArgument)(
              T,
              "parameter cannot be indexed",
              "obj.indexed",
              O.indexed
            ),
            (W = !!W));
          let Z = O.type,
            X = Z.match(eE);
          if (X) {
            let T = parseInt(X[2] || "-1"),
              J = eU.from({ type: X[1], components: O.components });
            return new eU(eP, L || "", Z, "array", W, null, T, J);
          }
          if ("tuple" === Z || Z.startsWith("tuple(") || Z.startsWith("(")) {
            let T =
              null != O.components ? O.components.map((O) => eU.from(O)) : null;
            return new eU(eP, L || "", Z, "tuple", W, T, null, null);
          }
          return new eU(eP, L || "", (Z = eS(O.type)), Z, W, null, null, null);
        }
        static isParamType(O) {
          return O && O[eC] === eB;
        }
      }
      T.ParamType = eU;
      class eL {
        constructor(O, T, L) {
          (0, J.assertPrivate)(O, eP, "Fragment"),
            (L = Object.freeze(L.slice())),
            (0, J.defineProperties)(this, { type: T, inputs: L });
        }
        static from(O) {
          if ("string" == typeof O) {
            try {
              eL.from(JSON.parse(O));
            } catch (O) {}
            return eL.from(eg(O));
          }
          if (O instanceof ep)
            switch (O.peekKeyword(er)) {
              case "constructor":
                return ej.from(O);
              case "error":
                return eF.from(O);
              case "event":
                return eK.from(O);
              case "fallback":
              case "receive":
                return eH.from(O);
              case "function":
                return e$.from(O);
              case "struct":
                return eV.from(O);
            }
          else if ("object" == typeof O) {
            switch (O.type) {
              case "constructor":
                return ej.from(O);
              case "error":
                return eF.from(O);
              case "event":
                return eK.from(O);
              case "fallback":
              case "receive":
                return eH.from(O);
              case "function":
                return e$.from(O);
              case "struct":
                return eV.from(O);
            }
            (0, J.assert)(
              !1,
              `unsupported type: ${O.type}`,
              "UNSUPPORTED_OPERATION",
              { operation: "Fragment.from" }
            );
          }
          (0, J.assertArgument)(!1, "unsupported frgament object", "obj", O);
        }
        static isConstructor(O) {
          return ej.isFragment(O);
        }
        static isError(O) {
          return eF.isFragment(O);
        }
        static isEvent(O) {
          return eK.isFragment(O);
        }
        static isFunction(O) {
          return e$.isFragment(O);
        }
        static isStruct(O) {
          return eV.isFragment(O);
        }
      }
      T.Fragment = eL;
      class eD extends eL {
        constructor(O, T, L, W) {
          super(O, T, W),
            (0, J.assertArgument)(
              "string" == typeof L && L.match(eh),
              "invalid identifier",
              "name",
              L
            ),
            (W = Object.freeze(W.slice())),
            (0, J.defineProperties)(this, { name: L });
        }
      }
      function e_(O, T) {
        return (
          "(" + T.map((T) => T.format(O)).join("full" === O ? ", " : ",") + ")"
        );
      }
      T.NamedFragment = eD;
      class eF extends eD {
        constructor(O, T, L) {
          super(O, "error", T, L),
            Object.defineProperty(this, eC, { value: eO });
        }
        get selector() {
          return (0, W.id)(this.format("sighash")).substring(0, 10);
        }
        format(O) {
          if ((null == O && (O = "sighash"), "json" === O))
            return JSON.stringify({
              type: "error",
              name: this.name,
              inputs: this.inputs.map((T) => JSON.parse(T.format(O))),
            });
          let T = [];
          return (
            "sighash" !== O && T.push("error"),
            T.push(this.name + e_(O, this.inputs)),
            T.join(" ")
          );
        }
        static from(O) {
          if (eF.isFragment(O)) return O;
          if ("string" == typeof O) return eF.from(eg(O));
          if (O instanceof ep) {
            let T = em("error", O),
              L = ew(O);
            return ek(O), new eF(eP, T, L);
          }
          return new eF(eP, O.name, O.inputs ? O.inputs.map(eU.from) : []);
        }
        static isFragment(O) {
          return O && O[eC] === eO;
        }
      }
      T.ErrorFragment = eF;
      class eK extends eD {
        constructor(O, T, L, W) {
          super(O, "event", T, L),
            Object.defineProperty(this, eC, { value: eT }),
            (0, J.defineProperties)(this, { anonymous: W });
        }
        get topicHash() {
          return (0, W.id)(this.format("sighash"));
        }
        format(O) {
          if ((null == O && (O = "sighash"), "json" === O))
            return JSON.stringify({
              type: "event",
              anonymous: this.anonymous,
              name: this.name,
              inputs: this.inputs.map((T) => JSON.parse(T.format(O))),
            });
          let T = [];
          return (
            "sighash" !== O && T.push("event"),
            T.push(this.name + e_(O, this.inputs)),
            "sighash" !== O && this.anonymous && T.push("anonymous"),
            T.join(" ")
          );
        }
        static getTopicHash(O, T) {
          return new eK(eP, O, (T = (T || []).map((O) => eU.from(O))), !1)
            .topicHash;
        }
        static from(O) {
          if (eK.isFragment(O)) return O;
          if ("string" == typeof O)
            try {
              return eK.from(eg(O));
            } catch (T) {
              (0, J.assertArgument)(!1, "invalid event fragment", "obj", O);
            }
          else if (O instanceof ep) {
            let T = em("event", O),
              L = ew(O, !0),
              J = !!eb(O, Y(["anonymous"])).has("anonymous");
            return ek(O), new eK(eP, T, L, J);
          }
          return new eK(
            eP,
            O.name,
            O.inputs ? O.inputs.map((O) => eU.from(O, !0)) : [],
            !!O.anonymous
          );
        }
        static isFragment(O) {
          return O && O[eC] === eT;
        }
      }
      T.EventFragment = eK;
      class ej extends eL {
        constructor(O, T, L, W, Y) {
          super(O, T, L),
            Object.defineProperty(this, eC, { value: eN }),
            (0, J.defineProperties)(this, { payable: W, gas: Y });
        }
        format(O) {
          if (
            ((0, J.assert)(
              null != O && "sighash" !== O,
              "cannot format a constructor for sighash",
              "UNSUPPORTED_OPERATION",
              { operation: "format(sighash)" }
            ),
            "json" === O)
          )
            return JSON.stringify({
              type: "constructor",
              stateMutability: this.payable ? "payable" : "undefined",
              payable: this.payable,
              gas: null != this.gas ? this.gas : void 0,
              inputs: this.inputs.map((T) => JSON.parse(T.format(O))),
            });
          let T = [`constructor${e_(O, this.inputs)}`];
          return (
            this.payable && T.push("payable"),
            null != this.gas && T.push(`@${this.gas.toString()}`),
            T.join(" ")
          );
        }
        static from(O) {
          if (ej.isFragment(O)) return O;
          if ("string" == typeof O)
            try {
              return ej.from(eg(O));
            } catch (T) {
              (0, J.assertArgument)(
                !1,
                "invalid constuctor fragment",
                "obj",
                O
              );
            }
          else if (O instanceof ep) {
            eb(O, Y(["constructor"]));
            let T = ew(O),
              L = !!eb(O, Z).has("payable"),
              J = ev(O);
            return ek(O), new ej(eP, "constructor", T, L, J);
          }
          return new ej(
            eP,
            "constructor",
            O.inputs ? O.inputs.map(eU.from) : [],
            !!O.payable,
            null != O.gas ? O.gas : null
          );
        }
        static isFragment(O) {
          return O && O[eC] === eN;
        }
      }
      T.ConstructorFragment = ej;
      class eH extends eL {
        constructor(O, T, L) {
          super(O, "fallback", T),
            Object.defineProperty(this, eC, { value: eR }),
            (0, J.defineProperties)(this, { payable: L });
        }
        format(O) {
          let T = 0 === this.inputs.length ? "receive" : "fallback";
          return "json" === O
            ? JSON.stringify({
                type: T,
                stateMutability: this.payable ? "payable" : "nonpayable",
              })
            : `${T}()${this.payable ? " payable" : ""}`;
        }
        static from(O) {
          if (eH.isFragment(O)) return O;
          if ("string" == typeof O)
            try {
              return eH.from(eg(O));
            } catch (T) {
              (0, J.assertArgument)(!1, "invalid fallback fragment", "obj", O);
            }
          else if (O instanceof ep) {
            let T = O.toString(),
              L = O.peekKeyword(Y(["fallback", "receive"]));
            if (
              ((0, J.assertArgument)(
                L,
                "type must be fallback or receive",
                "obj",
                T
              ),
              "receive" === O.popKeyword(Y(["fallback", "receive"])))
            ) {
              let T = ew(O);
              return (
                (0, J.assertArgument)(
                  0 === T.length,
                  "receive cannot have arguments",
                  "obj.inputs",
                  T
                ),
                eb(O, Y(["payable"])),
                ek(O),
                new eH(eP, [], !0)
              );
            }
            let W = ew(O);
            W.length
              ? (0, J.assertArgument)(
                  1 === W.length && "bytes" === W[0].type,
                  "invalid fallback inputs",
                  "obj.inputs",
                  W.map((O) => O.format("minimal")).join(", ")
                )
              : (W = [eU.from("bytes")]);
            let Z = eA(O);
            if (
              ((0, J.assertArgument)(
                "nonpayable" === Z || "payable" === Z,
                "fallback cannot be constants",
                "obj.stateMutability",
                Z
              ),
              eb(O, Y(["returns"])).has("returns"))
            ) {
              let T = ew(O);
              (0, J.assertArgument)(
                1 === T.length && "bytes" === T[0].type,
                "invalid fallback outputs",
                "obj.outputs",
                T.map((O) => O.format("minimal")).join(", ")
              );
            }
            return ek(O), new eH(eP, W, "payable" === Z);
          }
          return "receive" === O.type
            ? new eH(eP, [], !0)
            : "fallback" === O.type
            ? new eH(eP, [eU.from("bytes")], "payable" === O.stateMutability)
            : void (0, J.assertArgument)(
                !1,
                "invalid fallback description",
                "obj",
                O
              );
        }
        static isFragment(O) {
          return O && O[eC] === eR;
        }
      }
      T.FallbackFragment = eH;
      class e$ extends eD {
        constructor(O, T, L, W, Y, Z) {
          super(O, "function", T, W),
            Object.defineProperty(this, eC, { value: eI }),
            (Y = Object.freeze(Y.slice()));
          let X = "view" === L || "pure" === L,
            ee = "payable" === L;
          (0, J.defineProperties)(this, {
            constant: X,
            gas: Z,
            outputs: Y,
            payable: ee,
            stateMutability: L,
          });
        }
        get selector() {
          return (0, W.id)(this.format("sighash")).substring(0, 10);
        }
        format(O) {
          if ((null == O && (O = "sighash"), "json" === O))
            return JSON.stringify({
              type: "function",
              name: this.name,
              constant: this.constant,
              stateMutability:
                "nonpayable" !== this.stateMutability
                  ? this.stateMutability
                  : void 0,
              payable: this.payable,
              gas: null != this.gas ? this.gas : void 0,
              inputs: this.inputs.map((T) => JSON.parse(T.format(O))),
              outputs: this.outputs.map((T) => JSON.parse(T.format(O))),
            });
          let T = [];
          return (
            "sighash" !== O && T.push("function"),
            T.push(this.name + e_(O, this.inputs)),
            "sighash" !== O &&
              ("nonpayable" !== this.stateMutability &&
                T.push(this.stateMutability),
              this.outputs &&
                this.outputs.length &&
                (T.push("returns"), T.push(e_(O, this.outputs))),
              null != this.gas && T.push(`@${this.gas.toString()}`)),
            T.join(" ")
          );
        }
        static getSelector(O, T) {
          return new e$(
            eP,
            O,
            "view",
            (T = (T || []).map((O) => eU.from(O))),
            [],
            null
          ).selector;
        }
        static from(O) {
          if (e$.isFragment(O)) return O;
          if ("string" == typeof O)
            try {
              return e$.from(eg(O));
            } catch (T) {
              (0, J.assertArgument)(!1, "invalid function fragment", "obj", O);
            }
          else if (O instanceof ep) {
            let T = em("function", O),
              L = ew(O),
              J = eA(O),
              W = [];
            eb(O, Y(["returns"])).has("returns") && (W = ew(O));
            let Z = ev(O);
            return ek(O), new e$(eP, T, J, L, W, Z);
          }
          let T = O.stateMutability;
          return (
            null != T ||
              ((T = "payable"),
              "boolean" == typeof O.constant
                ? ((T = "view"),
                  O.constant ||
                    ((T = "payable"),
                    "boolean" != typeof O.payable ||
                      O.payable ||
                      (T = "nonpayable")))
                : "boolean" != typeof O.payable ||
                  O.payable ||
                  (T = "nonpayable")),
            new e$(
              eP,
              O.name,
              T,
              O.inputs ? O.inputs.map(eU.from) : [],
              O.outputs ? O.outputs.map(eU.from) : [],
              null != O.gas ? O.gas : null
            )
          );
        }
        static isFragment(O) {
          return O && O[eC] === eI;
        }
      }
      T.FunctionFragment = e$;
      class eV extends eD {
        constructor(O, T, L) {
          super(O, "struct", T, L),
            Object.defineProperty(this, eC, { value: eM });
        }
        format() {
          throw Error("@TODO");
        }
        static from(O) {
          if ("string" == typeof O)
            try {
              return eV.from(eg(O));
            } catch (T) {
              (0, J.assertArgument)(!1, "invalid struct fragment", "obj", O);
            }
          else if (O instanceof ep) {
            let T = em("struct", O),
              L = ew(O);
            return ek(O), new eV(eP, T, L);
          }
          return new eV(eP, O.name, O.inputs ? O.inputs.map(eU.from) : []);
        }
        static isFragment(O) {
          return O && O[eC] === eM;
        }
      }
      T.StructFragment = eV;
    },
    16330: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Typed =
          T.Result =
          T.TransactionDescription =
          T.LogDescription =
          T.ErrorDescription =
          T.Interface =
          T.Indexed =
          T.checkResultErrors =
          T.StructFragment =
          T.ParamType =
          T.NamedFragment =
          T.FunctionFragment =
          T.Fragment =
          T.FallbackFragment =
          T.EventFragment =
          T.ErrorFragment =
          T.ConstructorFragment =
          T.encodeBytes32String =
          T.decodeBytes32String =
          T.AbiCoder =
            void 0);
      var J = L(79934);
      Object.defineProperty(T, "AbiCoder", {
        enumerable: !0,
        get: function () {
          return J.AbiCoder;
        },
      });
      var W = L(30657);
      Object.defineProperty(T, "decodeBytes32String", {
        enumerable: !0,
        get: function () {
          return W.decodeBytes32String;
        },
      }),
        Object.defineProperty(T, "encodeBytes32String", {
          enumerable: !0,
          get: function () {
            return W.encodeBytes32String;
          },
        });
      var Y = L(4411);
      Object.defineProperty(T, "ConstructorFragment", {
        enumerable: !0,
        get: function () {
          return Y.ConstructorFragment;
        },
      }),
        Object.defineProperty(T, "ErrorFragment", {
          enumerable: !0,
          get: function () {
            return Y.ErrorFragment;
          },
        }),
        Object.defineProperty(T, "EventFragment", {
          enumerable: !0,
          get: function () {
            return Y.EventFragment;
          },
        }),
        Object.defineProperty(T, "FallbackFragment", {
          enumerable: !0,
          get: function () {
            return Y.FallbackFragment;
          },
        }),
        Object.defineProperty(T, "Fragment", {
          enumerable: !0,
          get: function () {
            return Y.Fragment;
          },
        }),
        Object.defineProperty(T, "FunctionFragment", {
          enumerable: !0,
          get: function () {
            return Y.FunctionFragment;
          },
        }),
        Object.defineProperty(T, "NamedFragment", {
          enumerable: !0,
          get: function () {
            return Y.NamedFragment;
          },
        }),
        Object.defineProperty(T, "ParamType", {
          enumerable: !0,
          get: function () {
            return Y.ParamType;
          },
        }),
        Object.defineProperty(T, "StructFragment", {
          enumerable: !0,
          get: function () {
            return Y.StructFragment;
          },
        });
      var Z = L(18825);
      Object.defineProperty(T, "checkResultErrors", {
        enumerable: !0,
        get: function () {
          return Z.checkResultErrors;
        },
      }),
        Object.defineProperty(T, "Indexed", {
          enumerable: !0,
          get: function () {
            return Z.Indexed;
          },
        }),
        Object.defineProperty(T, "Interface", {
          enumerable: !0,
          get: function () {
            return Z.Interface;
          },
        }),
        Object.defineProperty(T, "ErrorDescription", {
          enumerable: !0,
          get: function () {
            return Z.ErrorDescription;
          },
        }),
        Object.defineProperty(T, "LogDescription", {
          enumerable: !0,
          get: function () {
            return Z.LogDescription;
          },
        }),
        Object.defineProperty(T, "TransactionDescription", {
          enumerable: !0,
          get: function () {
            return Z.TransactionDescription;
          },
        }),
        Object.defineProperty(T, "Result", {
          enumerable: !0,
          get: function () {
            return Z.Result;
          },
        });
      var X = L(29970);
      Object.defineProperty(T, "Typed", {
        enumerable: !0,
        get: function () {
          return X.Typed;
        },
      });
    },
    18825: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Interface =
          T.Indexed =
          T.ErrorDescription =
          T.TransactionDescription =
          T.LogDescription =
          T.Result =
          T.checkResultErrors =
            void 0);
      let J = L(3382),
        W = L(41648),
        Y = L(38478),
        Z = L(79934),
        X = L(31458);
      Object.defineProperty(T, "checkResultErrors", {
        enumerable: !0,
        get: function () {
          return X.checkResultErrors;
        },
      }),
        Object.defineProperty(T, "Result", {
          enumerable: !0,
          get: function () {
            return X.Result;
          },
        });
      let ee = L(4411),
        et = L(29970);
      class er {
        constructor(O, T, L) {
          let J = O.name,
            W = O.format();
          (0, Y.defineProperties)(this, {
            fragment: O,
            name: J,
            signature: W,
            topic: T,
            args: L,
          });
        }
      }
      T.LogDescription = er;
      class en {
        constructor(O, T, L, J) {
          let W = O.name,
            Z = O.format();
          (0, Y.defineProperties)(this, {
            fragment: O,
            name: W,
            args: L,
            signature: Z,
            selector: T,
            value: J,
          });
        }
      }
      T.TransactionDescription = en;
      class es {
        constructor(O, T, L) {
          let J = O.name,
            W = O.format();
          (0, Y.defineProperties)(this, {
            fragment: O,
            name: J,
            args: L,
            signature: W,
            selector: T,
          });
        }
      }
      T.ErrorDescription = es;
      class ei {
        static isIndexed(O) {
          return !!(O && O._isIndexed);
        }
        constructor(O) {
          (0, Y.defineProperties)(this, { hash: O, _isIndexed: !0 });
        }
      }
      T.Indexed = ei;
      let ea = {
          0: "generic panic",
          1: "assert(false)",
          17: "arithmetic overflow",
          18: "division or modulo by zero",
          33: "enum overflow",
          34: "invalid encoded storage byte array accessed",
          49: "out-of-bounds array access; popping on an empty array",
          50: "out-of-bounds access of an array or bytesN",
          65: "out of memory",
          81: "uninitialized function",
        },
        eo = {
          "0x08c379a0": {
            signature: "Error(string)",
            name: "Error",
            inputs: ["string"],
            reason: (O) => `reverted with reason string ${JSON.stringify(O)}`,
          },
          "0x4e487b71": {
            signature: "Panic(uint256)",
            name: "Panic",
            inputs: ["uint256"],
            reason: (O) => {
              let T = "unknown panic code";
              return (
                O >= 0 &&
                  O <= 255 &&
                  ea[O.toString()] &&
                  (T = ea[O.toString()]),
                `reverted with panic code 0x${O.toString(16)} (${T})`
              );
            },
          },
        };
      class ec {
        constructor(O) {
          let T = [];
          (T = "string" == typeof O ? JSON.parse(O) : O),
            (this.y__0 = new Map()),
            (this.f__0 = new Map()),
            (this.g__0 = new Map());
          let L = [];
          for (let O of T)
            try {
              L.push(ee.Fragment.from(O));
            } catch (T) {
              console.log(
                `[Warning] Invalid Fragment ${JSON.stringify(O)}:`,
                T.message
              );
            }
          (0, Y.defineProperties)(this, { fragments: Object.freeze(L) });
          let J = null,
            W = !1;
          (this.m__0 = this.getAbiCoder()),
            this.fragments.forEach((O, T) => {
              let L;
              switch (O.type) {
                case "constructor":
                  if (this.deploy) {
                    console.log("duplicate definition - constructor");
                    return;
                  }
                  (0, Y.defineProperties)(this, { deploy: O });
                  return;
                case "fallback":
                  0 === O.inputs.length
                    ? (W = !0)
                    : ((0, Y.assertArgument)(
                        !J || O.payable !== J.payable,
                        "conflicting fallback fragments",
                        `fragments[${T}]`,
                        O
                      ),
                      (W = (J = O).payable));
                  return;
                case "function":
                  L = this.y__0;
                  break;
                case "event":
                  L = this.g__0;
                  break;
                case "error":
                  L = this.f__0;
                  break;
                default:
                  return;
              }
              let Z = O.format();
              L.has(Z) || L.set(Z, O);
            }),
            this.deploy ||
              (0, Y.defineProperties)(this, {
                deploy: ee.ConstructorFragment.from("constructor()"),
              }),
            (0, Y.defineProperties)(this, { fallback: J, receive: W });
        }
        format(O) {
          let T = O ? "minimal" : "full";
          return this.fragments.map((O) => O.format(T));
        }
        formatJson() {
          return JSON.stringify(
            this.fragments
              .map((O) => O.format("json"))
              .map((O) => JSON.parse(O))
          );
        }
        getAbiCoder() {
          return Z.AbiCoder.defaultAbiCoder();
        }
        b__0(O, T, L) {
          if ((0, Y.isHexString)(O)) {
            let T = O.toLowerCase();
            for (let O of this.y__0.values()) if (T === O.selector) return O;
            return null;
          }
          if (-1 === O.indexOf("(")) {
            let J = [];
            for (let [T, L] of this.y__0) T.split("(")[0] === O && J.push(L);
            if (T) {
              let O = T.length > 0 ? T[T.length - 1] : null,
                L = T.length,
                W = !0;
              et.Typed.isTyped(O) && "overrides" === O.type && ((W = !1), L--);
              for (let O = J.length - 1; O >= 0; O--) {
                let T = J[O].inputs.length;
                T === L || (W && T === L - 1) || J.splice(O, 1);
              }
              for (let O = J.length - 1; O >= 0; O--) {
                let L = J[O].inputs;
                for (let W = 0; W < T.length; W++)
                  if (et.Typed.isTyped(T[W])) {
                    if (W >= L.length) {
                      if ("overrides" === T[W].type) continue;
                      J.splice(O, 1);
                      break;
                    }
                    if (T[W].type !== L[W].baseType) {
                      J.splice(O, 1);
                      break;
                    }
                  }
              }
            }
            if (1 === J.length && T && T.length !== J[0].inputs.length) {
              let O = T[T.length - 1];
              (null == O || Array.isArray(O) || "object" != typeof O) &&
                J.splice(0, 1);
            }
            if (0 === J.length) return null;
            if (J.length > 1 && L) {
              let T = J.map((O) => JSON.stringify(O.format())).join(", ");
              (0, Y.assertArgument)(
                !1,
                `ambiguous function description (i.e. matches ${T})`,
                "key",
                O
              );
            }
            return J[0];
          }
          return this.y__0.get(ee.FunctionFragment.from(O).format()) || null;
        }
        getFunctionName(O) {
          let T = this.b__0(O, null, !1);
          return (
            (0, Y.assertArgument)(T, "no matching function", "key", O), T.name
          );
        }
        hasFunction(O) {
          return !!this.b__0(O, null, !1);
        }
        getFunction(O, T) {
          return this.b__0(O, T || null, !0);
        }
        forEachFunction(O) {
          let T = Array.from(this.y__0.keys());
          T.sort((O, T) => O.localeCompare(T));
          for (let L = 0; L < T.length; L++) {
            let J = T[L];
            O(this.y__0.get(J), L);
          }
        }
        __A(O, T, L) {
          if ((0, Y.isHexString)(O)) {
            let T = O.toLowerCase();
            for (let O of this.g__0.values()) if (T === O.topicHash) return O;
            return null;
          }
          if (-1 === O.indexOf("(")) {
            let J = [];
            for (let [T, L] of this.g__0) T.split("(")[0] === O && J.push(L);
            if (T) {
              for (let O = J.length - 1; O >= 0; O--)
                J[O].inputs.length < T.length && J.splice(O, 1);
              for (let O = J.length - 1; O >= 0; O--) {
                let L = J[O].inputs;
                for (let W = 0; W < T.length; W++)
                  if (et.Typed.isTyped(T[W]) && T[W].type !== L[W].baseType) {
                    J.splice(O, 1);
                    break;
                  }
              }
            }
            if (0 === J.length) return null;
            if (J.length > 1 && L) {
              let T = J.map((O) => JSON.stringify(O.format())).join(", ");
              (0, Y.assertArgument)(
                !1,
                `ambiguous event description (i.e. matches ${T})`,
                "key",
                O
              );
            }
            return J[0];
          }
          return this.g__0.get(ee.EventFragment.from(O).format()) || null;
        }
        getEventName(O) {
          let T = this.__A(O, null, !1);
          return (
            (0, Y.assertArgument)(T, "no matching event", "key", O), T.name
          );
        }
        hasEvent(O) {
          return !!this.__A(O, null, !1);
        }
        getEvent(O, T) {
          return this.__A(O, T || null, !0);
        }
        forEachEvent(O) {
          let T = Array.from(this.g__0.keys());
          T.sort((O, T) => O.localeCompare(T));
          for (let L = 0; L < T.length; L++) {
            let J = T[L];
            O(this.g__0.get(J), L);
          }
        }
        getError(O, T) {
          if ((0, Y.isHexString)(O)) {
            let T = O.toLowerCase();
            if (eo[T]) return ee.ErrorFragment.from(eo[T].signature);
            for (let O of this.f__0.values()) if (T === O.selector) return O;
            return null;
          }
          if (-1 === O.indexOf("(")) {
            let T = [];
            for (let [L, J] of this.f__0) L.split("(")[0] === O && T.push(J);
            if (0 === T.length)
              return "Error" === O
                ? ee.ErrorFragment.from("error Error(string)")
                : "Panic" === O
                ? ee.ErrorFragment.from("error Panic(uint256)")
                : null;
            if (T.length > 1) {
              let L = T.map((O) => JSON.stringify(O.format())).join(", ");
              (0, Y.assertArgument)(
                !1,
                `ambiguous error description (i.e. ${L})`,
                "name",
                O
              );
            }
            return T[0];
          }
          return "Error(string)" === (O = ee.ErrorFragment.from(O).format())
            ? ee.ErrorFragment.from("error Error(string)")
            : "Panic(uint256)" === O
            ? ee.ErrorFragment.from("error Panic(uint256)")
            : this.f__0.get(O) || null;
        }
        forEachError(O) {
          let T = Array.from(this.f__0.keys());
          T.sort((O, T) => O.localeCompare(T));
          for (let L = 0; L < T.length; L++) {
            let J = T[L];
            O(this.f__0.get(J), L);
          }
        }
        _decodeParams(O, T) {
          return this.m__0.decode(O, T);
        }
        _encodeParams(O, T) {
          return this.m__0.encode(O, T);
        }
        encodeDeploy(O) {
          return this._encodeParams(this.deploy.inputs, O || []);
        }
        decodeErrorResult(O, T) {
          if ("string" == typeof O) {
            let T = this.getError(O);
            (0, Y.assertArgument)(T, "unknown error", "fragment", O), (O = T);
          }
          return (
            (0, Y.assertArgument)(
              (0, Y.dataSlice)(T, 0, 4) === O.selector,
              `data signature does not match error ${O.name}.`,
              "data",
              T
            ),
            this._decodeParams(O.inputs, (0, Y.dataSlice)(T, 4))
          );
        }
        encodeErrorResult(O, T) {
          if ("string" == typeof O) {
            let T = this.getError(O);
            (0, Y.assertArgument)(T, "unknown error", "fragment", O), (O = T);
          }
          return (0, Y.concat)([
            O.selector,
            this._encodeParams(O.inputs, T || []),
          ]);
        }
        decodeFunctionData(O, T) {
          if ("string" == typeof O) {
            let T = this.getFunction(O);
            (0, Y.assertArgument)(T, "unknown function", "fragment", O),
              (O = T);
          }
          return (
            (0, Y.assertArgument)(
              (0, Y.dataSlice)(T, 0, 4) === O.selector,
              `data signature does not match function ${O.name}.`,
              "data",
              T
            ),
            this._decodeParams(O.inputs, (0, Y.dataSlice)(T, 4))
          );
        }
        encodeFunctionData(O, T) {
          if ("string" == typeof O) {
            let T = this.getFunction(O);
            (0, Y.assertArgument)(T, "unknown function", "fragment", O),
              (O = T);
          }
          return (0, Y.concat)([
            O.selector,
            this._encodeParams(O.inputs, T || []),
          ]);
        }
        decodeFunctionResult(O, T) {
          if ("string" == typeof O) {
            let T = this.getFunction(O);
            (0, Y.assertArgument)(T, "unknown function", "fragment", O),
              (O = T);
          }
          let L = "invalid length for result data",
            J = (0, Y.getBytesCopy)(T);
          if (J.length % 32 == 0)
            try {
              return this.m__0.decode(O.outputs, J);
            } catch (O) {
              L = "could not decode result data";
            }
          (0, Y.assert)(!1, L, "BAD_DATA", {
            value: (0, Y.hexlify)(J),
            info: { method: O.name, signature: O.format() },
          });
        }
        makeError(O, T) {
          let L = (0, Y.getBytes)(O, "data"),
            J = Z.AbiCoder.getBuiltinCallException("call", T, L),
            W = "execution reverted (unknown custom error)";
          if (J.message.startsWith(W)) {
            let O = (0, Y.hexlify)(L.slice(0, 4)),
              T = this.getError(O);
            if (T)
              try {
                let O = this.m__0.decode(T.inputs, L.slice(4));
                (J.revert = { name: T.name, signature: T.format(), args: O }),
                  (J.reason = J.revert.signature),
                  (J.message = `execution reverted: ${J.reason}`);
              } catch (O) {
                J.message =
                  "execution reverted (coult not decode custom error)";
              }
          }
          let X = this.parseTransaction(T);
          return (
            X &&
              (J.invocation = {
                method: X.name,
                signature: X.signature,
                args: X.args,
              }),
            J
          );
        }
        encodeFunctionResult(O, T) {
          if ("string" == typeof O) {
            let T = this.getFunction(O);
            (0, Y.assertArgument)(T, "unknown function", "fragment", O),
              (O = T);
          }
          return (0, Y.hexlify)(this.m__0.encode(O.outputs, T || []));
        }
        encodeFilterTopics(O, T) {
          if ("string" == typeof O) {
            let T = this.getEvent(O);
            (0, Y.assertArgument)(T, "unknown event", "eventFragment", O),
              (O = T);
          }
          (0, Y.assert)(
            T.length <= O.inputs.length,
            `too many arguments for ${O.format()}`,
            "UNEXPECTED_ARGUMENT",
            { count: T.length, expectedCount: O.inputs.length }
          );
          let L = [];
          O.anonymous || L.push(O.topicHash);
          let Z = (O, T) =>
            "string" === O.type
              ? (0, W.id)(T)
              : "bytes" === O.type
              ? (0, J.keccak256)((0, Y.hexlify)(T))
              : ("bool" === O.type && "boolean" == typeof T
                  ? (T = T ? "0x01" : "0x00")
                  : O.type.match(/^u?int/)
                  ? (T = (0, Y.toBeHex)(T))
                  : O.type.match(/^bytes/)
                  ? (T = (0, Y.zeroPadBytes)(T, 32))
                  : "address" === O.type && this.m__0.encode(["address"], [T]),
                (0, Y.zeroPadValue)((0, Y.hexlify)(T), 32));
          for (
            T.forEach((T, J) => {
              let W = O.inputs[J];
              if (!W.indexed) {
                (0, Y.assertArgument)(
                  null == T,
                  "cannot filter non-indexed parameters; must be null",
                  "contract." + W.name,
                  T
                );
                return;
              }
              null == T
                ? L.push(null)
                : "array" === W.baseType || "tuple" === W.baseType
                ? (0, Y.assertArgument)(
                    !1,
                    "filtering with tuples or arrays not supported",
                    "contract." + W.name,
                    T
                  )
                : Array.isArray(T)
                ? L.push(T.map((O) => Z(W, O)))
                : L.push(Z(W, T));
            });
            L.length && null === L[L.length - 1];

          )
            L.pop();
          return L;
        }
        encodeEventLog(O, T) {
          if ("string" == typeof O) {
            let T = this.getEvent(O);
            (0, Y.assertArgument)(T, "unknown event", "eventFragment", O),
              (O = T);
          }
          let L = [],
            Z = [],
            X = [];
          return (
            O.anonymous || L.push(O.topicHash),
            (0, Y.assertArgument)(
              T.length === O.inputs.length,
              "event arguments/values mismatch",
              "values",
              T
            ),
            O.inputs.forEach((O, Y) => {
              let ee = T[Y];
              if (O.indexed) {
                if ("string" === O.type) L.push((0, W.id)(ee));
                else if ("bytes" === O.type) L.push((0, J.keccak256)(ee));
                else if ("tuple" === O.baseType || "array" === O.baseType)
                  throw Error("not implemented");
                else L.push(this.m__0.encode([O.type], [ee]));
              } else Z.push(O), X.push(ee);
            }),
            { data: this.m__0.encode(Z, X), topics: L }
          );
        }
        decodeEventLog(O, T, L) {
          if ("string" == typeof O) {
            let T = this.getEvent(O);
            (0, Y.assertArgument)(T, "unknown event", "eventFragment", O),
              (O = T);
          }
          if (null != L && !O.anonymous) {
            let T = O.topicHash;
            (0, Y.assertArgument)(
              (0, Y.isHexString)(L[0], 32) && L[0].toLowerCase() === T,
              "fragment/topic mismatch",
              "topics[0]",
              L[0]
            ),
              (L = L.slice(1));
          }
          let J = [],
            W = [],
            Z = [];
          O.inputs.forEach((O, T) => {
            O.indexed
              ? "string" === O.type ||
                "bytes" === O.type ||
                "tuple" === O.baseType ||
                "array" === O.baseType
                ? (J.push(ee.ParamType.from({ type: "bytes32", name: O.name })),
                  Z.push(!0))
                : (J.push(O), Z.push(!1))
              : (W.push(O), Z.push(!1));
          });
          let et = null != L ? this.m__0.decode(J, (0, Y.concat)(L)) : null,
            er = this.m__0.decode(W, T, !0),
            en = [],
            es = [],
            ea = 0,
            eo = 0;
          return (
            O.inputs.forEach((O, T) => {
              let L = null;
              if (O.indexed) {
                if (null == et) L = new ei(null);
                else if (Z[T]) L = new ei(et[eo++]);
                else
                  try {
                    L = et[eo++];
                  } catch (O) {
                    L = O;
                  }
              } else
                try {
                  L = er[ea++];
                } catch (O) {
                  L = O;
                }
              en.push(L), es.push(O.name || null);
            }),
            X.Result.fromItems(en, es)
          );
        }
        parseTransaction(O) {
          let T = (0, Y.getBytes)(O.data, "tx.data"),
            L = (0, Y.getBigInt)(null != O.value ? O.value : 0, "tx.value"),
            J = this.getFunction((0, Y.hexlify)(T.slice(0, 4)));
          if (!J) return null;
          let W = this.m__0.decode(J.inputs, T.slice(4));
          return new en(J, J.selector, W, L);
        }
        parseCallResult(O) {
          throw Error("@TODO");
        }
        parseLog(O) {
          let T = this.getEvent(O.topics[0]);
          return !T || T.anonymous
            ? null
            : new er(T, T.topicHash, this.decodeEventLog(T, O.data, O.topics));
        }
        parseError(O) {
          let T = (0, Y.hexlify)(O),
            L = this.getError((0, Y.dataSlice)(T, 0, 4));
          if (!L) return null;
          let J = this.m__0.decode(L.inputs, (0, Y.dataSlice)(T, 4));
          return new es(L, L.selector, J);
        }
        static from(O) {
          return O instanceof ec
            ? O
            : new ec(
                "string" == typeof O
                  ? JSON.parse(O)
                  : "function" == typeof O.format
                  ? O.format("json")
                  : O
              );
        }
      }
      T.Interface = ec;
    },
    29970: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }), (T.Typed = void 0);
      let J = L(38478),
        W = {};
      function Y(O, T) {
        let L = !1;
        return (
          T < 0 && ((L = !0), (T *= -1)),
          new ee(W, `${L ? "" : "u"}int${T}`, O, { signed: L, width: T })
        );
      }
      function Z(O, T) {
        return new ee(W, `bytes${T || ""}`, O, { size: T });
      }
      let X = Symbol.for("_ethers_typed");
      class ee {
        constructor(O, T, L, Y) {
          null == Y && (Y = null),
            (0, J.assertPrivate)(W, O, "Typed"),
            (0, J.defineProperties)(this, {
              _typedSymbol: X,
              type: T,
              value: L,
            }),
            (this.w__0 = Y),
            this.format();
        }
        format() {
          if ("array" === this.type || "dynamicArray" === this.type)
            throw Error("");
          return "tuple" === this.type
            ? `tuple(${this.value.map((O) => O.format()).join(",")})`
            : this.type;
        }
        defaultValue() {
          return 0;
        }
        minValue() {
          return 0;
        }
        maxValue() {
          return 0;
        }
        isBigInt() {
          return !!this.type.match(/^u?int[0-9]+$/);
        }
        isData() {
          return this.type.startsWith("bytes");
        }
        isString() {
          return "string" === this.type;
        }
        get tupleName() {
          if ("tuple" !== this.type) throw TypeError("not a tuple");
          return this.w__0;
        }
        get arrayLength() {
          if ("array" !== this.type) throw TypeError("not an array");
          return !0 === this.w__0
            ? -1
            : !1 === this.w__0
            ? this.value.length
            : null;
        }
        static from(O, T) {
          return new ee(W, O, T);
        }
        static uint8(O) {
          return Y(O, 8);
        }
        static uint16(O) {
          return Y(O, 16);
        }
        static uint24(O) {
          return Y(O, 24);
        }
        static uint32(O) {
          return Y(O, 32);
        }
        static uint40(O) {
          return Y(O, 40);
        }
        static uint48(O) {
          return Y(O, 48);
        }
        static uint56(O) {
          return Y(O, 56);
        }
        static uint64(O) {
          return Y(O, 64);
        }
        static uint72(O) {
          return Y(O, 72);
        }
        static uint80(O) {
          return Y(O, 80);
        }
        static uint88(O) {
          return Y(O, 88);
        }
        static uint96(O) {
          return Y(O, 96);
        }
        static uint104(O) {
          return Y(O, 104);
        }
        static uint112(O) {
          return Y(O, 112);
        }
        static uint120(O) {
          return Y(O, 120);
        }
        static uint128(O) {
          return Y(O, 128);
        }
        static uint136(O) {
          return Y(O, 136);
        }
        static uint144(O) {
          return Y(O, 144);
        }
        static uint152(O) {
          return Y(O, 152);
        }
        static uint160(O) {
          return Y(O, 160);
        }
        static uint168(O) {
          return Y(O, 168);
        }
        static uint176(O) {
          return Y(O, 176);
        }
        static uint184(O) {
          return Y(O, 184);
        }
        static uint192(O) {
          return Y(O, 192);
        }
        static uint200(O) {
          return Y(O, 200);
        }
        static uint208(O) {
          return Y(O, 208);
        }
        static uint216(O) {
          return Y(O, 216);
        }
        static uint224(O) {
          return Y(O, 224);
        }
        static uint232(O) {
          return Y(O, 232);
        }
        static uint240(O) {
          return Y(O, 240);
        }
        static uint248(O) {
          return Y(O, 248);
        }
        static uint256(O) {
          return Y(O, 256);
        }
        static uint(O) {
          return Y(O, 256);
        }
        static int8(O) {
          return Y(O, -8);
        }
        static int16(O) {
          return Y(O, -16);
        }
        static int24(O) {
          return Y(O, -24);
        }
        static int32(O) {
          return Y(O, -32);
        }
        static int40(O) {
          return Y(O, -40);
        }
        static int48(O) {
          return Y(O, -48);
        }
        static int56(O) {
          return Y(O, -56);
        }
        static int64(O) {
          return Y(O, -64);
        }
        static int72(O) {
          return Y(O, -72);
        }
        static int80(O) {
          return Y(O, -80);
        }
        static int88(O) {
          return Y(O, -88);
        }
        static int96(O) {
          return Y(O, -96);
        }
        static int104(O) {
          return Y(O, -104);
        }
        static int112(O) {
          return Y(O, -112);
        }
        static int120(O) {
          return Y(O, -120);
        }
        static int128(O) {
          return Y(O, -128);
        }
        static int136(O) {
          return Y(O, -136);
        }
        static int144(O) {
          return Y(O, -144);
        }
        static int152(O) {
          return Y(O, -152);
        }
        static int160(O) {
          return Y(O, -160);
        }
        static int168(O) {
          return Y(O, -168);
        }
        static int176(O) {
          return Y(O, -176);
        }
        static int184(O) {
          return Y(O, -184);
        }
        static int192(O) {
          return Y(O, -192);
        }
        static int200(O) {
          return Y(O, -200);
        }
        static int208(O) {
          return Y(O, -208);
        }
        static int216(O) {
          return Y(O, -216);
        }
        static int224(O) {
          return Y(O, -224);
        }
        static int232(O) {
          return Y(O, -232);
        }
        static int240(O) {
          return Y(O, -240);
        }
        static int248(O) {
          return Y(O, -248);
        }
        static int256(O) {
          return Y(O, -256);
        }
        static int(O) {
          return Y(O, -256);
        }
        static bytes1(O) {
          return Z(O, 1);
        }
        static bytes2(O) {
          return Z(O, 2);
        }
        static bytes3(O) {
          return Z(O, 3);
        }
        static bytes4(O) {
          return Z(O, 4);
        }
        static bytes5(O) {
          return Z(O, 5);
        }
        static bytes6(O) {
          return Z(O, 6);
        }
        static bytes7(O) {
          return Z(O, 7);
        }
        static bytes8(O) {
          return Z(O, 8);
        }
        static bytes9(O) {
          return Z(O, 9);
        }
        static bytes10(O) {
          return Z(O, 10);
        }
        static bytes11(O) {
          return Z(O, 11);
        }
        static bytes12(O) {
          return Z(O, 12);
        }
        static bytes13(O) {
          return Z(O, 13);
        }
        static bytes14(O) {
          return Z(O, 14);
        }
        static bytes15(O) {
          return Z(O, 15);
        }
        static bytes16(O) {
          return Z(O, 16);
        }
        static bytes17(O) {
          return Z(O, 17);
        }
        static bytes18(O) {
          return Z(O, 18);
        }
        static bytes19(O) {
          return Z(O, 19);
        }
        static bytes20(O) {
          return Z(O, 20);
        }
        static bytes21(O) {
          return Z(O, 21);
        }
        static bytes22(O) {
          return Z(O, 22);
        }
        static bytes23(O) {
          return Z(O, 23);
        }
        static bytes24(O) {
          return Z(O, 24);
        }
        static bytes25(O) {
          return Z(O, 25);
        }
        static bytes26(O) {
          return Z(O, 26);
        }
        static bytes27(O) {
          return Z(O, 27);
        }
        static bytes28(O) {
          return Z(O, 28);
        }
        static bytes29(O) {
          return Z(O, 29);
        }
        static bytes30(O) {
          return Z(O, 30);
        }
        static bytes31(O) {
          return Z(O, 31);
        }
        static bytes32(O) {
          return Z(O, 32);
        }
        static address(O) {
          return new ee(W, "address", O);
        }
        static bool(O) {
          return new ee(W, "bool", !!O);
        }
        static bytes(O) {
          return new ee(W, "bytes", O);
        }
        static string(O) {
          return new ee(W, "string", O);
        }
        static array(O, T) {
          throw Error("not implemented yet");
        }
        static tuple(O, T) {
          throw Error("not implemented yet");
        }
        static overrides(O) {
          return new ee(W, "overrides", Object.assign({}, O));
        }
        static isTyped(O) {
          return (
            O &&
            "object" == typeof O &&
            "_typedSymbol" in O &&
            O._typedSymbol === X
          );
        }
        static dereference(O, T) {
          if (ee.isTyped(O)) {
            if (O.type !== T)
              throw Error(`invalid type: expecetd ${T}, got ${O.type}`);
            return O.value;
          }
          return O;
        }
      }
      T.Typed = ee;
    },
    41779: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.getIcapAddress = T.getAddress = void 0);
      let J = L(3382),
        W = L(38478),
        Y = BigInt(0),
        Z = BigInt(36);
      function X(O) {
        let T = (O = O.toLowerCase()).substring(2).split(""),
          L = new Uint8Array(40);
        for (let O = 0; O < 40; O++) L[O] = T[O].charCodeAt(0);
        let Y = (0, W.getBytes)((0, J.keccak256)(L));
        for (let O = 0; O < 40; O += 2)
          Y[O >> 1] >> 4 >= 8 && (T[O] = T[O].toUpperCase()),
            (15 & Y[O >> 1]) >= 8 && (T[O + 1] = T[O + 1].toUpperCase());
        return "0x" + T.join("");
      }
      let ee = {};
      for (let O = 0; O < 10; O++) ee[String(O)] = String(O);
      for (let O = 0; O < 26; O++)
        ee[String.fromCharCode(65 + O)] = String(10 + O);
      let et = 15;
      function er(O) {
        let T = (O =
          (O = O.toUpperCase()).substring(4) + O.substring(0, 2) + "00")
          .split("")
          .map((O) => ee[O])
          .join("");
        for (; T.length >= et; ) {
          let O = T.substring(0, et);
          T = (parseInt(O, 10) % 97) + T.substring(O.length);
        }
        let L = String(98 - (parseInt(T, 10) % 97));
        for (; L.length < 2; ) L = "0" + L;
        return L;
      }
      let en = (function () {
        let O = {};
        for (let T = 0; T < 36; T++)
          O["0123456789abcdefghijklmnopqrstuvwxyz"[T]] = BigInt(T);
        return O;
      })();
      function es(O) {
        O = O.toLowerCase();
        let T = Y;
        for (let L = 0; L < O.length; L++) T = T * Z + en[O[L]];
        return T;
      }
      function ei(O) {
        if (
          ((0, W.assertArgument)(
            "string" == typeof O,
            "invalid address",
            "address",
            O
          ),
          O.match(/^(0x)?[0-9a-fA-F]{40}$/))
        ) {
          O.startsWith("0x") || (O = "0x" + O);
          let T = X(O);
          return (
            (0, W.assertArgument)(
              !O.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || T === O,
              "bad address checksum",
              "address",
              O
            ),
            T
          );
        }
        if (O.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
          (0, W.assertArgument)(
            O.substring(2, 4) === er(O),
            "bad icap checksum",
            "address",
            O
          );
          let T = es(O.substring(4)).toString(16);
          for (; T.length < 40; ) T = "0" + T;
          return X("0x" + T);
        }
        (0, W.assertArgument)(!1, "invalid address", "address", O);
      }
      function ea(O) {
        let T = BigInt(ei(O)).toString(36).toUpperCase();
        for (; T.length < 30; ) T = "0" + T;
        return "XE" + er("XE00" + T) + T;
      }
      (T.getAddress = ei), (T.getIcapAddress = ea);
    },
    4448: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.resolveAddress = T.isAddress = T.isAddressable = void 0);
      let J = L(38478),
        W = L(41779);
      function Y(O) {
        return O && "function" == typeof O.getAddress;
      }
      function Z(O) {
        try {
          return (0, W.getAddress)(O), !0;
        } catch (O) {}
        return !1;
      }
      async function X(O, T) {
        let L = await T;
        return (
          (null == L || "0x0000000000000000000000000000000000000000" === L) &&
            ((0, J.assert)(
              "string" != typeof O,
              "unconfigured name",
              "UNCONFIGURED_NAME",
              { value: O }
            ),
            (0, J.assertArgument)(
              !1,
              "invalid AddressLike value; did not resolve to a value address",
              "target",
              O
            )),
          (0, W.getAddress)(L)
        );
      }
      function ee(O, T) {
        return "string" == typeof O
          ? O.match(/^0x[0-9a-f]{40}$/i)
            ? (0, W.getAddress)(O)
            : ((0, J.assert)(
                null != T,
                "ENS resolution requires a provider",
                "UNSUPPORTED_OPERATION",
                { operation: "resolveName" }
              ),
              X(O, T.resolveName(O)))
          : Y(O)
          ? X(O, O.getAddress())
          : O && "function" == typeof O.then
          ? X(O, O)
          : void (0, J.assertArgument)(
              !1,
              "unsupported addressable value",
              "target",
              O
            );
      }
      (T.isAddressable = Y), (T.isAddress = Z), (T.resolveAddress = ee);
    },
    68260: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.getCreate2Address = T.getCreateAddress = void 0);
      let J = L(3382),
        W = L(38478),
        Y = L(41779);
      function Z(O) {
        let T = (0, Y.getAddress)(O.from),
          L = (0, W.getBigInt)(O.nonce, "tx.nonce").toString(16);
        return (
          (L = "0" === L ? "0x" : L.length % 2 ? "0x0" + L : "0x" + L),
          (0, Y.getAddress)(
            (0, W.dataSlice)((0, J.keccak256)((0, W.encodeRlp)([T, L])), 12)
          )
        );
      }
      function X(O, T, L) {
        let Z = (0, Y.getAddress)(O),
          X = (0, W.getBytes)(T, "salt"),
          ee = (0, W.getBytes)(L, "initCodeHash");
        return (
          (0, W.assertArgument)(
            32 === X.length,
            "salt must be 32 bytes",
            "salt",
            T
          ),
          (0, W.assertArgument)(
            32 === ee.length,
            "initCodeHash must be 32 bytes",
            "initCodeHash",
            L
          ),
          (0, Y.getAddress)(
            (0, W.dataSlice)(
              (0, J.keccak256)((0, W.concat)(["0xff", Z, X, ee])),
              12
            )
          )
        );
      }
      (T.getCreateAddress = Z), (T.getCreate2Address = X);
    },
    40431: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.resolveAddress =
          T.isAddress =
          T.isAddressable =
          T.getCreate2Address =
          T.getCreateAddress =
          T.getIcapAddress =
          T.getAddress =
            void 0);
      var J = L(41779);
      Object.defineProperty(T, "getAddress", {
        enumerable: !0,
        get: function () {
          return J.getAddress;
        },
      }),
        Object.defineProperty(T, "getIcapAddress", {
          enumerable: !0,
          get: function () {
            return J.getIcapAddress;
          },
        });
      var W = L(68260);
      Object.defineProperty(T, "getCreateAddress", {
        enumerable: !0,
        get: function () {
          return W.getCreateAddress;
        },
      }),
        Object.defineProperty(T, "getCreate2Address", {
          enumerable: !0,
          get: function () {
            return W.getCreate2Address;
          },
        });
      var Y = L(4448);
      Object.defineProperty(T, "isAddressable", {
        enumerable: !0,
        get: function () {
          return Y.isAddressable;
        },
      }),
        Object.defineProperty(T, "isAddress", {
          enumerable: !0,
          get: function () {
            return Y.isAddress;
          },
        }),
        Object.defineProperty(T, "resolveAddress", {
          enumerable: !0,
          get: function () {
            return Y.resolveAddress;
          },
        });
    },
    11654: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ZeroAddress = void 0),
        (T.ZeroAddress = "0x0000000000000000000000000000000000000000");
    },
    42852: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ZeroHash = void 0),
        (T.ZeroHash =
          "0x0000000000000000000000000000000000000000000000000000000000000000");
    },
    98148: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.MessagePrefix =
          T.EtherSymbol =
          T.MaxInt256 =
          T.MinInt256 =
          T.MaxUint256 =
          T.WeiPerEther =
          T.N =
          T.ZeroHash =
          T.ZeroAddress =
            void 0);
      var J = L(11654);
      Object.defineProperty(T, "ZeroAddress", {
        enumerable: !0,
        get: function () {
          return J.ZeroAddress;
        },
      });
      var W = L(42852);
      Object.defineProperty(T, "ZeroHash", {
        enumerable: !0,
        get: function () {
          return W.ZeroHash;
        },
      });
      var Y = L(63508);
      Object.defineProperty(T, "N", {
        enumerable: !0,
        get: function () {
          return Y.N;
        },
      }),
        Object.defineProperty(T, "WeiPerEther", {
          enumerable: !0,
          get: function () {
            return Y.WeiPerEther;
          },
        }),
        Object.defineProperty(T, "MaxUint256", {
          enumerable: !0,
          get: function () {
            return Y.MaxUint256;
          },
        }),
        Object.defineProperty(T, "MinInt256", {
          enumerable: !0,
          get: function () {
            return Y.MinInt256;
          },
        }),
        Object.defineProperty(T, "MaxInt256", {
          enumerable: !0,
          get: function () {
            return Y.MaxInt256;
          },
        });
      var Z = L(27887);
      Object.defineProperty(T, "EtherSymbol", {
        enumerable: !0,
        get: function () {
          return Z.EtherSymbol;
        },
      }),
        Object.defineProperty(T, "MessagePrefix", {
          enumerable: !0,
          get: function () {
            return Z.MessagePrefix;
          },
        });
    },
    63508: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.MaxInt256 =
          T.MinInt256 =
          T.MaxUint256 =
          T.WeiPerEther =
          T.N =
            void 0),
        (T.N = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        )),
        (T.WeiPerEther = BigInt("1000000000000000000")),
        (T.MaxUint256 = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        )),
        (T.MinInt256 =
          BigInt(
            "0x8000000000000000000000000000000000000000000000000000000000000000"
          ) * BigInt(-1)),
        (T.MaxInt256 = BigInt(
          "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        ));
    },
    27887: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.MessagePrefix = T.EtherSymbol = void 0),
        (T.EtherSymbol = ""),
        (T.MessagePrefix = "\x19Ethereum Signed Message:\n");
    },
    13672: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Contract =
          T.BaseContract =
          T.resolveArgs =
          T.copyOverrides =
            void 0);
      let J = L(16330),
        W = L(40431),
        Y = L(27773),
        Z = L(38478),
        X = L(35788),
        ee = BigInt(0);
      function et(O) {
        return O && "function" == typeof O.call;
      }
      function er(O) {
        return O && "function" == typeof O.estimateGas;
      }
      function en(O) {
        return O && "function" == typeof O.resolveName;
      }
      function es(O) {
        return O && "function" == typeof O.sendTransaction;
      }
      function ei(O) {
        if (null != O) {
          if (en(O)) return O;
          if (O.provider) return O.provider;
        }
      }
      class ea {
        constructor(O, T, L) {
          if (
            ((0, Z.defineProperties)(this, { fragment: T }),
            T.inputs.length < L.length)
          )
            throw Error("too many arguments");
          let J = eo(O.runner, "resolveName"),
            Y = en(J) ? J : null;
          this.v__0 = (async function () {
            let J = await Promise.all(
              T.inputs.map((O, T) =>
                null == L[T]
                  ? null
                  : O.walkAsync(L[T], (O, T) =>
                      "address" === O
                        ? Array.isArray(T)
                          ? Promise.all(
                              T.map((O) => (0, W.resolveAddress)(O, Y))
                            )
                          : (0, W.resolveAddress)(T, Y)
                        : T
                    )
              )
            );
            return O.interface.encodeFilterTopics(T, J);
          })();
        }
        getTopicFilter() {
          return this.v__0;
        }
      }
      function eo(O, T) {
        return null == O
          ? null
          : "function" == typeof O[T]
          ? O
          : O.provider && "function" == typeof O.provider[T]
          ? O.provider
          : null;
      }
      function ec(O) {
        return null == O ? null : O.provider || null;
      }
      async function eu(O, T) {
        let L = J.Typed.dereference(O, "overrides");
        (0, Z.assertArgument)(
          "object" == typeof L,
          "invalid overrides parameter",
          "overrides",
          O
        );
        let W = (0, Y.copyRequest)(L);
        return (
          (0, Z.assertArgument)(
            null == W.to || (T || []).indexOf("to") >= 0,
            "cannot override to",
            "overrides.to",
            W.to
          ),
          (0, Z.assertArgument)(
            null == W.data || (T || []).indexOf("data") >= 0,
            "cannot override data",
            "overrides.data",
            W.data
          ),
          W.from && (W.from = W.from),
          W
        );
      }
      async function eh(O, T, L) {
        let Y = eo(O, "resolveName"),
          Z = en(Y) ? Y : null;
        return await Promise.all(
          T.map((O, T) =>
            O.walkAsync(L[T], (O, T) =>
              ((T = J.Typed.dereference(T, O)), "address" === O)
                ? (0, W.resolveAddress)(T, Z)
                : T
            )
          )
        );
      }
      function ed(O) {
        let T = async function (T) {
            let L = await eu(T, ["data"]);
            (L.to = await O.getAddress()),
              L.from &&
                (L.from = await (0, W.resolveAddress)(L.from, ei(O.runner)));
            let J = O.interface,
              Y = (0, Z.getBigInt)(L.value || ee, "overrides.value") === ee,
              X = "0x" === (L.data || "0x");
            !J.fallback ||
              J.fallback.payable ||
              !J.receive ||
              X ||
              Y ||
              (0, Z.assertArgument)(
                !1,
                "cannot send data to receive or send value to non-payable fallback",
                "overrides",
                T
              ),
              (0, Z.assertArgument)(
                J.fallback || X,
                "cannot send data to receive-only contract",
                "overrides.data",
                L.data
              );
            let et = J.receive || (J.fallback && J.fallback.payable);
            return (
              (0, Z.assertArgument)(
                et || Y,
                "cannot send value to non-payable fallback",
                "overrides.value",
                L.value
              ),
              (0, Z.assertArgument)(
                J.fallback || X,
                "cannot send data to receive-only contract",
                "overrides.data",
                L.data
              ),
              L
            );
          },
          L = async function (L) {
            let J = eo(O.runner, "call");
            (0, Z.assert)(
              et(J),
              "contract runner does not support calling",
              "UNSUPPORTED_OPERATION",
              { operation: "call" }
            );
            let W = await T(L);
            try {
              return await J.call(W);
            } catch (T) {
              if ((0, Z.isCallException)(T) && T.data)
                throw O.interface.makeError(T.data, W);
              throw T;
            }
          },
          J = async function (L) {
            let J = O.runner;
            (0, Z.assert)(
              es(J),
              "contract runner does not support sending transactions",
              "UNSUPPORTED_OPERATION",
              { operation: "sendTransaction" }
            );
            let W = await J.sendTransaction(await T(L)),
              Y = ec(O.runner);
            return new X.ContractTransactionResponse(O.interface, Y, W);
          },
          Y = async function (L) {
            let J = eo(O.runner, "estimateGas");
            return (
              (0, Z.assert)(
                er(J),
                "contract runner does not support gas estimation",
                "UNSUPPORTED_OPERATION",
                { operation: "estimateGas" }
              ),
              await J.estimateGas(await T(L))
            );
          },
          en = async (O) => await J(O);
        return (
          (0, Z.defineProperties)(en, {
            _contract: O,
            estimateGas: Y,
            populateTransaction: T,
            send: J,
            staticCall: L,
          }),
          en
        );
      }
      function ep(O, T) {
        let L = function (...L) {
            let J = O.interface.getFunction(T, L);
            return (
              (0, Z.assert)(
                J,
                "no matching fragment",
                "UNSUPPORTED_OPERATION",
                { operation: "fragment", info: { key: T, args: L } }
              ),
              J
            );
          },
          J = async function (...T) {
            let J = L(...T),
              Y = {};
            if (
              (J.inputs.length + 1 === T.length &&
                (Y = await eu(T.pop())).from &&
                (Y.from = await (0, W.resolveAddress)(Y.from, ei(O.runner))),
              J.inputs.length !== T.length)
            )
              throw Error(
                "internal error: fragment inputs doesn't match arguments; should not happen"
              );
            let X = await eh(O.runner, J.inputs, T);
            return Object.assign(
              {},
              Y,
              await (0, Z.resolveProperties)({
                to: O.getAddress(),
                data: O.interface.encodeFunctionData(J, X),
              })
            );
          },
          Y = async function (...O) {
            let T = await ea(...O);
            return 1 === T.length ? T[0] : T;
          },
          ee = async function (...T) {
            let L = O.runner;
            (0, Z.assert)(
              es(L),
              "contract runner does not support sending transactions",
              "UNSUPPORTED_OPERATION",
              { operation: "sendTransaction" }
            );
            let W = await L.sendTransaction(await J(...T)),
              Y = ec(O.runner);
            return new X.ContractTransactionResponse(O.interface, Y, W);
          },
          en = async function (...T) {
            let L = eo(O.runner, "estimateGas");
            return (
              (0, Z.assert)(
                er(L),
                "contract runner does not support gas estimation",
                "UNSUPPORTED_OPERATION",
                { operation: "estimateGas" }
              ),
              await L.estimateGas(await J(...T))
            );
          },
          ea = async function (...T) {
            let W = eo(O.runner, "call");
            (0, Z.assert)(
              et(W),
              "contract runner does not support calling",
              "UNSUPPORTED_OPERATION",
              { operation: "call" }
            );
            let Y = await J(...T),
              X = "0x";
            try {
              X = await W.call(Y);
            } catch (T) {
              if ((0, Z.isCallException)(T) && T.data)
                throw O.interface.makeError(T.data, Y);
              throw T;
            }
            let ee = L(...T);
            return O.interface.decodeFunctionResult(ee, X);
          },
          ed = async (...O) =>
            L(...O).constant ? await Y(...O) : await ee(...O);
        return (
          (0, Z.defineProperties)(ed, {
            name: O.interface.getFunctionName(T),
            _contract: O,
            _key: T,
            getFragment: L,
            estimateGas: en,
            populateTransaction: J,
            send: ee,
            staticCall: Y,
            staticCallResult: ea,
          }),
          Object.defineProperty(ed, "fragment", {
            configurable: !1,
            enumerable: !0,
            get: () => {
              let L = O.interface.getFunction(T);
              return (
                (0, Z.assert)(
                  L,
                  "no matching fragment",
                  "UNSUPPORTED_OPERATION",
                  { operation: "fragment", info: { key: T } }
                ),
                L
              );
            },
          }),
          ed
        );
      }
      function eg(O, T) {
        let L = function (...L) {
            let J = O.interface.getEvent(T, L);
            return (
              (0, Z.assert)(
                J,
                "no matching fragment",
                "UNSUPPORTED_OPERATION",
                { operation: "fragment", info: { key: T, args: L } }
              ),
              J
            );
          },
          J = function (...T) {
            return new ea(O, L(...T), T);
          };
        return (
          (0, Z.defineProperties)(J, {
            name: O.interface.getEventName(T),
            _contract: O,
            _key: T,
            getFragment: L,
          }),
          Object.defineProperty(J, "fragment", {
            configurable: !1,
            enumerable: !0,
            get: () => {
              let L = O.interface.getEvent(T);
              return (
                (0, Z.assert)(
                  L,
                  "no matching fragment",
                  "UNSUPPORTED_OPERATION",
                  { operation: "fragment", info: { key: T } }
                ),
                L
              );
            },
          }),
          J
        );
      }
      (T.copyOverrides = eu), (T.resolveArgs = eh);
      let ey = Symbol.for("_ethersInternal_contract"),
        em = new WeakMap();
      function eb(O, T) {
        em.set(O[ey], T);
      }
      function eA(O) {
        return em.get(O[ey]);
      }
      function ew(O) {
        return (
          O &&
          "object" == typeof O &&
          "getTopicFilter" in O &&
          "function" == typeof O.getTopicFilter &&
          O.fragment
        );
      }
      async function ev(O, T) {
        let L;
        let J = null;
        if (Array.isArray(T)) {
          let J = function (T) {
            if ((0, Z.isHexString)(T, 32)) return T;
            let L = O.interface.getEvent(T);
            return (
              (0, Z.assertArgument)(L, "unknown fragment", "name", T),
              L.topicHash
            );
          };
          L = T.map((O) =>
            null == O ? null : Array.isArray(O) ? O.map(J) : J(O)
          );
        } else
          "*" === T
            ? (L = [null])
            : "string" == typeof T
            ? (0, Z.isHexString)(T, 32)
              ? (L = [T])
              : ((J = O.interface.getEvent(T)),
                (0, Z.assertArgument)(J, "unknown fragment", "event", T),
                (L = [J.topicHash]))
            : ew(T)
            ? (L = await T.getTopicFilter())
            : "fragment" in T
            ? (L = [(J = T.fragment).topicHash])
            : (0, Z.assertArgument)(!1, "unknown event name", "event", T);
        return {
          fragment: J,
          tag: (L = L.map((O) => {
            if (null == O) return null;
            if (Array.isArray(O)) {
              let T = Array.from(
                new Set(O.map((O) => O.toLowerCase())).values()
              );
              return 1 === T.length ? T[0] : (T.sort(), T);
            }
            return O.toLowerCase();
          }))
            .map((O) =>
              null == O ? "null" : Array.isArray(O) ? O.join("|") : O
            )
            .join("&"),
          topics: L,
        };
      }
      async function ek(O, T) {
        let { subs: L } = eA(O);
        return L.get((await ev(O, T)).tag) || null;
      }
      async function eE(O, T, L) {
        let J = ec(O.runner);
        (0, Z.assert)(
          J,
          "contract runner does not support subscribing",
          "UNSUPPORTED_OPERATION",
          { operation: T }
        );
        let { fragment: W, tag: Y, topics: ee } = await ev(O, L),
          { addr: et, subs: er } = eA(O),
          en = er.get(Y);
        if (!en) {
          let T = { address: et || O, topics: ee },
            Z = (T) => {
              let J = W;
              if (null == J)
                try {
                  J = O.interface.getEvent(T.topics[0]);
                } catch (O) {}
              if (J) {
                let Y = J,
                  Z = W ? O.interface.decodeEventLog(W, T.data, T.topics) : [];
                eC(O, L, Z, (J) => new X.ContractEventPayload(O, J, L, Y, T));
              } else
                eC(
                  O,
                  L,
                  [],
                  (J) => new X.ContractUnknownEventPayload(O, J, L, T)
                );
            },
            es = [];
          (en = {
            tag: Y,
            listeners: [],
            start: () => {
              es.length || es.push(J.on(T, Z));
            },
            stop: async () => {
              if (0 == es.length) return;
              let O = es;
              (es = []), await Promise.all(O), J.off(T, Z);
            },
          }),
            er.set(Y, en);
        }
        return en;
      }
      let eS = Promise.resolve();
      async function eP(O, T, L, J) {
        await eS;
        let W = await ek(O, T);
        if (!W) return !1;
        let Y = W.listeners.length;
        return (
          (W.listeners = W.listeners.filter(({ listener: T, once: W }) => {
            let Y = Array.from(L);
            J && Y.push(J(W ? null : T));
            try {
              T.call(O, ...Y);
            } catch (O) {}
            return !W;
          })),
          0 === W.listeners.length && (W.stop(), eA(O).subs.delete(W.tag)),
          Y > 0
        );
      }
      async function eC(O, T, L, J) {
        try {
          await eS;
        } catch (O) {}
        let W = eP(O, T, L, J);
        return (eS = W), await W;
      }
      let eB = ["then"];
      class eO {
        constructor(O, T, L, Y) {
          let ee;
          (0, Z.assertArgument)(
            "string" == typeof O || (0, W.isAddressable)(O),
            "invalid value for Contract target",
            "target",
            O
          ),
            null == L && (L = null);
          let et = J.Interface.from(T);
          (0, Z.defineProperties)(this, {
            target: O,
            runner: L,
            interface: et,
          }),
            Object.defineProperty(this, ey, { value: {} });
          let er = null,
            es = null;
          if (Y) {
            let O = ec(L);
            es = new X.ContractTransactionResponse(this.interface, O, Y);
          }
          let ei = new Map();
          if ("string" == typeof O) {
            if ((0, Z.isHexString)(O)) (er = O), (ee = Promise.resolve(O));
            else {
              let T = eo(L, "resolveName");
              if (!en(T))
                throw (0, Z.makeError)(
                  "contract runner does not support name resolution",
                  "UNSUPPORTED_OPERATION",
                  { operation: "resolveName" }
                );
              ee = T.resolveName(O).then((T) => {
                if (null == T)
                  throw (0, Z.makeError)(
                    "an ENS name used for a contract target must be correctly configured",
                    "UNCONFIGURED_NAME",
                    { value: O }
                  );
                return (eA(this).addr = T), T;
              });
            }
          } else
            ee = O.getAddress().then((O) => {
              if (null == O) throw Error("TODO");
              return (eA(this).addr = O), O;
            });
          eb(this, { addrPromise: ee, addr: er, deployTx: es, subs: ei });
          let ea = new Proxy(
            {},
            {
              get: (O, T, L) => {
                if ("symbol" == typeof T || eB.indexOf(T) >= 0)
                  return Reflect.get(O, T, L);
                try {
                  return this.getEvent(T);
                } catch (O) {
                  if (
                    !(0, Z.isError)(O, "INVALID_ARGUMENT") ||
                    "key" !== O.argument
                  )
                    throw O;
                }
              },
              has: (O, T) =>
                eB.indexOf(T) >= 0
                  ? Reflect.has(O, T)
                  : Reflect.has(O, T) || this.interface.hasEvent(String(T)),
            }
          );
          return (
            (0, Z.defineProperties)(this, { filters: ea }),
            (0, Z.defineProperties)(this, {
              fallback: et.receive || et.fallback ? ed(this) : null,
            }),
            new Proxy(this, {
              get: (O, T, L) => {
                if ("symbol" == typeof T || T in O || eB.indexOf(T) >= 0)
                  return Reflect.get(O, T, L);
                try {
                  return O.getFunction(T);
                } catch (O) {
                  if (
                    !(0, Z.isError)(O, "INVALID_ARGUMENT") ||
                    "key" !== O.argument
                  )
                    throw O;
                }
              },
              has: (O, T) =>
                "symbol" == typeof T || T in O || eB.indexOf(T) >= 0
                  ? Reflect.has(O, T)
                  : O.interface.hasFunction(T),
            })
          );
        }
        connect(O) {
          return new eO(this.target, this.interface, O);
        }
        attach(O) {
          return new eO(O, this.interface, this.runner);
        }
        async getAddress() {
          return await eA(this).addrPromise;
        }
        async getDeployedCode() {
          let O = ec(this.runner);
          (0, Z.assert)(
            O,
            "runner does not support .provider",
            "UNSUPPORTED_OPERATION",
            { operation: "getDeployedCode" }
          );
          let T = await O.getCode(await this.getAddress());
          return "0x" === T ? null : T;
        }
        async waitForDeployment() {
          let O = this.deploymentTransaction();
          if (O) return await O.wait(), this;
          if (null != (await this.getDeployedCode())) return this;
          let T = ec(this.runner);
          return (
            (0, Z.assert)(
              null != T,
              "contract runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "waitForDeployment" }
            ),
            new Promise((O, L) => {
              let J = async () => {
                try {
                  let L = await this.getDeployedCode();
                  if (null != L) return O(this);
                  T.once("block", J);
                } catch (O) {
                  L(O);
                }
              };
              J();
            })
          );
        }
        deploymentTransaction() {
          return eA(this).deployTx;
        }
        getFunction(O) {
          return "string" != typeof O && (O = O.format()), ep(this, O);
        }
        getEvent(O) {
          return "string" != typeof O && (O = O.format()), eg(this, O);
        }
        async queryTransaction(O) {
          throw Error("@TODO");
        }
        async queryFilter(O, T, L) {
          null == T && (T = 0), null == L && (L = "latest");
          let { addr: J, addrPromise: W } = eA(this),
            ee = J || (await W),
            { fragment: et, topics: er } = await ev(this, O),
            en = { address: ee, topics: er, fromBlock: T, toBlock: L },
            es = ec(this.runner);
          return (
            (0, Z.assert)(
              es,
              "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION",
              { operation: "queryFilter" }
            ),
            (await es.getLogs(en)).map((O) => {
              let T = et;
              if (null == T)
                try {
                  T = this.interface.getEvent(O.topics[0]);
                } catch (O) {}
              if (T)
                try {
                  return new X.EventLog(O, this.interface, T);
                } catch (T) {
                  return new X.UndecodedEventLog(O, T);
                }
              return new Y.Log(O, es);
            })
          );
        }
        async on(O, T) {
          let L = await eE(this, "on", O);
          return L.listeners.push({ listener: T, once: !1 }), L.start(), this;
        }
        async once(O, T) {
          let L = await eE(this, "once", O);
          return L.listeners.push({ listener: T, once: !0 }), L.start(), this;
        }
        async emit(O, ...T) {
          return await eC(this, O, T, null);
        }
        async listenerCount(O) {
          if (O) {
            let T = await ek(this, O);
            return T ? T.listeners.length : 0;
          }
          let { subs: T } = eA(this),
            L = 0;
          for (let { listeners: O } of T.values()) L += O.length;
          return L;
        }
        async listeners(O) {
          if (O) {
            let T = await ek(this, O);
            return T ? T.listeners.map(({ listener: O }) => O) : [];
          }
          let { subs: T } = eA(this),
            L = [];
          for (let { listeners: O } of T.values())
            L = L.concat(O.map(({ listener: O }) => O));
          return L;
        }
        async off(O, T) {
          let L = await ek(this, O);
          if (!L) return this;
          if (T) {
            let O = L.listeners.map(({ listener: O }) => O).indexOf(T);
            O >= 0 && L.listeners.splice(O, 1);
          }
          return (
            (null == T || 0 === L.listeners.length) &&
              (L.stop(), eA(this).subs.delete(L.tag)),
            this
          );
        }
        async removeAllListeners(O) {
          if (O) {
            let T = await ek(this, O);
            if (!T) return this;
            T.stop(), eA(this).subs.delete(T.tag);
          } else {
            let { subs: O } = eA(this);
            for (let { tag: T, stop: L } of O.values()) L(), O.delete(T);
          }
          return this;
        }
        async addListener(O, T) {
          return await this.on(O, T);
        }
        async removeListener(O, T) {
          return await this.off(O, T);
        }
        static buildClass(O) {
          class T extends eO {
            constructor(T, L = null) {
              super(T, O, L);
            }
          }
          return T;
        }
        static from(O, T, L) {
          return null == L && (L = null), new this(O, T, L);
        }
      }
      function eT() {
        return eO;
      }
      T.BaseContract = eO;
      class eN extends eT() {}
      T.Contract = eN;
    },
    21: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ContractFactory = void 0);
      let J = L(16330),
        W = L(40431),
        Y = L(38478),
        Z = L(13672);
      class X {
        constructor(O, T, L) {
          let W = J.Interface.from(O);
          T instanceof Uint8Array ||
            ("object" == typeof T && (T = T.object),
            T.startsWith("0x") || (T = "0x" + T)),
            (T = (0, Y.hexlify)((0, Y.getBytes)(T))),
            (0, Y.defineProperties)(this, {
              bytecode: T,
              interface: W,
              runner: L || null,
            });
        }
        attach(O) {
          return new Z.BaseContract(O, this.interface, this.runner);
        }
        async getDeployTransaction(...O) {
          let T = {},
            L = this.interface.deploy;
          if (
            (L.inputs.length + 1 === O.length &&
              (T = await (0, Z.copyOverrides)(O.pop())),
            L.inputs.length !== O.length)
          )
            throw Error("incorrect number of arguments to constructor");
          let J = await (0, Z.resolveArgs)(this.runner, L.inputs, O);
          return Object.assign({}, T, {
            data: (0, Y.concat)([
              this.bytecode,
              this.interface.encodeDeploy(J),
            ]),
          });
        }
        async deploy(...O) {
          let T = await this.getDeployTransaction(...O);
          (0, Y.assert)(
            this.runner && "function" == typeof this.runner.sendTransaction,
            "factory runner does not support sending transactions",
            "UNSUPPORTED_OPERATION",
            { operation: "sendTransaction" }
          );
          let L = await this.runner.sendTransaction(T),
            J = (0, W.getCreateAddress)(L);
          return new Z.BaseContract(J, this.interface, this.runner, L);
        }
        connect(O) {
          return new X(this.interface, this.bytecode, O);
        }
        static fromSolidity(O, T) {
          (0, Y.assertArgument)(null != O, "bad compiler output", "output", O),
            "string" == typeof O && (O = JSON.parse(O));
          let L = O.abi,
            J = "";
          return (
            O.bytecode
              ? (J = O.bytecode)
              : O.evm && O.evm.bytecode && (J = O.evm.bytecode),
            new this(L, J, T)
          );
        }
      }
      T.ContractFactory = X;
    },
    15311: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.UndecodedEventLog =
          T.EventLog =
          T.ContractTransactionResponse =
          T.ContractTransactionReceipt =
          T.ContractUnknownEventPayload =
          T.ContractEventPayload =
          T.ContractFactory =
          T.Contract =
          T.BaseContract =
            void 0);
      var J = L(13672);
      Object.defineProperty(T, "BaseContract", {
        enumerable: !0,
        get: function () {
          return J.BaseContract;
        },
      }),
        Object.defineProperty(T, "Contract", {
          enumerable: !0,
          get: function () {
            return J.Contract;
          },
        });
      var W = L(21);
      Object.defineProperty(T, "ContractFactory", {
        enumerable: !0,
        get: function () {
          return W.ContractFactory;
        },
      });
      var Y = L(35788);
      Object.defineProperty(T, "ContractEventPayload", {
        enumerable: !0,
        get: function () {
          return Y.ContractEventPayload;
        },
      }),
        Object.defineProperty(T, "ContractUnknownEventPayload", {
          enumerable: !0,
          get: function () {
            return Y.ContractUnknownEventPayload;
          },
        }),
        Object.defineProperty(T, "ContractTransactionReceipt", {
          enumerable: !0,
          get: function () {
            return Y.ContractTransactionReceipt;
          },
        }),
        Object.defineProperty(T, "ContractTransactionResponse", {
          enumerable: !0,
          get: function () {
            return Y.ContractTransactionResponse;
          },
        }),
        Object.defineProperty(T, "EventLog", {
          enumerable: !0,
          get: function () {
            return Y.EventLog;
          },
        }),
        Object.defineProperty(T, "UndecodedEventLog", {
          enumerable: !0,
          get: function () {
            return Y.UndecodedEventLog;
          },
        });
    },
    35788: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ContractEventPayload =
          T.ContractUnknownEventPayload =
          T.ContractTransactionResponse =
          T.ContractTransactionReceipt =
          T.UndecodedEventLog =
          T.EventLog =
            void 0);
      let J = L(27773),
        W = L(38478);
      class Y extends J.Log {
        constructor(O, T, L) {
          super(O, O.provider);
          let J = T.decodeEventLog(L, O.data, O.topics);
          (0, W.defineProperties)(this, { args: J, fragment: L, interface: T });
        }
        get eventName() {
          return this.fragment.name;
        }
        get eventSignature() {
          return this.fragment.format();
        }
      }
      T.EventLog = Y;
      class Z extends J.Log {
        constructor(O, T) {
          super(O, O.provider), (0, W.defineProperties)(this, { error: T });
        }
      }
      T.UndecodedEventLog = Z;
      class X extends J.TransactionReceipt {
        constructor(O, T, L) {
          super(L, T), (this.k__0 = O);
        }
        get logs() {
          return super.logs.map((O) => {
            let T = O.topics.length ? this.k__0.getEvent(O.topics[0]) : null;
            if (T)
              try {
                return new Y(O, this.k__0, T);
              } catch (T) {
                return new Z(O, T);
              }
            return O;
          });
        }
      }
      T.ContractTransactionReceipt = X;
      class ee extends J.TransactionResponse {
        constructor(O, T, L) {
          super(L, T), (this.k__0 = O);
        }
        async wait(O, T) {
          let L = await super.wait(O, T);
          return null == L ? null : new X(this.k__0, this.provider, L);
        }
      }
      T.ContractTransactionResponse = ee;
      class et extends W.EventPayload {
        constructor(O, T, L, J) {
          super(O, T, L), (0, W.defineProperties)(this, { log: J });
        }
        async getBlock() {
          return await this.log.getBlock();
        }
        async getTransaction() {
          return await this.log.getTransaction();
        }
        async getTransactionReceipt() {
          return await this.log.getTransactionReceipt();
        }
      }
      T.ContractUnknownEventPayload = et;
      class er extends et {
        constructor(O, T, L, J, Z) {
          super(O, T, L, new Y(Z, O.interface, J));
          let X = O.interface.decodeEventLog(J, this.log.data, this.log.topics);
          (0, W.defineProperties)(this, { args: X, fragment: J });
        }
        get eventName() {
          return this.fragment.name;
        }
        get eventSignature() {
          return this.fragment.format();
        }
      }
      T.ContractEventPayload = er;
    },
    98928: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.randomBytes = T.pbkdf2Sync = T.createHmac = T.createHash = void 0);
      let J = L(8692),
        W = L(28187),
        Y = L(93782),
        Z = L(60626),
        X = L(38478),
        ee = (function () {
          if ("undefined" != typeof self) return self;
          if ("undefined" != typeof window) return window;
          if (void 0 !== L.g) return L.g;
          throw Error("unable to locate global object");
        })(),
        et = ee.crypto || ee.msCrypto;
      function er(O) {
        switch (O) {
          case "sha256":
            return Y.sha256.create();
          case "sha512":
            return Z.sha512.create();
        }
        (0, X.assertArgument)(
          !1,
          "invalid hashing algorithm name",
          "algorithm",
          O
        );
      }
      function en(O, T) {
        let L = { sha256: Y.sha256, sha512: Z.sha512 }[O];
        return (
          (0, X.assertArgument)(
            null != L,
            "invalid hmac algorithm",
            "algorithm",
            O
          ),
          J.hmac.create(L, T)
        );
      }
      function es(O, T, L, J, ee) {
        let et = { sha256: Y.sha256, sha512: Z.sha512 }[ee];
        return (
          (0, X.assertArgument)(
            null != et,
            "invalid pbkdf2 algorithm",
            "algorithm",
            ee
          ),
          (0, W.pbkdf2)(et, O, T, { c: L, dkLen: J })
        );
      }
      function ei(O) {
        (0, X.assert)(
          null != et,
          "platform does not support secure random numbers",
          "UNSUPPORTED_OPERATION",
          { operation: "randomBytes" }
        ),
          (0, X.assertArgument)(
            Number.isInteger(O) && O > 0 && O <= 1024,
            "invalid length",
            "length",
            O
          );
        let T = new Uint8Array(O);
        return et.getRandomValues(T), T;
      }
      (T.createHash = er),
        (T.createHmac = en),
        (T.pbkdf2Sync = es),
        (T.randomBytes = ei);
    },
    69297: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.computeHmac = void 0);
      let J = L(98928),
        W = L(38478),
        Y = !1,
        Z = function (O, T, L) {
          return (0, J.createHmac)(O, T).update(L).digest();
        },
        X = Z;
      function ee(O, T, L) {
        let J = (0, W.getBytes)(T, "key"),
          Y = (0, W.getBytes)(L, "data");
        return (0, W.hexlify)(X(O, J, Y));
      }
      (T.computeHmac = ee),
        (ee._ = Z),
        (ee.lock = function () {
          Y = !0;
        }),
        (ee.register = function (O) {
          if (Y) throw Error("computeHmac is locked");
          X = O;
        }),
        Object.freeze(ee);
    },
    3382: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.lock =
          T.Signature =
          T.SigningKey =
          T.scryptSync =
          T.scrypt =
          T.pbkdf2 =
          T.sha512 =
          T.sha256 =
          T.ripemd160 =
          T.keccak256 =
          T.randomBytes =
          T.computeHmac =
            void 0);
      let J = L(69297);
      Object.defineProperty(T, "computeHmac", {
        enumerable: !0,
        get: function () {
          return J.computeHmac;
        },
      });
      let W = L(17528);
      Object.defineProperty(T, "keccak256", {
        enumerable: !0,
        get: function () {
          return W.keccak256;
        },
      });
      let Y = L(7587);
      Object.defineProperty(T, "ripemd160", {
        enumerable: !0,
        get: function () {
          return Y.ripemd160;
        },
      });
      let Z = L(58965);
      Object.defineProperty(T, "pbkdf2", {
        enumerable: !0,
        get: function () {
          return Z.pbkdf2;
        },
      });
      let X = L(23800);
      Object.defineProperty(T, "randomBytes", {
        enumerable: !0,
        get: function () {
          return X.randomBytes;
        },
      });
      let ee = L(77021);
      Object.defineProperty(T, "scrypt", {
        enumerable: !0,
        get: function () {
          return ee.scrypt;
        },
      }),
        Object.defineProperty(T, "scryptSync", {
          enumerable: !0,
          get: function () {
            return ee.scryptSync;
          },
        });
      let et = L(14156);
      Object.defineProperty(T, "sha256", {
        enumerable: !0,
        get: function () {
          return et.sha256;
        },
      }),
        Object.defineProperty(T, "sha512", {
          enumerable: !0,
          get: function () {
            return et.sha512;
          },
        });
      var er = L(11726);
      Object.defineProperty(T, "SigningKey", {
        enumerable: !0,
        get: function () {
          return er.SigningKey;
        },
      });
      var en = L(94003);
      function es() {
        J.computeHmac.lock(),
          W.keccak256.lock(),
          Z.pbkdf2.lock(),
          X.randomBytes.lock(),
          Y.ripemd160.lock(),
          ee.scrypt.lock(),
          ee.scryptSync.lock(),
          et.sha256.lock(),
          et.sha512.lock(),
          X.randomBytes.lock();
      }
      Object.defineProperty(T, "Signature", {
        enumerable: !0,
        get: function () {
          return en.Signature;
        },
      }),
        (T.lock = es);
    },
    17528: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.keccak256 = void 0);
      let J = L(14816),
        W = L(38478),
        Y = !1,
        Z = function (O) {
          return (0, J.keccak_256)(O);
        },
        X = Z;
      function ee(O) {
        let T = (0, W.getBytes)(O, "data");
        return (0, W.hexlify)(X(T));
      }
      (T.keccak256 = ee),
        (ee._ = Z),
        (ee.lock = function () {
          Y = !0;
        }),
        (ee.register = function (O) {
          if (Y) throw TypeError("keccak256 is locked");
          X = O;
        }),
        Object.freeze(ee);
    },
    58965: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.pbkdf2 = void 0);
      let J = L(98928),
        W = L(38478),
        Y = !1,
        Z = function (O, T, L, W, Y) {
          return (0, J.pbkdf2Sync)(O, T, L, W, Y);
        },
        X = Z;
      function ee(O, T, L, J, Y) {
        let Z = (0, W.getBytes)(O, "password"),
          ee = (0, W.getBytes)(T, "salt");
        return (0, W.hexlify)(X(Z, ee, L, J, Y));
      }
      (T.pbkdf2 = ee),
        (ee._ = Z),
        (ee.lock = function () {
          Y = !0;
        }),
        (ee.register = function (O) {
          if (Y) throw Error("pbkdf2 is locked");
          X = O;
        }),
        Object.freeze(ee);
    },
    23800: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.randomBytes = void 0);
      let J = L(98928),
        W = !1,
        Y = function (O) {
          return new Uint8Array((0, J.randomBytes)(O));
        },
        Z = Y;
      function X(O) {
        return Z(O);
      }
      (T.randomBytes = X),
        (X._ = Y),
        (X.lock = function () {
          W = !0;
        }),
        (X.register = function (O) {
          if (W) throw Error("randomBytes is locked");
          Z = O;
        }),
        Object.freeze(X);
    },
    7587: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ripemd160 = void 0);
      let J = L(30341),
        W = L(38478),
        Y = !1,
        Z = function (O) {
          return (0, J.ripemd160)(O);
        },
        X = Z;
      function ee(O) {
        let T = (0, W.getBytes)(O, "data");
        return (0, W.hexlify)(X(T));
      }
      (T.ripemd160 = ee),
        (ee._ = Z),
        (ee.lock = function () {
          Y = !0;
        }),
        (ee.register = function (O) {
          if (Y) throw TypeError("ripemd160 is locked");
          X = O;
        }),
        Object.freeze(ee);
    },
    77021: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.scryptSync = T.scrypt = void 0);
      let J = L(43756),
        W = L(38478),
        Y = !1,
        Z = !1,
        X = async function (O, T, L, W, Y, Z, X) {
          return await (0, J.scryptAsync)(O, T, {
            N: L,
            r: W,
            p: Y,
            dkLen: Z,
            onProgress: X,
          });
        },
        ee = function (O, T, L, W, Y, Z) {
          return (0, J.scrypt)(O, T, { N: L, r: W, p: Y, dkLen: Z });
        },
        et = X,
        er = ee;
      async function en(O, T, L, J, Y, Z, X) {
        let ee = (0, W.getBytes)(O, "passwd"),
          er = (0, W.getBytes)(T, "salt");
        return (0, W.hexlify)(await et(ee, er, L, J, Y, Z, X));
      }
      function es(O, T, L, J, Y, Z) {
        let X = (0, W.getBytes)(O, "passwd"),
          ee = (0, W.getBytes)(T, "salt");
        return (0, W.hexlify)(er(X, ee, L, J, Y, Z));
      }
      (T.scrypt = en),
        (en._ = X),
        (en.lock = function () {
          Z = !0;
        }),
        (en.register = function (O) {
          if (Z) throw Error("scrypt is locked");
          et = O;
        }),
        Object.freeze(en),
        (T.scryptSync = es),
        (es._ = ee),
        (es.lock = function () {
          Y = !0;
        }),
        (es.register = function (O) {
          if (Y) throw Error("scryptSync is locked");
          er = O;
        }),
        Object.freeze(es);
    },
    14156: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.sha512 = T.sha256 = void 0);
      let J = L(98928),
        W = L(38478),
        Y = function (O) {
          return (0, J.createHash)("sha256").update(O).digest();
        },
        Z = function (O) {
          return (0, J.createHash)("sha512").update(O).digest();
        },
        X = Y,
        ee = Z,
        et = !1,
        er = !1;
      function en(O) {
        let T = (0, W.getBytes)(O, "data");
        return (0, W.hexlify)(X(T));
      }
      function es(O) {
        let T = (0, W.getBytes)(O, "data");
        return (0, W.hexlify)(ee(T));
      }
      (T.sha256 = en),
        (en._ = Y),
        (en.lock = function () {
          et = !0;
        }),
        (en.register = function (O) {
          if (et) throw Error("sha256 is locked");
          X = O;
        }),
        Object.freeze(en),
        (T.sha512 = es),
        (es._ = Z),
        (es.lock = function () {
          er = !0;
        }),
        (es.register = function (O) {
          if (er) throw Error("sha512 is locked");
          ee = O;
        }),
        Object.freeze(en);
    },
    94003: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Signature = void 0);
      let J = L(98148),
        W = L(38478),
        Y = BigInt(0),
        Z = BigInt(1),
        X = BigInt(2),
        ee = BigInt(27),
        et = BigInt(28),
        er = BigInt(35),
        en = {};
      function es(O) {
        return (0, W.zeroPadValue)((0, W.toBeArray)(O), 32);
      }
      class ei {
        get r() {
          return this.E__0;
        }
        set r(O) {
          (0, W.assertArgument)(
            32 === (0, W.dataLength)(O),
            "invalid r",
            "value",
            O
          ),
            (this.E__0 = (0, W.hexlify)(O));
        }
        get s() {
          return this.S__0;
        }
        set s(O) {
          (0, W.assertArgument)(
            32 === (0, W.dataLength)(O),
            "invalid s",
            "value",
            O
          );
          let T = (0, W.hexlify)(O);
          (0, W.assertArgument)(
            8 > parseInt(T.substring(0, 3)),
            "non-canonical s",
            "value",
            T
          ),
            (this.S__0 = T);
        }
        get v() {
          return this.P__0;
        }
        set v(O) {
          let T = (0, W.getNumber)(O, "value");
          (0, W.assertArgument)(27 === T || 28 === T, "invalid v", "v", O),
            (this.P__0 = T);
        }
        get networkV() {
          return this.x__0;
        }
        get legacyChainId() {
          let O = this.networkV;
          return null == O ? null : ei.getChainId(O);
        }
        get yParity() {
          return 27 === this.v ? 0 : 1;
        }
        get yParityAndS() {
          let O = (0, W.getBytes)(this.s);
          return this.yParity && (O[0] |= 128), (0, W.hexlify)(O);
        }
        get compactSerialized() {
          return (0, W.concat)([this.r, this.yParityAndS]);
        }
        get serialized() {
          return (0, W.concat)([
            this.r,
            this.s,
            this.yParity ? "0x1c" : "0x1b",
          ]);
        }
        constructor(O, T, L, J) {
          (0, W.assertPrivate)(O, en, "Signature"),
            (this.E__0 = T),
            (this.S__0 = L),
            (this.P__0 = J),
            (this.x__0 = null);
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
        }
        clone() {
          let O = new ei(en, this.r, this.s, this.v);
          return this.networkV && (O.x__0 = this.networkV), O;
        }
        toJSON() {
          let O = this.networkV;
          return {
            _type: "signature",
            networkV: null != O ? O.toString() : null,
            r: this.r,
            s: this.s,
            v: this.v,
          };
        }
        static getChainId(O) {
          let T = (0, W.getBigInt)(O, "v");
          return T == ee || T == et
            ? Y
            : ((0, W.assertArgument)(T >= er, "invalid EIP-155 v", "v", O),
              (T - er) / X);
        }
        static getChainIdV(O, T) {
          return (0, W.getBigInt)(O) * X + BigInt(35 + T - 27);
        }
        static getNormalizedV(O) {
          let T = (0, W.getBigInt)(O);
          return T === Y || T === ee
            ? 27
            : T === Z || T === et
            ? 28
            : ((0, W.assertArgument)(T >= er, "invalid v", "v", O),
              T & Z ? 27 : 28);
        }
        static from(O) {
          function T(T, L) {
            (0, W.assertArgument)(T, L, "signature", O);
          }
          if (null == O) return new ei(en, J.ZeroHash, J.ZeroHash, 27);
          if ("string" == typeof O) {
            let L = (0, W.getBytes)(O, "signature");
            if (64 === L.length) {
              let O = (0, W.hexlify)(L.slice(0, 32)),
                T = L.slice(32, 64),
                J = 128 & T[0] ? 28 : 27;
              return (T[0] &= 127), new ei(en, O, (0, W.hexlify)(T), J);
            }
            if (65 === L.length) {
              let O = (0, W.hexlify)(L.slice(0, 32)),
                J = L.slice(32, 64);
              T((128 & J[0]) == 0, "non-canonical s");
              let Y = ei.getNormalizedV(L[64]);
              return new ei(en, O, (0, W.hexlify)(J), Y);
            }
            T(!1, "invalid raw signature length");
          }
          if (O instanceof ei) return O.clone();
          let L = O.r;
          T(null != L, "missing r");
          let Y = es(L),
            Z = (function (O, L) {
              if (null != O) return es(O);
              if (null != L) {
                T((0, W.isHexString)(L, 32), "invalid yParityAndS");
                let O = (0, W.getBytes)(L);
                return (O[0] &= 127), (0, W.hexlify)(O);
              }
              T(!1, "missing s");
            })(O.s, O.yParityAndS);
          T((128 & (0, W.getBytes)(Z)[0]) == 0, "non-canonical s");
          let { networkV: X, v: ee } = (function (O, L, J) {
              if (null != O) {
                let T = (0, W.getBigInt)(O);
                return {
                  networkV: T >= er ? T : void 0,
                  v: ei.getNormalizedV(T),
                };
              }
              if (null != L)
                return (
                  T((0, W.isHexString)(L, 32), "invalid yParityAndS"),
                  { v: 128 & (0, W.getBytes)(L)[0] ? 28 : 27 }
                );
              if (null != J) {
                switch ((0, W.getNumber)(J, "sig.yParity")) {
                  case 0:
                    return { v: 27 };
                  case 1:
                    return { v: 28 };
                }
                T(!1, "invalid yParity");
              }
              T(!1, "missing v");
            })(O.v, O.yParityAndS, O.yParity),
            et = new ei(en, Y, Z, ee);
          return (
            X && (et.x__0 = X),
            T(
              null == O.yParity ||
                (0, W.getNumber)(O.yParity, "sig.yParity") === et.yParity,
              "yParity mismatch"
            ),
            T(
              null == O.yParityAndS || O.yParityAndS === et.yParityAndS,
              "yParityAndS mismatch"
            ),
            et
          );
        }
      }
      T.Signature = ei;
    },
    11726: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.SigningKey = void 0);
      let J = L(70280),
        W = L(38478),
        Y = L(94003);
      class Z {
        constructor(O) {
          (0, W.assertArgument)(
            32 === (0, W.dataLength)(O),
            "invalid private key",
            "privateKey",
            "[REDACTED]"
          ),
            (this.C__0 = (0, W.hexlify)(O));
        }
        get privateKey() {
          return this.C__0;
        }
        get publicKey() {
          return Z.computePublicKey(this.C__0);
        }
        get compressedPublicKey() {
          return Z.computePublicKey(this.C__0, !0);
        }
        sign(O) {
          (0, W.assertArgument)(
            32 === (0, W.dataLength)(O),
            "invalid digest length",
            "digest",
            O
          );
          let T = J.secp256k1.sign(
            (0, W.getBytesCopy)(O),
            (0, W.getBytesCopy)(this.C__0),
            { lowS: !0 }
          );
          return Y.Signature.from({
            r: (0, W.toBeHex)(T.r, 32),
            s: (0, W.toBeHex)(T.s, 32),
            v: T.recovery ? 28 : 27,
          });
        }
        computeSharedSecret(O) {
          let T = Z.computePublicKey(O);
          return (0, W.hexlify)(
            J.secp256k1.getSharedSecret(
              (0, W.getBytesCopy)(this.C__0),
              (0, W.getBytes)(T),
              !1
            )
          );
        }
        static computePublicKey(O, T) {
          let L = (0, W.getBytes)(O, "key");
          if (32 === L.length) {
            let O = J.secp256k1.getPublicKey(L, !!T);
            return (0, W.hexlify)(O);
          }
          if (64 === L.length) {
            let O = new Uint8Array(65);
            (O[0] = 4), O.set(L, 1), (L = O);
          }
          let Y = J.secp256k1.ProjectivePoint.fromHex(L);
          return (0, W.hexlify)(Y.toRawBytes(T));
        }
        static recoverPublicKey(O, T) {
          (0, W.assertArgument)(
            32 === (0, W.dataLength)(O),
            "invalid digest length",
            "digest",
            O
          );
          let L = Y.Signature.from(T),
            Z = J.secp256k1.Signature.fromCompact(
              (0, W.getBytesCopy)((0, W.concat)([L.r, L.s]))
            ),
            X = (Z = Z.addRecoveryBit(L.yParity)).recoverPublicKey(
              (0, W.getBytesCopy)(O)
            );
          return (
            (0, W.assertArgument)(
              null != X,
              "invalid signautre for digest",
              "signature",
              T
            ),
            "0x" + X.toHex(!1)
          );
        }
        static addPoints(O, T, L) {
          let W = J.secp256k1.ProjectivePoint.fromHex(
              Z.computePublicKey(O).substring(2)
            ),
            Y = J.secp256k1.ProjectivePoint.fromHex(
              Z.computePublicKey(T).substring(2)
            );
          return "0x" + W.add(Y).toHex(!!L);
        }
      }
      T.SigningKey = Z;
    },
    28757: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ripemd160 =
          T.keccak256 =
          T.randomBytes =
          T.computeHmac =
          T.UndecodedEventLog =
          T.EventLog =
          T.ContractUnknownEventPayload =
          T.ContractTransactionResponse =
          T.ContractTransactionReceipt =
          T.ContractEventPayload =
          T.ContractFactory =
          T.Contract =
          T.BaseContract =
          T.MessagePrefix =
          T.EtherSymbol =
          T.ZeroHash =
          T.N =
          T.MaxInt256 =
          T.MinInt256 =
          T.MaxUint256 =
          T.WeiPerEther =
          T.ZeroAddress =
          T.resolveAddress =
          T.isAddress =
          T.isAddressable =
          T.getCreate2Address =
          T.getCreateAddress =
          T.getIcapAddress =
          T.getAddress =
          T.Typed =
          T.TransactionDescription =
          T.Result =
          T.LogDescription =
          T.Interface =
          T.Indexed =
          T.ErrorDescription =
          T.checkResultErrors =
          T.StructFragment =
          T.ParamType =
          T.NamedFragment =
          T.FunctionFragment =
          T.FallbackFragment =
          T.Fragment =
          T.EventFragment =
          T.ErrorFragment =
          T.ConstructorFragment =
          T.AbiCoder =
          T.encodeBytes32String =
          T.decodeBytes32String =
          T.version =
            void 0),
        (T.EtherscanPlugin =
          T.EnsPlugin =
          T.Network =
          T.EnsResolver =
          T.WebSocketProvider =
          T.SocketProvider =
          T.IpcSocketProvider =
          T.QuickNodeProvider =
          T.PocketProvider =
          T.InfuraWebSocketProvider =
          T.InfuraProvider =
          T.EtherscanProvider =
          T.CloudflareProvider =
          T.AnkrProvider =
          T.AlchemyProvider =
          T.BrowserProvider =
          T.JsonRpcSigner =
          T.JsonRpcProvider =
          T.JsonRpcApiProvider =
          T.FallbackProvider =
          T.AbstractProvider =
          T.VoidSigner =
          T.NonceManager =
          T.AbstractSigner =
          T.TransactionResponse =
          T.TransactionReceipt =
          T.Log =
          T.FeeData =
          T.Block =
          T.getDefaultProvider =
          T.verifyTypedData =
          T.TypedDataEncoder =
          T.solidityPackedSha256 =
          T.solidityPackedKeccak256 =
          T.solidityPacked =
          T.verifyMessage =
          T.hashMessage =
          T.dnsEncode =
          T.namehash =
          T.isValidName =
          T.ensNormalize =
          T.id =
          T.SigningKey =
          T.Signature =
          T.lock =
          T.scryptSync =
          T.scrypt =
          T.pbkdf2 =
          T.sha512 =
          T.sha256 =
            void 0),
        (T.toBeArray =
          T.getUint =
          T.getNumber =
          T.getBigInt =
          T.FixedNumber =
          T.FetchCancelSignal =
          T.FetchResponse =
          T.FetchRequest =
          T.EventPayload =
          T.isError =
          T.isCallException =
          T.makeError =
          T.assertPrivate =
          T.assertNormalize =
          T.assertArgumentCount =
          T.assertArgument =
          T.assert =
          T.resolveProperties =
          T.defineProperties =
          T.zeroPadValue =
          T.zeroPadBytes =
          T.stripZerosLeft =
          T.isBytesLike =
          T.isHexString =
          T.hexlify =
          T.getBytesCopy =
          T.getBytes =
          T.dataSlice =
          T.dataLength =
          T.concat =
          T.encodeBase64 =
          T.decodeBase64 =
          T.encodeBase58 =
          T.decodeBase58 =
          T.Transaction =
          T.recoverAddress =
          T.computeAddress =
          T.accessListify =
          T.showThrottleMessage =
          T.copyRequest =
          T.UnmanagedSubscriber =
          T.SocketSubscriber =
          T.SocketPendingSubscriber =
          T.SocketEventSubscriber =
          T.SocketBlockSubscriber =
          T.MulticoinProviderPlugin =
          T.NetworkPlugin =
          T.GasCostPlugin =
          T.FetchUrlFeeDataNetworkPlugin =
          T.FeeDataNetworkPlugin =
            void 0),
        (T.wordlists =
          T.WordlistOwlA =
          T.WordlistOwl =
          T.LangEn =
          T.Wordlist =
          T.encryptKeystoreJsonSync =
          T.encryptKeystoreJson =
          T.decryptKeystoreJson =
          T.decryptKeystoreJsonSync =
          T.decryptCrowdsaleJson =
          T.isKeystoreJson =
          T.isCrowdsaleJson =
          T.getIndexedAccountPath =
          T.getAccountPath =
          T.defaultPath =
          T.Wallet =
          T.HDNodeVoidWallet =
          T.HDNodeWallet =
          T.BaseWallet =
          T.Mnemonic =
          T.uuidV4 =
          T.encodeRlp =
          T.decodeRlp =
          T.Utf8ErrorFuncs =
          T.toUtf8String =
          T.toUtf8CodePoints =
          T.toUtf8Bytes =
          T.parseUnits =
          T.formatUnits =
          T.parseEther =
          T.formatEther =
          T.mask =
          T.toTwos =
          T.fromTwos =
          T.toQuantity =
          T.toNumber =
          T.toBeHex =
          T.toBigInt =
            void 0);
      var J = L(73661);
      Object.defineProperty(T, "version", {
        enumerable: !0,
        get: function () {
          return J.version;
        },
      });
      var W = L(16330);
      Object.defineProperty(T, "decodeBytes32String", {
        enumerable: !0,
        get: function () {
          return W.decodeBytes32String;
        },
      }),
        Object.defineProperty(T, "encodeBytes32String", {
          enumerable: !0,
          get: function () {
            return W.encodeBytes32String;
          },
        }),
        Object.defineProperty(T, "AbiCoder", {
          enumerable: !0,
          get: function () {
            return W.AbiCoder;
          },
        }),
        Object.defineProperty(T, "ConstructorFragment", {
          enumerable: !0,
          get: function () {
            return W.ConstructorFragment;
          },
        }),
        Object.defineProperty(T, "ErrorFragment", {
          enumerable: !0,
          get: function () {
            return W.ErrorFragment;
          },
        }),
        Object.defineProperty(T, "EventFragment", {
          enumerable: !0,
          get: function () {
            return W.EventFragment;
          },
        }),
        Object.defineProperty(T, "Fragment", {
          enumerable: !0,
          get: function () {
            return W.Fragment;
          },
        }),
        Object.defineProperty(T, "FallbackFragment", {
          enumerable: !0,
          get: function () {
            return W.FallbackFragment;
          },
        }),
        Object.defineProperty(T, "FunctionFragment", {
          enumerable: !0,
          get: function () {
            return W.FunctionFragment;
          },
        }),
        Object.defineProperty(T, "NamedFragment", {
          enumerable: !0,
          get: function () {
            return W.NamedFragment;
          },
        }),
        Object.defineProperty(T, "ParamType", {
          enumerable: !0,
          get: function () {
            return W.ParamType;
          },
        }),
        Object.defineProperty(T, "StructFragment", {
          enumerable: !0,
          get: function () {
            return W.StructFragment;
          },
        }),
        Object.defineProperty(T, "checkResultErrors", {
          enumerable: !0,
          get: function () {
            return W.checkResultErrors;
          },
        }),
        Object.defineProperty(T, "ErrorDescription", {
          enumerable: !0,
          get: function () {
            return W.ErrorDescription;
          },
        }),
        Object.defineProperty(T, "Indexed", {
          enumerable: !0,
          get: function () {
            return W.Indexed;
          },
        }),
        Object.defineProperty(T, "Interface", {
          enumerable: !0,
          get: function () {
            return W.Interface;
          },
        }),
        Object.defineProperty(T, "LogDescription", {
          enumerable: !0,
          get: function () {
            return W.LogDescription;
          },
        }),
        Object.defineProperty(T, "Result", {
          enumerable: !0,
          get: function () {
            return W.Result;
          },
        }),
        Object.defineProperty(T, "TransactionDescription", {
          enumerable: !0,
          get: function () {
            return W.TransactionDescription;
          },
        }),
        Object.defineProperty(T, "Typed", {
          enumerable: !0,
          get: function () {
            return W.Typed;
          },
        });
      var Y = L(40431);
      Object.defineProperty(T, "getAddress", {
        enumerable: !0,
        get: function () {
          return Y.getAddress;
        },
      }),
        Object.defineProperty(T, "getIcapAddress", {
          enumerable: !0,
          get: function () {
            return Y.getIcapAddress;
          },
        }),
        Object.defineProperty(T, "getCreateAddress", {
          enumerable: !0,
          get: function () {
            return Y.getCreateAddress;
          },
        }),
        Object.defineProperty(T, "getCreate2Address", {
          enumerable: !0,
          get: function () {
            return Y.getCreate2Address;
          },
        }),
        Object.defineProperty(T, "isAddressable", {
          enumerable: !0,
          get: function () {
            return Y.isAddressable;
          },
        }),
        Object.defineProperty(T, "isAddress", {
          enumerable: !0,
          get: function () {
            return Y.isAddress;
          },
        }),
        Object.defineProperty(T, "resolveAddress", {
          enumerable: !0,
          get: function () {
            return Y.resolveAddress;
          },
        });
      var Z = L(98148);
      Object.defineProperty(T, "ZeroAddress", {
        enumerable: !0,
        get: function () {
          return Z.ZeroAddress;
        },
      }),
        Object.defineProperty(T, "WeiPerEther", {
          enumerable: !0,
          get: function () {
            return Z.WeiPerEther;
          },
        }),
        Object.defineProperty(T, "MaxUint256", {
          enumerable: !0,
          get: function () {
            return Z.MaxUint256;
          },
        }),
        Object.defineProperty(T, "MinInt256", {
          enumerable: !0,
          get: function () {
            return Z.MinInt256;
          },
        }),
        Object.defineProperty(T, "MaxInt256", {
          enumerable: !0,
          get: function () {
            return Z.MaxInt256;
          },
        }),
        Object.defineProperty(T, "N", {
          enumerable: !0,
          get: function () {
            return Z.N;
          },
        }),
        Object.defineProperty(T, "ZeroHash", {
          enumerable: !0,
          get: function () {
            return Z.ZeroHash;
          },
        }),
        Object.defineProperty(T, "EtherSymbol", {
          enumerable: !0,
          get: function () {
            return Z.EtherSymbol;
          },
        }),
        Object.defineProperty(T, "MessagePrefix", {
          enumerable: !0,
          get: function () {
            return Z.MessagePrefix;
          },
        });
      var X = L(15311);
      Object.defineProperty(T, "BaseContract", {
        enumerable: !0,
        get: function () {
          return X.BaseContract;
        },
      }),
        Object.defineProperty(T, "Contract", {
          enumerable: !0,
          get: function () {
            return X.Contract;
          },
        }),
        Object.defineProperty(T, "ContractFactory", {
          enumerable: !0,
          get: function () {
            return X.ContractFactory;
          },
        }),
        Object.defineProperty(T, "ContractEventPayload", {
          enumerable: !0,
          get: function () {
            return X.ContractEventPayload;
          },
        }),
        Object.defineProperty(T, "ContractTransactionReceipt", {
          enumerable: !0,
          get: function () {
            return X.ContractTransactionReceipt;
          },
        }),
        Object.defineProperty(T, "ContractTransactionResponse", {
          enumerable: !0,
          get: function () {
            return X.ContractTransactionResponse;
          },
        }),
        Object.defineProperty(T, "ContractUnknownEventPayload", {
          enumerable: !0,
          get: function () {
            return X.ContractUnknownEventPayload;
          },
        }),
        Object.defineProperty(T, "EventLog", {
          enumerable: !0,
          get: function () {
            return X.EventLog;
          },
        }),
        Object.defineProperty(T, "UndecodedEventLog", {
          enumerable: !0,
          get: function () {
            return X.UndecodedEventLog;
          },
        });
      var ee = L(3382);
      Object.defineProperty(T, "computeHmac", {
        enumerable: !0,
        get: function () {
          return ee.computeHmac;
        },
      }),
        Object.defineProperty(T, "randomBytes", {
          enumerable: !0,
          get: function () {
            return ee.randomBytes;
          },
        }),
        Object.defineProperty(T, "keccak256", {
          enumerable: !0,
          get: function () {
            return ee.keccak256;
          },
        }),
        Object.defineProperty(T, "ripemd160", {
          enumerable: !0,
          get: function () {
            return ee.ripemd160;
          },
        }),
        Object.defineProperty(T, "sha256", {
          enumerable: !0,
          get: function () {
            return ee.sha256;
          },
        }),
        Object.defineProperty(T, "sha512", {
          enumerable: !0,
          get: function () {
            return ee.sha512;
          },
        }),
        Object.defineProperty(T, "pbkdf2", {
          enumerable: !0,
          get: function () {
            return ee.pbkdf2;
          },
        }),
        Object.defineProperty(T, "scrypt", {
          enumerable: !0,
          get: function () {
            return ee.scrypt;
          },
        }),
        Object.defineProperty(T, "scryptSync", {
          enumerable: !0,
          get: function () {
            return ee.scryptSync;
          },
        }),
        Object.defineProperty(T, "lock", {
          enumerable: !0,
          get: function () {
            return ee.lock;
          },
        }),
        Object.defineProperty(T, "Signature", {
          enumerable: !0,
          get: function () {
            return ee.Signature;
          },
        }),
        Object.defineProperty(T, "SigningKey", {
          enumerable: !0,
          get: function () {
            return ee.SigningKey;
          },
        });
      var et = L(41648);
      Object.defineProperty(T, "id", {
        enumerable: !0,
        get: function () {
          return et.id;
        },
      }),
        Object.defineProperty(T, "ensNormalize", {
          enumerable: !0,
          get: function () {
            return et.ensNormalize;
          },
        }),
        Object.defineProperty(T, "isValidName", {
          enumerable: !0,
          get: function () {
            return et.isValidName;
          },
        }),
        Object.defineProperty(T, "namehash", {
          enumerable: !0,
          get: function () {
            return et.namehash;
          },
        }),
        Object.defineProperty(T, "dnsEncode", {
          enumerable: !0,
          get: function () {
            return et.dnsEncode;
          },
        }),
        Object.defineProperty(T, "hashMessage", {
          enumerable: !0,
          get: function () {
            return et.hashMessage;
          },
        }),
        Object.defineProperty(T, "verifyMessage", {
          enumerable: !0,
          get: function () {
            return et.verifyMessage;
          },
        }),
        Object.defineProperty(T, "solidityPacked", {
          enumerable: !0,
          get: function () {
            return et.solidityPacked;
          },
        }),
        Object.defineProperty(T, "solidityPackedKeccak256", {
          enumerable: !0,
          get: function () {
            return et.solidityPackedKeccak256;
          },
        }),
        Object.defineProperty(T, "solidityPackedSha256", {
          enumerable: !0,
          get: function () {
            return et.solidityPackedSha256;
          },
        }),
        Object.defineProperty(T, "TypedDataEncoder", {
          enumerable: !0,
          get: function () {
            return et.TypedDataEncoder;
          },
        }),
        Object.defineProperty(T, "verifyTypedData", {
          enumerable: !0,
          get: function () {
            return et.verifyTypedData;
          },
        });
      var er = L(37431);
      Object.defineProperty(T, "getDefaultProvider", {
        enumerable: !0,
        get: function () {
          return er.getDefaultProvider;
        },
      }),
        Object.defineProperty(T, "Block", {
          enumerable: !0,
          get: function () {
            return er.Block;
          },
        }),
        Object.defineProperty(T, "FeeData", {
          enumerable: !0,
          get: function () {
            return er.FeeData;
          },
        }),
        Object.defineProperty(T, "Log", {
          enumerable: !0,
          get: function () {
            return er.Log;
          },
        }),
        Object.defineProperty(T, "TransactionReceipt", {
          enumerable: !0,
          get: function () {
            return er.TransactionReceipt;
          },
        }),
        Object.defineProperty(T, "TransactionResponse", {
          enumerable: !0,
          get: function () {
            return er.TransactionResponse;
          },
        }),
        Object.defineProperty(T, "AbstractSigner", {
          enumerable: !0,
          get: function () {
            return er.AbstractSigner;
          },
        }),
        Object.defineProperty(T, "NonceManager", {
          enumerable: !0,
          get: function () {
            return er.NonceManager;
          },
        }),
        Object.defineProperty(T, "VoidSigner", {
          enumerable: !0,
          get: function () {
            return er.VoidSigner;
          },
        }),
        Object.defineProperty(T, "AbstractProvider", {
          enumerable: !0,
          get: function () {
            return er.AbstractProvider;
          },
        }),
        Object.defineProperty(T, "FallbackProvider", {
          enumerable: !0,
          get: function () {
            return er.FallbackProvider;
          },
        }),
        Object.defineProperty(T, "JsonRpcApiProvider", {
          enumerable: !0,
          get: function () {
            return er.JsonRpcApiProvider;
          },
        }),
        Object.defineProperty(T, "JsonRpcProvider", {
          enumerable: !0,
          get: function () {
            return er.JsonRpcProvider;
          },
        }),
        Object.defineProperty(T, "JsonRpcSigner", {
          enumerable: !0,
          get: function () {
            return er.JsonRpcSigner;
          },
        }),
        Object.defineProperty(T, "BrowserProvider", {
          enumerable: !0,
          get: function () {
            return er.BrowserProvider;
          },
        }),
        Object.defineProperty(T, "AlchemyProvider", {
          enumerable: !0,
          get: function () {
            return er.AlchemyProvider;
          },
        }),
        Object.defineProperty(T, "AnkrProvider", {
          enumerable: !0,
          get: function () {
            return er.AnkrProvider;
          },
        }),
        Object.defineProperty(T, "CloudflareProvider", {
          enumerable: !0,
          get: function () {
            return er.CloudflareProvider;
          },
        }),
        Object.defineProperty(T, "EtherscanProvider", {
          enumerable: !0,
          get: function () {
            return er.EtherscanProvider;
          },
        }),
        Object.defineProperty(T, "InfuraProvider", {
          enumerable: !0,
          get: function () {
            return er.InfuraProvider;
          },
        }),
        Object.defineProperty(T, "InfuraWebSocketProvider", {
          enumerable: !0,
          get: function () {
            return er.InfuraWebSocketProvider;
          },
        }),
        Object.defineProperty(T, "PocketProvider", {
          enumerable: !0,
          get: function () {
            return er.PocketProvider;
          },
        }),
        Object.defineProperty(T, "QuickNodeProvider", {
          enumerable: !0,
          get: function () {
            return er.QuickNodeProvider;
          },
        }),
        Object.defineProperty(T, "IpcSocketProvider", {
          enumerable: !0,
          get: function () {
            return er.IpcSocketProvider;
          },
        }),
        Object.defineProperty(T, "SocketProvider", {
          enumerable: !0,
          get: function () {
            return er.SocketProvider;
          },
        }),
        Object.defineProperty(T, "WebSocketProvider", {
          enumerable: !0,
          get: function () {
            return er.WebSocketProvider;
          },
        }),
        Object.defineProperty(T, "EnsResolver", {
          enumerable: !0,
          get: function () {
            return er.EnsResolver;
          },
        }),
        Object.defineProperty(T, "Network", {
          enumerable: !0,
          get: function () {
            return er.Network;
          },
        }),
        Object.defineProperty(T, "EnsPlugin", {
          enumerable: !0,
          get: function () {
            return er.EnsPlugin;
          },
        }),
        Object.defineProperty(T, "EtherscanPlugin", {
          enumerable: !0,
          get: function () {
            return er.EtherscanPlugin;
          },
        }),
        Object.defineProperty(T, "FeeDataNetworkPlugin", {
          enumerable: !0,
          get: function () {
            return er.FeeDataNetworkPlugin;
          },
        }),
        Object.defineProperty(T, "FetchUrlFeeDataNetworkPlugin", {
          enumerable: !0,
          get: function () {
            return er.FetchUrlFeeDataNetworkPlugin;
          },
        }),
        Object.defineProperty(T, "GasCostPlugin", {
          enumerable: !0,
          get: function () {
            return er.GasCostPlugin;
          },
        }),
        Object.defineProperty(T, "NetworkPlugin", {
          enumerable: !0,
          get: function () {
            return er.NetworkPlugin;
          },
        }),
        Object.defineProperty(T, "MulticoinProviderPlugin", {
          enumerable: !0,
          get: function () {
            return er.MulticoinProviderPlugin;
          },
        }),
        Object.defineProperty(T, "SocketBlockSubscriber", {
          enumerable: !0,
          get: function () {
            return er.SocketBlockSubscriber;
          },
        }),
        Object.defineProperty(T, "SocketEventSubscriber", {
          enumerable: !0,
          get: function () {
            return er.SocketEventSubscriber;
          },
        }),
        Object.defineProperty(T, "SocketPendingSubscriber", {
          enumerable: !0,
          get: function () {
            return er.SocketPendingSubscriber;
          },
        }),
        Object.defineProperty(T, "SocketSubscriber", {
          enumerable: !0,
          get: function () {
            return er.SocketSubscriber;
          },
        }),
        Object.defineProperty(T, "UnmanagedSubscriber", {
          enumerable: !0,
          get: function () {
            return er.UnmanagedSubscriber;
          },
        }),
        Object.defineProperty(T, "copyRequest", {
          enumerable: !0,
          get: function () {
            return er.copyRequest;
          },
        }),
        Object.defineProperty(T, "showThrottleMessage", {
          enumerable: !0,
          get: function () {
            return er.showThrottleMessage;
          },
        });
      var en = L(16989);
      Object.defineProperty(T, "accessListify", {
        enumerable: !0,
        get: function () {
          return en.accessListify;
        },
      }),
        Object.defineProperty(T, "computeAddress", {
          enumerable: !0,
          get: function () {
            return en.computeAddress;
          },
        }),
        Object.defineProperty(T, "recoverAddress", {
          enumerable: !0,
          get: function () {
            return en.recoverAddress;
          },
        }),
        Object.defineProperty(T, "Transaction", {
          enumerable: !0,
          get: function () {
            return en.Transaction;
          },
        });
      var es = L(38478);
      Object.defineProperty(T, "decodeBase58", {
        enumerable: !0,
        get: function () {
          return es.decodeBase58;
        },
      }),
        Object.defineProperty(T, "encodeBase58", {
          enumerable: !0,
          get: function () {
            return es.encodeBase58;
          },
        }),
        Object.defineProperty(T, "decodeBase64", {
          enumerable: !0,
          get: function () {
            return es.decodeBase64;
          },
        }),
        Object.defineProperty(T, "encodeBase64", {
          enumerable: !0,
          get: function () {
            return es.encodeBase64;
          },
        }),
        Object.defineProperty(T, "concat", {
          enumerable: !0,
          get: function () {
            return es.concat;
          },
        }),
        Object.defineProperty(T, "dataLength", {
          enumerable: !0,
          get: function () {
            return es.dataLength;
          },
        }),
        Object.defineProperty(T, "dataSlice", {
          enumerable: !0,
          get: function () {
            return es.dataSlice;
          },
        }),
        Object.defineProperty(T, "getBytes", {
          enumerable: !0,
          get: function () {
            return es.getBytes;
          },
        }),
        Object.defineProperty(T, "getBytesCopy", {
          enumerable: !0,
          get: function () {
            return es.getBytesCopy;
          },
        }),
        Object.defineProperty(T, "hexlify", {
          enumerable: !0,
          get: function () {
            return es.hexlify;
          },
        }),
        Object.defineProperty(T, "isHexString", {
          enumerable: !0,
          get: function () {
            return es.isHexString;
          },
        }),
        Object.defineProperty(T, "isBytesLike", {
          enumerable: !0,
          get: function () {
            return es.isBytesLike;
          },
        }),
        Object.defineProperty(T, "stripZerosLeft", {
          enumerable: !0,
          get: function () {
            return es.stripZerosLeft;
          },
        }),
        Object.defineProperty(T, "zeroPadBytes", {
          enumerable: !0,
          get: function () {
            return es.zeroPadBytes;
          },
        }),
        Object.defineProperty(T, "zeroPadValue", {
          enumerable: !0,
          get: function () {
            return es.zeroPadValue;
          },
        }),
        Object.defineProperty(T, "defineProperties", {
          enumerable: !0,
          get: function () {
            return es.defineProperties;
          },
        }),
        Object.defineProperty(T, "resolveProperties", {
          enumerable: !0,
          get: function () {
            return es.resolveProperties;
          },
        }),
        Object.defineProperty(T, "assert", {
          enumerable: !0,
          get: function () {
            return es.assert;
          },
        }),
        Object.defineProperty(T, "assertArgument", {
          enumerable: !0,
          get: function () {
            return es.assertArgument;
          },
        }),
        Object.defineProperty(T, "assertArgumentCount", {
          enumerable: !0,
          get: function () {
            return es.assertArgumentCount;
          },
        }),
        Object.defineProperty(T, "assertNormalize", {
          enumerable: !0,
          get: function () {
            return es.assertNormalize;
          },
        }),
        Object.defineProperty(T, "assertPrivate", {
          enumerable: !0,
          get: function () {
            return es.assertPrivate;
          },
        }),
        Object.defineProperty(T, "makeError", {
          enumerable: !0,
          get: function () {
            return es.makeError;
          },
        }),
        Object.defineProperty(T, "isCallException", {
          enumerable: !0,
          get: function () {
            return es.isCallException;
          },
        }),
        Object.defineProperty(T, "isError", {
          enumerable: !0,
          get: function () {
            return es.isError;
          },
        }),
        Object.defineProperty(T, "EventPayload", {
          enumerable: !0,
          get: function () {
            return es.EventPayload;
          },
        }),
        Object.defineProperty(T, "FetchRequest", {
          enumerable: !0,
          get: function () {
            return es.FetchRequest;
          },
        }),
        Object.defineProperty(T, "FetchResponse", {
          enumerable: !0,
          get: function () {
            return es.FetchResponse;
          },
        }),
        Object.defineProperty(T, "FetchCancelSignal", {
          enumerable: !0,
          get: function () {
            return es.FetchCancelSignal;
          },
        }),
        Object.defineProperty(T, "FixedNumber", {
          enumerable: !0,
          get: function () {
            return es.FixedNumber;
          },
        }),
        Object.defineProperty(T, "getBigInt", {
          enumerable: !0,
          get: function () {
            return es.getBigInt;
          },
        }),
        Object.defineProperty(T, "getNumber", {
          enumerable: !0,
          get: function () {
            return es.getNumber;
          },
        }),
        Object.defineProperty(T, "getUint", {
          enumerable: !0,
          get: function () {
            return es.getUint;
          },
        }),
        Object.defineProperty(T, "toBeArray", {
          enumerable: !0,
          get: function () {
            return es.toBeArray;
          },
        }),
        Object.defineProperty(T, "toBigInt", {
          enumerable: !0,
          get: function () {
            return es.toBigInt;
          },
        }),
        Object.defineProperty(T, "toBeHex", {
          enumerable: !0,
          get: function () {
            return es.toBeHex;
          },
        }),
        Object.defineProperty(T, "toNumber", {
          enumerable: !0,
          get: function () {
            return es.toNumber;
          },
        }),
        Object.defineProperty(T, "toQuantity", {
          enumerable: !0,
          get: function () {
            return es.toQuantity;
          },
        }),
        Object.defineProperty(T, "fromTwos", {
          enumerable: !0,
          get: function () {
            return es.fromTwos;
          },
        }),
        Object.defineProperty(T, "toTwos", {
          enumerable: !0,
          get: function () {
            return es.toTwos;
          },
        }),
        Object.defineProperty(T, "mask", {
          enumerable: !0,
          get: function () {
            return es.mask;
          },
        }),
        Object.defineProperty(T, "formatEther", {
          enumerable: !0,
          get: function () {
            return es.formatEther;
          },
        }),
        Object.defineProperty(T, "parseEther", {
          enumerable: !0,
          get: function () {
            return es.parseEther;
          },
        }),
        Object.defineProperty(T, "formatUnits", {
          enumerable: !0,
          get: function () {
            return es.formatUnits;
          },
        }),
        Object.defineProperty(T, "parseUnits", {
          enumerable: !0,
          get: function () {
            return es.parseUnits;
          },
        }),
        Object.defineProperty(T, "toUtf8Bytes", {
          enumerable: !0,
          get: function () {
            return es.toUtf8Bytes;
          },
        }),
        Object.defineProperty(T, "toUtf8CodePoints", {
          enumerable: !0,
          get: function () {
            return es.toUtf8CodePoints;
          },
        }),
        Object.defineProperty(T, "toUtf8String", {
          enumerable: !0,
          get: function () {
            return es.toUtf8String;
          },
        }),
        Object.defineProperty(T, "Utf8ErrorFuncs", {
          enumerable: !0,
          get: function () {
            return es.Utf8ErrorFuncs;
          },
        }),
        Object.defineProperty(T, "decodeRlp", {
          enumerable: !0,
          get: function () {
            return es.decodeRlp;
          },
        }),
        Object.defineProperty(T, "encodeRlp", {
          enumerable: !0,
          get: function () {
            return es.encodeRlp;
          },
        }),
        Object.defineProperty(T, "uuidV4", {
          enumerable: !0,
          get: function () {
            return es.uuidV4;
          },
        });
      var ei = L(92311);
      Object.defineProperty(T, "Mnemonic", {
        enumerable: !0,
        get: function () {
          return ei.Mnemonic;
        },
      }),
        Object.defineProperty(T, "BaseWallet", {
          enumerable: !0,
          get: function () {
            return ei.BaseWallet;
          },
        }),
        Object.defineProperty(T, "HDNodeWallet", {
          enumerable: !0,
          get: function () {
            return ei.HDNodeWallet;
          },
        }),
        Object.defineProperty(T, "HDNodeVoidWallet", {
          enumerable: !0,
          get: function () {
            return ei.HDNodeVoidWallet;
          },
        }),
        Object.defineProperty(T, "Wallet", {
          enumerable: !0,
          get: function () {
            return ei.Wallet;
          },
        }),
        Object.defineProperty(T, "defaultPath", {
          enumerable: !0,
          get: function () {
            return ei.defaultPath;
          },
        }),
        Object.defineProperty(T, "getAccountPath", {
          enumerable: !0,
          get: function () {
            return ei.getAccountPath;
          },
        }),
        Object.defineProperty(T, "getIndexedAccountPath", {
          enumerable: !0,
          get: function () {
            return ei.getIndexedAccountPath;
          },
        }),
        Object.defineProperty(T, "isCrowdsaleJson", {
          enumerable: !0,
          get: function () {
            return ei.isCrowdsaleJson;
          },
        }),
        Object.defineProperty(T, "isKeystoreJson", {
          enumerable: !0,
          get: function () {
            return ei.isKeystoreJson;
          },
        }),
        Object.defineProperty(T, "decryptCrowdsaleJson", {
          enumerable: !0,
          get: function () {
            return ei.decryptCrowdsaleJson;
          },
        }),
        Object.defineProperty(T, "decryptKeystoreJsonSync", {
          enumerable: !0,
          get: function () {
            return ei.decryptKeystoreJsonSync;
          },
        }),
        Object.defineProperty(T, "decryptKeystoreJson", {
          enumerable: !0,
          get: function () {
            return ei.decryptKeystoreJson;
          },
        }),
        Object.defineProperty(T, "encryptKeystoreJson", {
          enumerable: !0,
          get: function () {
            return ei.encryptKeystoreJson;
          },
        }),
        Object.defineProperty(T, "encryptKeystoreJsonSync", {
          enumerable: !0,
          get: function () {
            return ei.encryptKeystoreJsonSync;
          },
        });
      var ea = L(63851);
      Object.defineProperty(T, "Wordlist", {
        enumerable: !0,
        get: function () {
          return ea.Wordlist;
        },
      }),
        Object.defineProperty(T, "LangEn", {
          enumerable: !0,
          get: function () {
            return ea.LangEn;
          },
        }),
        Object.defineProperty(T, "WordlistOwl", {
          enumerable: !0,
          get: function () {
            return ea.WordlistOwl;
          },
        }),
        Object.defineProperty(T, "WordlistOwlA", {
          enumerable: !0,
          get: function () {
            return ea.WordlistOwlA;
          },
        }),
        Object.defineProperty(T, "wordlists", {
          enumerable: !0,
          get: function () {
            return ea.wordlists;
          },
        });
    },
    42169: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }), (T.id = void 0);
      let J = L(3382),
        W = L(38478);
      function Y(O) {
        return (0, J.keccak256)((0, W.toUtf8Bytes)(O));
      }
      T.id = Y;
    },
    41648: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.verifyTypedData =
          T.TypedDataEncoder =
          T.solidityPackedSha256 =
          T.solidityPackedKeccak256 =
          T.solidityPacked =
          T.verifyMessage =
          T.hashMessage =
          T.dnsEncode =
          T.namehash =
          T.isValidName =
          T.ensNormalize =
          T.id =
            void 0);
      var J = L(42169);
      Object.defineProperty(T, "id", {
        enumerable: !0,
        get: function () {
          return J.id;
        },
      });
      var W = L(11797);
      Object.defineProperty(T, "ensNormalize", {
        enumerable: !0,
        get: function () {
          return W.ensNormalize;
        },
      }),
        Object.defineProperty(T, "isValidName", {
          enumerable: !0,
          get: function () {
            return W.isValidName;
          },
        }),
        Object.defineProperty(T, "namehash", {
          enumerable: !0,
          get: function () {
            return W.namehash;
          },
        }),
        Object.defineProperty(T, "dnsEncode", {
          enumerable: !0,
          get: function () {
            return W.dnsEncode;
          },
        });
      var Y = L(63329);
      Object.defineProperty(T, "hashMessage", {
        enumerable: !0,
        get: function () {
          return Y.hashMessage;
        },
      }),
        Object.defineProperty(T, "verifyMessage", {
          enumerable: !0,
          get: function () {
            return Y.verifyMessage;
          },
        });
      var Z = L(86766);
      Object.defineProperty(T, "solidityPacked", {
        enumerable: !0,
        get: function () {
          return Z.solidityPacked;
        },
      }),
        Object.defineProperty(T, "solidityPackedKeccak256", {
          enumerable: !0,
          get: function () {
            return Z.solidityPackedKeccak256;
          },
        }),
        Object.defineProperty(T, "solidityPackedSha256", {
          enumerable: !0,
          get: function () {
            return Z.solidityPackedSha256;
          },
        });
      var X = L(8473);
      Object.defineProperty(T, "TypedDataEncoder", {
        enumerable: !0,
        get: function () {
          return X.TypedDataEncoder;
        },
      }),
        Object.defineProperty(T, "verifyTypedData", {
          enumerable: !0,
          get: function () {
            return X.verifyTypedData;
          },
        });
    },
    63329: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.verifyMessage = T.hashMessage = void 0);
      let J = L(3382),
        W = L(98148),
        Y = L(16989),
        Z = L(38478);
      function X(O) {
        return (
          "string" == typeof O && (O = (0, Z.toUtf8Bytes)(O)),
          (0, J.keccak256)(
            (0, Z.concat)([
              (0, Z.toUtf8Bytes)(W.MessagePrefix),
              (0, Z.toUtf8Bytes)(String(O.length)),
              O,
            ])
          )
        );
      }
      function ee(O, T) {
        let L = X(O);
        return (0, Y.recoverAddress)(L, T);
      }
      (T.hashMessage = X), (T.verifyMessage = ee);
    },
    11797: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.dnsEncode = T.namehash = T.isValidName = T.ensNormalize = void 0);
      let J = L(3382),
        W = L(38478),
        Y = L(13467),
        Z = new Uint8Array(32);
      function X(O) {
        return (
          (0, W.assertArgument)(
            0 !== O.length,
            "invalid ENS name; empty component",
            "comp",
            O
          ),
          O
        );
      }
      function ee(O) {
        let T = (0, W.toUtf8Bytes)(et(O)),
          L = [];
        if (0 === O.length) return L;
        let J = 0;
        for (let O = 0; O < T.length; O++)
          46 === T[O] && (L.push(X(T.slice(J, O))), (J = O + 1));
        return (
          (0, W.assertArgument)(
            J < T.length,
            "invalid ENS name; empty component",
            "name",
            O
          ),
          L.push(X(T.slice(J))),
          L
        );
      }
      function et(O) {
        try {
          if (0 === O.length) throw Error("empty label");
          return (0, Y.ens_normalize)(O);
        } catch (T) {
          (0, W.assertArgument)(
            !1,
            `invalid ENS name (${T.message})`,
            "name",
            O
          );
        }
      }
      function er(O) {
        try {
          return 0 !== ee(O).length;
        } catch (O) {}
        return !1;
      }
      function en(O) {
        (0, W.assertArgument)(
          "string" == typeof O,
          "invalid ENS name; not a string",
          "name",
          O
        ),
          (0, W.assertArgument)(
            O.length,
            "invalid ENS name (empty label)",
            "name",
            O
          );
        let T = Z,
          L = ee(O);
        for (; L.length; )
          T = (0, J.keccak256)((0, W.concat)([T, (0, J.keccak256)(L.pop())]));
        return (0, W.hexlify)(T);
      }
      function es(O, T) {
        let L = null != T ? T : 63;
        return (
          (0, W.assertArgument)(
            L <= 255,
            "DNS encoded label cannot exceed 255",
            "length",
            L
          ),
          (0, W.hexlify)(
            (0, W.concat)(
              ee(O).map((T) => {
                (0, W.assertArgument)(
                  T.length <= L,
                  `label ${JSON.stringify(O)} exceeds ${L} bytes`,
                  "name",
                  O
                );
                let J = new Uint8Array(T.length + 1);
                return J.set(T, 1), (J[0] = J.length - 1), J;
              })
            )
          ) + "00"
        );
      }
      Z.fill(0),
        (T.ensNormalize = et),
        (T.isValidName = er),
        (T.namehash = en),
        (T.dnsEncode = es);
    },
    86766: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.solidityPackedSha256 =
          T.solidityPackedKeccak256 =
          T.solidityPacked =
            void 0);
      let J = L(40431),
        W = L(3382),
        Y = L(38478),
        Z = RegExp("^bytes([0-9]+)$"),
        X = RegExp("^(u?int)([0-9]*)$"),
        ee = RegExp("^(.*)\\[([0-9]*)\\]$");
      function et(O, T, L) {
        switch (O) {
          case "address":
            if (L) return (0, Y.getBytes)((0, Y.zeroPadValue)(T, 32));
            return (0, Y.getBytes)((0, J.getAddress)(T));
          case "string":
            return (0, Y.toUtf8Bytes)(T);
          case "bytes":
            return (0, Y.getBytes)(T);
          case "bool":
            if (((T = T ? "0x01" : "0x00"), L))
              return (0, Y.getBytes)((0, Y.zeroPadValue)(T, 32));
            return (0, Y.getBytes)(T);
        }
        let W = O.match(X);
        if (W) {
          let J = "int" === W[1],
            Z = parseInt(W[2] || "256");
          return (
            (0, Y.assertArgument)(
              (!W[2] || W[2] === String(Z)) &&
                Z % 8 == 0 &&
                0 !== Z &&
                Z <= 256,
              "invalid number type",
              "type",
              O
            ),
            L && (Z = 256),
            J && (T = (0, Y.toTwos)(T, Z)),
            (0, Y.getBytes)((0, Y.zeroPadValue)((0, Y.toBeArray)(T), Z / 8))
          );
        }
        if ((W = O.match(Z))) {
          let J = parseInt(W[1]);
          return ((0, Y.assertArgument)(
            String(J) === W[1] && 0 !== J && J <= 32,
            "invalid bytes type",
            "type",
            O
          ),
          (0, Y.assertArgument)(
            (0, Y.dataLength)(T) === J,
            `invalid value for ${O}`,
            "value",
            T
          ),
          L)
            ? (0, Y.getBytes)((0, Y.zeroPadBytes)(T, 32))
            : T;
        }
        if ((W = O.match(ee)) && Array.isArray(T)) {
          let L = W[1],
            J = parseInt(W[2] || String(T.length));
          (0, Y.assertArgument)(
            J === T.length,
            `invalid array length for ${O}`,
            "value",
            T
          );
          let Z = [];
          return (
            T.forEach(function (O) {
              Z.push(et(L, O, !0));
            }),
            (0, Y.getBytes)((0, Y.concat)(Z))
          );
        }
        (0, Y.assertArgument)(!1, "invalid type", "type", O);
      }
      function er(O, T) {
        (0, Y.assertArgument)(
          O.length === T.length,
          "wrong number of values; expected ${ types.length }",
          "values",
          T
        );
        let L = [];
        return (
          O.forEach(function (O, J) {
            L.push(et(O, T[J]));
          }),
          (0, Y.hexlify)((0, Y.concat)(L))
        );
      }
      function en(O, T) {
        return (0, W.keccak256)(er(O, T));
      }
      function es(O, T) {
        return (0, W.sha256)(er(O, T));
      }
      (T.solidityPacked = er),
        (T.solidityPackedKeccak256 = en),
        (T.solidityPackedSha256 = es);
    },
    8473: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.verifyTypedData = T.TypedDataEncoder = void 0);
      let J = L(40431),
        W = L(3382),
        Y = L(16989),
        Z = L(38478),
        X = L(42169),
        ee = new Uint8Array(32);
      ee.fill(0);
      let et = BigInt(-1),
        er = BigInt(0),
        en = BigInt(1),
        es = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
      function ei(O) {
        let T = (0, Z.getBytes)(O),
          L = T.length % 32;
        return L ? (0, Z.concat)([T, ee.slice(L)]) : (0, Z.hexlify)(T);
      }
      let ea = (0, Z.toBeHex)(en, 32),
        eo = (0, Z.toBeHex)(er, 32),
        ec = {
          name: "string",
          version: "string",
          chainId: "uint256",
          verifyingContract: "address",
          salt: "bytes32",
        },
        eu = ["name", "version", "chainId", "verifyingContract", "salt"];
      function eh(O) {
        return function (T) {
          return (
            (0, Z.assertArgument)(
              "string" == typeof T,
              `invalid domain value for ${JSON.stringify(O)}`,
              `domain.${O}`,
              T
            ),
            T
          );
        };
      }
      let ed = {
        name: eh("name"),
        version: eh("version"),
        chainId: function (O) {
          let T = (0, Z.getBigInt)(O, "domain.chainId");
          return ((0, Z.assertArgument)(
            T >= 0,
            "invalid chain ID",
            "domain.chainId",
            O
          ),
          Number.isSafeInteger(T))
            ? Number(T)
            : (0, Z.toQuantity)(T);
        },
        verifyingContract: function (O) {
          try {
            return (0, J.getAddress)(O).toLowerCase();
          } catch (O) {}
          (0, Z.assertArgument)(
            !1,
            'invalid domain value "verifyingContract"',
            "domain.verifyingContract",
            O
          );
        },
        salt: function (O) {
          let T = (0, Z.getBytes)(O, "domain.salt");
          return (
            (0, Z.assertArgument)(
              32 === T.length,
              'invalid domain value "salt"',
              "domain.salt",
              O
            ),
            (0, Z.hexlify)(T)
          );
        },
      };
      function ep(O) {
        {
          let T = O.match(/^(u?)int(\d+)$/);
          if (T) {
            let L = "" === T[1],
              J = parseInt(T[2]);
            (0, Z.assertArgument)(
              J % 8 == 0 && 0 !== J && J <= 256 && T[2] === String(J),
              "invalid numeric width",
              "type",
              O
            );
            let W = (0, Z.mask)(es, L ? J - 1 : J),
              Y = L ? (W + en) * et : er;
            return function (T) {
              let J = (0, Z.getBigInt)(T, "value");
              return (
                (0, Z.assertArgument)(
                  J >= Y && J <= W,
                  `value out-of-bounds for ${O}`,
                  "value",
                  J
                ),
                (0, Z.toBeHex)(L ? (0, Z.toTwos)(J, 256) : J, 32)
              );
            };
          }
        }
        {
          let T = O.match(/^bytes(\d+)$/);
          if (T) {
            let L = parseInt(T[1]);
            return (
              (0, Z.assertArgument)(
                0 !== L && L <= 32 && T[1] === String(L),
                "invalid bytes width",
                "type",
                O
              ),
              function (T) {
                let J = (0, Z.getBytes)(T);
                return (
                  (0, Z.assertArgument)(
                    J.length === L,
                    `invalid length for ${O}`,
                    "value",
                    T
                  ),
                  ei(T)
                );
              }
            );
          }
        }
        switch (O) {
          case "address":
            return function (O) {
              return (0, Z.zeroPadValue)((0, J.getAddress)(O), 32);
            };
          case "bool":
            return function (O) {
              return O ? ea : eo;
            };
          case "bytes":
            return function (O) {
              return (0, W.keccak256)(O);
            };
          case "string":
            return function (O) {
              return (0, X.id)(O);
            };
        }
        return null;
      }
      function eg(O, T) {
        return `${O}(${T.map(({ name: O, type: T }) => T + " " + O).join(
          ","
        )})`;
      }
      function ey(O) {
        let T = O.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
        return T
          ? {
              base: T[1],
              index: T[2] + T[4],
              array: {
                base: T[1],
                prefix: T[1] + T[2],
                count: T[5] ? parseInt(T[5]) : -1,
              },
            }
          : { base: O };
      }
      class em {
        get types() {
          return JSON.parse(this.B__0);
        }
        constructor(O) {
          (this.O__0 = new Map()), (this.T__0 = new Map());
          let T = new Map(),
            L = new Map(),
            J = new Map(),
            W = {};
          for (let Y in (Object.keys(O).forEach((Y) => {
            (W[Y] = O[Y].map(({ name: T, type: L }) => {
              let { base: J, index: W } = ey(L);
              return (
                "int" !== J || O.int || (J = "int256"),
                "uint" !== J || O.uint || (J = "uint256"),
                { name: T, type: J + (W || "") }
              );
            })),
              T.set(Y, new Set()),
              L.set(Y, []),
              J.set(Y, new Set());
          }),
          (this.B__0 = JSON.stringify(W)),
          W)) {
            let J = new Set();
            for (let X of W[Y]) {
              (0, Z.assertArgument)(
                !J.has(X.name),
                `duplicate variable name ${JSON.stringify(
                  X.name
                )} in ${JSON.stringify(Y)}`,
                "types",
                O
              ),
                J.add(X.name);
              let W = ey(X.type).base;
              (0, Z.assertArgument)(
                W !== Y,
                `circular type reference to ${JSON.stringify(W)}`,
                "types",
                O
              ),
                ep(W) ||
                  ((0, Z.assertArgument)(
                    L.has(W),
                    `unknown type ${JSON.stringify(W)}`,
                    "types",
                    O
                  ),
                  L.get(W).push(Y),
                  T.get(Y).add(W));
            }
          }
          let Y = Array.from(L.keys()).filter((O) => 0 === L.get(O).length);
          function X(W, Y) {
            for (let ee of ((0, Z.assertArgument)(
              !Y.has(W),
              `circular type reference to ${JSON.stringify(W)}`,
              "types",
              O
            ),
            Y.add(W),
            T.get(W)))
              if (L.has(ee)) for (let O of (X(ee, Y), Y)) J.get(O).add(ee);
            Y.delete(W);
          }
          for (let [T, L] of ((0, Z.assertArgument)(
            0 !== Y.length,
            "missing primary type",
            "types",
            O
          ),
          (0, Z.assertArgument)(
            1 === Y.length,
            `ambiguous primary types or unused types: ${Y.map((O) =>
              JSON.stringify(O)
            ).join(", ")}`,
            "types",
            O
          ),
          (0, Z.defineProperties)(this, { primaryType: Y[0] }),
          X(this.primaryType, new Set()),
          J)) {
            let O = Array.from(L);
            O.sort(),
              this.O__0.set(T, eg(T, W[T]) + O.map((O) => eg(O, W[O])).join(""));
          }
        }
        getEncoder(O) {
          let T = this.T__0.get(O);
          return T || ((T = this.__N(O)), this.T__0.set(O, T)), T;
        }
        __N(O) {
          {
            let T = ep(O);
            if (T) return T;
          }
          let T = ey(O).array;
          if (T) {
            let O = T.prefix,
              L = this.getEncoder(O);
            return (J) => {
              (0, Z.assertArgument)(
                -1 === T.count || T.count === J.length,
                `array length mismatch; expected length ${T.count}`,
                "value",
                J
              );
              let Y = J.map(L);
              return (
                this.O__0.has(O) && (Y = Y.map(W.keccak256)),
                (0, W.keccak256)((0, Z.concat)(Y))
              );
            };
          }
          let L = this.types[O];
          if (L) {
            let T = (0, X.id)(this.O__0.get(O));
            return (O) => {
              let J = L.map(({ name: T, type: L }) => {
                let J = this.getEncoder(L)(O[T]);
                return this.O__0.has(L) ? (0, W.keccak256)(J) : J;
              });
              return J.unshift(T), (0, Z.concat)(J);
            };
          }
          (0, Z.assertArgument)(!1, `unknown type: ${O}`, "type", O);
        }
        encodeType(O) {
          let T = this.O__0.get(O);
          return (
            (0, Z.assertArgument)(
              T,
              `unknown type: ${JSON.stringify(O)}`,
              "name",
              O
            ),
            T
          );
        }
        encodeData(O, T) {
          return this.getEncoder(O)(T);
        }
        hashStruct(O, T) {
          return (0, W.keccak256)(this.encodeData(O, T));
        }
        encode(O) {
          return this.encodeData(this.primaryType, O);
        }
        hash(O) {
          return this.hashStruct(this.primaryType, O);
        }
        _visit(O, T, L) {
          if (ep(O)) return L(O, T);
          let J = ey(O).array;
          if (J)
            return (
              (0, Z.assertArgument)(
                -1 === J.count || J.count === T.length,
                `array length mismatch; expected length ${J.count}`,
                "value",
                T
              ),
              T.map((O) => this._visit(J.prefix, O, L))
            );
          let W = this.types[O];
          if (W)
            return W.reduce(
              (O, { name: J, type: W }) => (
                (O[J] = this._visit(W, T[J], L)), O
              ),
              {}
            );
          (0, Z.assertArgument)(!1, `unknown type: ${O}`, "type", O);
        }
        visit(O, T) {
          return this._visit(this.primaryType, O, T);
        }
        static from(O) {
          return new em(O);
        }
        static getPrimaryType(O) {
          return em.from(O).primaryType;
        }
        static hashStruct(O, T, L) {
          return em.from(T).hashStruct(O, L);
        }
        static hashDomain(O) {
          let T = [];
          for (let L in O) {
            if (null == O[L]) continue;
            let J = ec[L];
            (0, Z.assertArgument)(
              J,
              `invalid typed-data domain key: ${JSON.stringify(L)}`,
              "domain",
              O
            ),
              T.push({ name: L, type: J });
          }
          return (
            T.sort((O, T) => eu.indexOf(O.name) - eu.indexOf(T.name)),
            em.hashStruct("EIP712Domain", { EIP712Domain: T }, O)
          );
        }
        static encode(O, T, L) {
          return (0, Z.concat)([
            "0x1901",
            em.hashDomain(O),
            em.from(T).hash(L),
          ]);
        }
        static hash(O, T, L) {
          return (0, W.keccak256)(em.encode(O, T, L));
        }
        static async resolveNames(O, T, L, J) {
          for (let T in (O = Object.assign({}, O))) null == O[T] && delete O[T];
          let W = {};
          O.verifyingContract &&
            !(0, Z.isHexString)(O.verifyingContract, 20) &&
            (W[O.verifyingContract] = "0x");
          let Y = em.from(T);
          for (let O in (Y.visit(
            L,
            (O, T) => (
              "address" !== O || (0, Z.isHexString)(T, 20) || (W[T] = "0x"), T
            )
          ),
          W))
            W[O] = await J(O);
          return (
            O.verifyingContract &&
              W[O.verifyingContract] &&
              (O.verifyingContract = W[O.verifyingContract]),
            (L = Y.visit(L, (O, T) => ("address" === O && W[T] ? W[T] : T))),
            { domain: O, value: L }
          );
        }
        static getPayload(O, T, L) {
          em.hashDomain(O);
          let J = {},
            W = [];
          eu.forEach((T) => {
            let L = O[T];
            null != L && ((J[T] = ed[T](L)), W.push({ name: T, type: ec[T] }));
          });
          let Y = em.from(T),
            X = Object.assign({}, (T = Y.types));
          return (
            (0, Z.assertArgument)(
              null == X.EIP712Domain,
              "types must not contain EIP712Domain type",
              "types.EIP712Domain",
              T
            ),
            (X.EIP712Domain = W),
            Y.encode(L),
            {
              types: X,
              domain: J,
              primaryType: Y.primaryType,
              message: Y.visit(L, (O, T) => {
                if (O.match(/^bytes(\d*)/))
                  return (0, Z.hexlify)((0, Z.getBytes)(T));
                if (O.match(/^u?int/)) return (0, Z.getBigInt)(T).toString();
                switch (O) {
                  case "address":
                    return T.toLowerCase();
                  case "bool":
                    return !!T;
                  case "string":
                    return (
                      (0, Z.assertArgument)(
                        "string" == typeof T,
                        "invalid string",
                        "value",
                        T
                      ),
                      T
                    );
                }
                (0, Z.assertArgument)(!1, "unsupported type", "type", O);
              }),
            }
          );
        }
      }
      function eb(O, T, L, J) {
        return (0, Y.recoverAddress)(em.hash(O, T, L), J);
      }
      (T.TypedDataEncoder = em), (T.verifyTypedData = eb);
    },
    77806: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.ethers = void 0);
      let J = L(87152),
        W = J.__importStar(L(28757));
      (T.ethers = W), J.__exportStar(L(28757), T);
    },
    58978: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.AbstractProvider = T.UnmanagedSubscriber = void 0);
      let J = L(40431),
        W = L(98148),
        Y = L(15311),
        Z = L(41648),
        X = L(16989),
        ee = L(38478),
        et = L(25812),
        er = L(42560),
        en = L(61927),
        es = L(27773),
        ei = L(22896),
        ea = BigInt(2),
        eo = 10;
      function ec(O) {
        return O && "function" == typeof O.then;
      }
      function eu(O, T) {
        return (
          O +
          ":" +
          JSON.stringify(T, (O, T) => {
            if (null == T) return "null";
            if ("bigint" == typeof T) return `bigint:${T.toString()}`;
            if ("string" == typeof T) return T.toLowerCase();
            if ("object" == typeof T && !Array.isArray(T)) {
              let O = Object.keys(T);
              return O.sort(), O.reduce((O, L) => ((O[L] = T[L]), O), {});
            }
            return T;
          })
        );
      }
      class eh {
        constructor(O) {
          (0, ee.defineProperties)(this, { name: O });
        }
        start() {}
        stop() {}
        pause(O) {}
        resume() {}
      }
      function ed(O) {
        return JSON.parse(JSON.stringify(O));
      }
      function ep(O) {
        return (O = Array.from(new Set(O).values())).sort(), O;
      }
      async function eg(O, T) {
        if (null == O) throw Error("invalid event");
        if ((Array.isArray(O) && (O = { topics: O }), "string" == typeof O))
          switch (O) {
            case "block":
            case "debug":
            case "error":
            case "finalized":
            case "network":
            case "pending":
            case "safe":
              return { type: O, tag: O };
          }
        if ((0, ee.isHexString)(O, 32)) {
          let T = O.toLowerCase();
          return { type: "transaction", tag: eu("tx", { hash: T }), hash: T };
        }
        if (O.orphan) {
          let T = O;
          return { type: "orphan", tag: eu("orphan", T), filter: ed(T) };
        }
        if (O.address || O.topics) {
          let L = O,
            W = {
              topics: (L.topics || []).map((O) =>
                null == O
                  ? null
                  : Array.isArray(O)
                  ? ep(O.map((O) => O.toLowerCase()))
                  : O.toLowerCase()
              ),
            };
          if (L.address) {
            let O = [],
              Y = [],
              Z = (L) => {
                (0, ee.isHexString)(L)
                  ? O.push(L)
                  : Y.push(
                      (async () => {
                        O.push(await (0, J.resolveAddress)(L, T));
                      })()
                    );
              };
            Array.isArray(L.address) ? L.address.forEach(Z) : Z(L.address),
              Y.length && (await Promise.all(Y)),
              (W.address = ep(O.map((O) => O.toLowerCase())));
          }
          return { filter: W, tag: eu("event", W), type: "event" };
        }
        (0, ee.assertArgument)(!1, "unknown ProviderEvent", "event", O);
      }
      function ey() {
        return new Date().getTime();
      }
      T.UnmanagedSubscriber = eh;
      let em = { cacheTimeout: 250, pollingInterval: 4e3 };
      class eb {
        constructor(O, T) {
          if (((this.w__0 = Object.assign({}, em, T || {})), "any" === O))
            (this.D__0 = !0), (this.L__0 = null);
          else if (O) {
            let T = en.Network.from(O);
            (this.D__0 = !1),
              (this.L__0 = Promise.resolve(T)),
              setTimeout(() => {
                this.emit("network", T, null);
              }, 0);
          } else (this.D__0 = !1), (this.L__0 = null);
          (this.F__0 = -1),
            (this.TT__0 = new Map()),
            (this.R__0 = new Map()),
            (this.I__0 = new Map()),
            (this.M__0 = null),
            (this.U__0 = !1),
            (this.K__0 = 1),
            (this.j__0 = new Map()),
            (this.H__0 = !1);
        }
        get pollingInterval() {
          return this.w__0.pollingInterval;
        }
        get provider() {
          return this;
        }
        get plugins() {
          return Array.from(this.I__0.values());
        }
        attachPlugin(O) {
          if (this.I__0.get(O.name))
            throw Error(`cannot replace existing plugin: ${O.name} `);
          return this.I__0.set(O.name, O.connect(this)), this;
        }
        getPlugin(O) {
          return this.I__0.get(O) || null;
        }
        get disableCcipRead() {
          return this.H__0;
        }
        set disableCcipRead(O) {
          this.H__0 = !!O;
        }
        async __sp(O) {
          let T = this.w__0.cacheTimeout;
          if (T < 0) return await this._perform(O);
          let L = eu(O.method, O),
            J = this.TT__0.get(L);
          return (
            J ||
              ((J = this._perform(O)),
              this.TT__0.set(L, J),
              setTimeout(() => {
                this.TT__0.get(L) === J && this.TT__0.delete(L);
              }, T)),
            await J
          );
        }
        async ccipReadFetch(O, T, L) {
          if (this.disableCcipRead || 0 === L.length || null == O.to)
            return null;
          let J = O.to.toLowerCase(),
            W = T.toLowerCase(),
            Y = [];
          for (let T = 0; T < L.length; T++) {
            let Z = L[T],
              X = Z.replace("{sender}", J).replace("{data}", W),
              et = new ee.FetchRequest(X);
            -1 === Z.indexOf("{data}") && (et.body = { data: W, sender: J }),
              this.emit("debug", {
                action: "sendCcipReadFetchRequest",
                request: et,
                index: T,
                urls: L,
              });
            let er = "unknown error",
              en = await et.send();
            try {
              let O = en.bodyJson;
              if (O.data)
                return (
                  this.emit("debug", {
                    action: "receiveCcipReadFetchResult",
                    request: et,
                    result: O,
                  }),
                  O.data
                );
              O.message && (er = O.message),
                this.emit("debug", {
                  action: "receiveCcipReadFetchError",
                  request: et,
                  result: O,
                });
            } catch (O) {}
            (0, ee.assert)(
              en.statusCode < 400 || en.statusCode >= 500,
              `response not found during CCIP fetch: ${er}`,
              "OFFCHAIN_FAULT",
              {
                reason: "404_MISSING_RESOURCE",
                transaction: O,
                info: { url: Z, errorMessage: er },
              }
            ),
              Y.push(er);
          }
          (0, ee.assert)(
            !1,
            `error encountered during CCIP fetch: ${Y.map((O) =>
              JSON.stringify(O)
            ).join(", ")}`,
            "OFFCHAIN_FAULT",
            {
              reason: "500_SERVER_ERROR",
              transaction: O,
              info: { urls: L, errorMessages: Y },
            }
          );
        }
        _wrapBlock(O, T) {
          return new es.Block((0, er.formatBlock)(O), this);
        }
        _wrapLog(O, T) {
          return new es.Log((0, er.formatLog)(O), this);
        }
        _wrapTransactionReceipt(O, T) {
          return new es.TransactionReceipt(
            (0, er.formatTransactionReceipt)(O),
            this
          );
        }
        _wrapTransactionResponse(O, T) {
          return new es.TransactionResponse(
            (0, er.formatTransactionResponse)(O),
            this
          );
        }
        _detectNetwork() {
          (0, ee.assert)(
            !1,
            "sub-classes must implement this",
            "UNSUPPORTED_OPERATION",
            { operation: "_detectNetwork" }
          );
        }
        async _perform(O) {
          (0, ee.assert)(
            !1,
            `unsupported method: ${O.method}`,
            "UNSUPPORTED_OPERATION",
            { operation: O.method, info: O }
          );
        }
        async getBlockNumber() {
          let O = (0, ee.getNumber)(
            await this.__sp({ method: "getBlockNumber" }),
            "%response"
          );
          return this.F__0 >= 0 && (this.F__0 = O), O;
        }
        _getAddress(O) {
          return (0, J.resolveAddress)(O, this);
        }
        _getBlockTag(O) {
          if (null == O) return "latest";
          switch (O) {
            case "earliest":
              return "0x0";
            case "finalized":
            case "latest":
            case "pending":
            case "safe":
              return O;
          }
          return (0, ee.isHexString)(O)
            ? (0, ee.isHexString)(O, 32)
              ? O
              : (0, ee.toQuantity)(O)
            : ("bigint" == typeof O && (O = (0, ee.getNumber)(O, "blockTag")),
              "number" == typeof O)
            ? O >= 0
              ? (0, ee.toQuantity)(O)
              : this.F__0 >= 0
              ? (0, ee.toQuantity)(this.F__0 + O)
              : this.getBlockNumber().then((T) => (0, ee.toQuantity)(T + O))
            : void (0, ee.assertArgument)(
                !1,
                "invalid blockTag",
                "blockTag",
                O
              );
        }
        _getFilter(O) {
          let T, L;
          let J = (O.topics || []).map((O) =>
              null == O
                ? null
                : Array.isArray(O)
                ? ep(O.map((O) => O.toLowerCase()))
                : O.toLowerCase()
            ),
            W = "blockHash" in O ? O.blockHash : void 0,
            Y = (O, T, L) => {
              let Y;
              switch (O.length) {
                case 0:
                  break;
                case 1:
                  Y = O[0];
                  break;
                default:
                  O.sort(), (Y = O);
              }
              if (W && (null != T || null != L)) throw Error("invalid filter");
              let Z = {};
              return (
                Y && (Z.address = Y),
                J.length && (Z.topics = J),
                T && (Z.fromBlock = T),
                L && (Z.toBlock = L),
                W && (Z.blockHash = W),
                Z
              );
            },
            Z = [];
          if (O.address) {
            if (Array.isArray(O.address))
              for (let T of O.address) Z.push(this._getAddress(T));
            else Z.push(this._getAddress(O.address));
          }
          return (
            "fromBlock" in O && (T = this._getBlockTag(O.fromBlock)),
            ("toBlock" in O && (L = this._getBlockTag(O.toBlock)),
            Z.filter((O) => "string" != typeof O).length ||
              (null != T && "string" != typeof T) ||
              (null != L && "string" != typeof L))
              ? Promise.all([Promise.all(Z), T, L]).then((O) =>
                  Y(O[0], O[1], O[2])
                )
              : Y(Z, T, L)
          );
        }
        _getTransactionRequest(O) {
          let T = (0, es.copyRequest)(O),
            L = [];
          if (
            (["to", "from"].forEach((O) => {
              if (null == T[O]) return;
              let W = (0, J.resolveAddress)(T[O], this);
              ec(W)
                ? L.push(
                    (async function () {
                      T[O] = await W;
                    })()
                  )
                : (T[O] = W);
            }),
            null != T.blockTag)
          ) {
            let O = this._getBlockTag(T.blockTag);
            ec(O)
              ? L.push(
                  (async function () {
                    T.blockTag = await O;
                  })()
                )
              : (T.blockTag = O);
          }
          return L.length
            ? (async function () {
                return await Promise.all(L), T;
              })()
            : T;
        }
        async getNetwork() {
          if (null == this.L__0) {
            let O = (async () => {
              try {
                let O = await this._detectNetwork();
                return this.emit("network", O, null), O;
              } catch (T) {
                throw (this.L__0 === O && (this.L__0 = null), T);
              }
            })();
            return (this.L__0 = O), (await O).clone();
          }
          let O = this.L__0,
            [T, L] = await Promise.all([O, this._detectNetwork()]);
          return (
            T.chainId !== L.chainId &&
              (this.D__0
                ? (this.emit("network", L, T),
                  this.L__0 === O && (this.L__0 = Promise.resolve(L)))
                : (0, ee.assert)(
                    !1,
                    `network changed: ${T.chainId} => ${L.chainId} `,
                    "NETWORK_ERROR",
                    { event: "changed" }
                  )),
            T.clone()
          );
        }
        async getFeeData() {
          let O = await this.getNetwork(),
            T = async () => {
              let {
                  _block: T,
                  gasPrice: L,
                  priorityFee: J,
                } = await (0, ee.resolveProperties)({
                  _block: this.__V("latest", !1),
                  gasPrice: (async () => {
                    try {
                      let O = await this.__sp({ method: "getGasPrice" });
                      return (0, ee.getBigInt)(O, "%response");
                    } catch (O) {}
                    return null;
                  })(),
                  priorityFee: (async () => {
                    try {
                      let O = await this.__sp({ method: "getPriorityFee" });
                      return (0, ee.getBigInt)(O, "%response");
                    } catch (O) {}
                    return null;
                  })(),
                }),
                W = null,
                Y = null,
                Z = this._wrapBlock(T, O);
              return (
                Z &&
                  Z.baseFeePerGas &&
                  ((Y = null != J ? J : BigInt("1000000000")),
                  (W = Z.baseFeePerGas * ea + Y)),
                new es.FeeData(L, W, Y)
              );
            },
            L = O.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
          if (L) {
            let O = new ee.FetchRequest(L.url),
              J = await L.processFunc(T, this, O);
            return new es.FeeData(
              J.gasPrice,
              J.maxFeePerGas,
              J.maxPriorityFeePerGas
            );
          }
          return await T();
        }
        async estimateGas(O) {
          let T = this._getTransactionRequest(O);
          return (
            ec(T) && (T = await T),
            (0, ee.getBigInt)(
              await this.__sp({ method: "estimateGas", transaction: T }),
              "%response"
            )
          );
        }
        async __G(O, T, L) {
          (0, ee.assert)(
            L < eo,
            "CCIP read exceeded maximum redirections",
            "OFFCHAIN_FAULT",
            {
              reason: "TOO_MANY_REDIRECTS",
              transaction: Object.assign({}, O, {
                blockTag: T,
                enableCcipRead: !0,
              }),
            }
          );
          let W = (0, es.copyRequest)(O);
          try {
            return (0, ee.hexlify)(
              await this._perform({
                method: "call",
                transaction: W,
                blockTag: T,
              })
            );
          } catch (O) {
            if (
              !this.disableCcipRead &&
              (0, ee.isCallException)(O) &&
              O.data &&
              L >= 0 &&
              "latest" === T &&
              null != W.to &&
              "0x556f1830" === (0, ee.dataSlice)(O.data, 0, 4)
            ) {
              let Y;
              let Z = O.data,
                X = await (0, J.resolveAddress)(W.to, this);
              try {
                Y = eC((0, ee.dataSlice)(O.data, 4));
              } catch (O) {
                (0, ee.assert)(!1, O.message, "OFFCHAIN_FAULT", {
                  reason: "BAD_DATA",
                  transaction: W,
                  info: { data: Z },
                });
              }
              (0, ee.assert)(
                Y.sender.toLowerCase() === X.toLowerCase(),
                "CCIP Read sender mismatch",
                "CALL_EXCEPTION",
                {
                  action: "call",
                  data: Z,
                  reason: "OffchainLookup",
                  transaction: W,
                  invocation: null,
                  revert: {
                    signature:
                      "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    name: "OffchainLookup",
                    args: Y.errorArgs,
                  },
                }
              );
              let et = await this.ccipReadFetch(W, Y.calldata, Y.urls);
              (0, ee.assert)(
                null != et,
                "CCIP Read failed to fetch data",
                "OFFCHAIN_FAULT",
                {
                  reason: "FETCH_FAILED",
                  transaction: W,
                  info: { data: O.data, errorArgs: Y.errorArgs },
                }
              );
              let er = {
                to: X,
                data: (0, ee.concat)([Y.selector, eS([et, Y.extraData])]),
              };
              this.emit("debug", {
                action: "sendCcipReadCall",
                transaction: er,
              });
              try {
                let O = await this.__G(er, T, L + 1);
                return (
                  this.emit("debug", {
                    action: "receiveCcipReadCallResult",
                    transaction: Object.assign({}, er),
                    result: O,
                  }),
                  O
                );
              } catch (O) {
                throw (
                  (this.emit("debug", {
                    action: "receiveCcipReadCallError",
                    transaction: Object.assign({}, er),
                    error: O,
                  }),
                  O)
                );
              }
            }
            throw O;
          }
        }
        async __J(O) {
          let { value: T } = await (0, ee.resolveProperties)({
            network: this.getNetwork(),
            value: O,
          });
          return T;
        }
        async call(O) {
          let { tx: T, blockTag: L } = await (0, ee.resolveProperties)({
            tx: this._getTransactionRequest(O),
            blockTag: this._getBlockTag(O.blockTag),
          });
          return await this.__J(this.__G(T, L, O.enableCcipRead ? 0 : -1));
        }
        async z__0(O, T, L) {
          let J = this._getAddress(T),
            W = this._getBlockTag(L);
          return (
            ("string" != typeof J || "string" != typeof W) &&
              ([J, W] = await Promise.all([J, W])),
            await this.__J(
              this.__sp(Object.assign(O, { address: J, blockTag: W }))
            )
          );
        }
        async getBalance(O, T) {
          return (0, ee.getBigInt)(
            await this.z__0({ method: "getBalance" }, O, T),
            "%response"
          );
        }
        async getTransactionCount(O, T) {
          return (0, ee.getNumber)(
            await this.z__0({ method: "getTransactionCount" }, O, T),
            "%response"
          );
        }
        async getCode(O, T) {
          return (0, ee.hexlify)(await this.z__0({ method: "getCode" }, O, T));
        }
        async getStorage(O, T, L) {
          let J = (0, ee.getBigInt)(T, "position");
          return (0, ee.hexlify)(
            await this.z__0({ method: "getStorage", position: J }, O, L)
          );
        }
        async broadcastTransaction(O) {
          let {
              blockNumber: T,
              hash: L,
              network: J,
            } = await (0, ee.resolveProperties)({
              blockNumber: this.getBlockNumber(),
              hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: O,
              }),
              network: this.getNetwork(),
            }),
            W = X.Transaction.from(O);
          if (W.hash !== L)
            throw Error("@TODO: the returned hash did not match");
          return this._wrapTransactionResponse(W, J).replaceableTransaction(T);
        }
        async __V(O, T) {
          if ((0, ee.isHexString)(O, 32))
            return await this.__sp({
              method: "getBlock",
              blockHash: O,
              includeTransactions: T,
            });
          let L = this._getBlockTag(O);
          return (
            "string" != typeof L && (L = await L),
            await this.__sp({
              method: "getBlock",
              blockTag: L,
              includeTransactions: T,
            })
          );
        }
        async getBlock(O, T) {
          let { network: L, params: J } = await (0, ee.resolveProperties)({
            network: this.getNetwork(),
            params: this.__V(O, !!T),
          });
          return null == J ? null : this._wrapBlock(J, L);
        }
        async getTransaction(O) {
          let { network: T, params: L } = await (0, ee.resolveProperties)({
            network: this.getNetwork(),
            params: this.__sp({ method: "getTransaction", hash: O }),
          });
          return null == L ? null : this._wrapTransactionResponse(L, T);
        }
        async getTransactionReceipt(O) {
          let { network: T, params: L } = await (0, ee.resolveProperties)({
            network: this.getNetwork(),
            params: this.__sp({ method: "getTransactionReceipt", hash: O }),
          });
          if (null == L) return null;
          if (null == L.gasPrice && null == L.effectiveGasPrice) {
            let T = await this.__sp({ method: "getTransaction", hash: O });
            if (null == T)
              throw Error(
                "report this; could not find tx or effectiveGasPrice"
              );
            L.effectiveGasPrice = T.gasPrice;
          }
          return this._wrapTransactionReceipt(L, T);
        }
        async getTransactionResult(O) {
          let { result: T } = await (0, ee.resolveProperties)({
            network: this.getNetwork(),
            result: this.__sp({ method: "getTransactionResult", hash: O }),
          });
          return null == T ? null : (0, ee.hexlify)(T);
        }
        async getLogs(O) {
          let T = this._getFilter(O);
          ec(T) && (T = await T);
          let { network: L, params: J } = await (0, ee.resolveProperties)({
            network: this.getNetwork(),
            params: this.__sp({ method: "getLogs", filter: T }),
          });
          return J.map((O) => this._wrapLog(O, L));
        }
        _getProvider(O) {
          (0, ee.assert)(
            !1,
            "provider cannot connect to target network",
            "UNSUPPORTED_OPERATION",
            { operation: "_getProvider()" }
          );
        }
        async getResolver(O) {
          return await et.EnsResolver.fromName(this, O);
        }
        async getAvatar(O) {
          let T = await this.getResolver(O);
          return T ? await T.getAvatar() : null;
        }
        async resolveName(O) {
          let T = await this.getResolver(O);
          return T ? await T.getAddress() : null;
        }
        async lookupAddress(O) {
          O = (0, J.getAddress)(O);
          let T = (0, Z.namehash)(
            O.substring(2).toLowerCase() + ".addr.reverse"
          );
          try {
            let L = await et.EnsResolver.getEnsAddress(this),
              J = new Y.Contract(
                L,
                ["function resolver(bytes32) view returns (address)"],
                this
              ),
              Z = await J.resolver(T);
            if (null == Z || Z === W.ZeroAddress) return null;
            let X = new Y.Contract(
                Z,
                ["function name(bytes32) view returns (string)"],
                this
              ),
              ee = await X.name(T);
            if ((await this.resolveName(ee)) !== O) return null;
            return ee;
          } catch (O) {
            if (
              ((0, ee.isError)(O, "BAD_DATA") && "0x" === O.value) ||
              (0, ee.isError)(O, "CALL_EXCEPTION")
            )
              return null;
            throw O;
          }
          return null;
        }
        async waitForTransaction(O, T, L) {
          let J = null != T ? T : 1;
          return 0 === J
            ? this.getTransactionReceipt(O)
            : new Promise(async (T, W) => {
                let Y = null,
                  Z = async (L) => {
                    try {
                      let W = await this.getTransactionReceipt(O);
                      if (null != W && L - W.blockNumber + 1 >= J) {
                        T(W), Y && (clearTimeout(Y), (Y = null));
                        return;
                      }
                    } catch (O) {
                      console.log("EEE", O);
                    }
                    this.once("block", Z);
                  };
                null != L &&
                  (Y = setTimeout(() => {
                    null != Y &&
                      ((Y = null),
                      this.off("block", Z),
                      W(
                        (0, ee.makeError)("timeout", "TIMEOUT", {
                          reason: "timeout",
                        })
                      ));
                  }, L)),
                  Z(await this.getBlockNumber());
              });
        }
        async waitForBlock(O) {
          (0, ee.assert)(!1, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock",
          });
        }
        _clearTimeout(O) {
          let T = this.j__0.get(O);
          T && (T.timer && clearTimeout(T.timer), this.j__0.delete(O));
        }
        _setTimeout(O, T) {
          null == T && (T = 0);
          let L = this.K__0++,
            J = () => {
              this.j__0.delete(L), O();
            };
          if (this.paused) this.j__0.set(L, { timer: null, func: J, time: T });
          else {
            let O = setTimeout(J, T);
            this.j__0.set(L, { timer: O, func: J, time: ey() });
          }
          return L;
        }
        _forEachSubscriber(O) {
          for (let T of this.R__0.values()) O(T.subscriber);
        }
        _getSubscriber(O) {
          switch (O.type) {
            case "debug":
            case "error":
            case "network":
              return new eh(O.type);
            case "block": {
              let O = new ei.PollingBlockSubscriber(this);
              return (O.pollingInterval = this.pollingInterval), O;
            }
            case "safe":
            case "finalized":
              return new ei.PollingBlockTagSubscriber(this, O.type);
            case "event":
              return new ei.PollingEventSubscriber(this, O.filter);
            case "transaction":
              return new ei.PollingTransactionSubscriber(this, O.hash);
            case "orphan":
              return new ei.PollingOrphanSubscriber(this, O.filter);
          }
          throw Error(`unsupported event: ${O.type}`);
        }
        _recoverSubscriber(O, T) {
          for (let L of this.R__0.values())
            if (L.subscriber === O) {
              L.started && L.subscriber.stop(),
                (L.subscriber = T),
                L.started && T.start(),
                null != this.M__0 && T.pause(this.M__0);
              break;
            }
        }
        async Q__0(O, T) {
          let L = await eg(O, this);
          return (
            "event" === L.type &&
              T &&
              T.length > 0 &&
              !0 === T[0].removed &&
              (L = await eg({ orphan: "drop-log", log: T[0] }, this)),
            this.R__0.get(L.tag) || null
          );
        }
        async q__0(O) {
          let T = await eg(O, this),
            L = T.tag,
            J = this.R__0.get(L);
          return (
            !J &&
              ((J = {
                subscriber: this._getSubscriber(T),
                tag: L,
                addressableMap: new WeakMap(),
                nameMap: new Map(),
                started: !1,
                listeners: [],
              }),
              this.R__0.set(L, J)),
            J
          );
        }
        async on(O, T) {
          let L = await this.q__0(O);
          return (
            L.listeners.push({ listener: T, once: !1 }),
            L.started ||
              (L.subscriber.start(),
              (L.started = !0),
              null != this.M__0 && L.subscriber.pause(this.M__0)),
            this
          );
        }
        async once(O, T) {
          let L = await this.q__0(O);
          return (
            L.listeners.push({ listener: T, once: !0 }),
            L.started ||
              (L.subscriber.start(),
              (L.started = !0),
              null != this.M__0 && L.subscriber.pause(this.M__0)),
            this
          );
        }
        async emit(O, ...T) {
          let L = await this.Q__0(O, T);
          if (!L || 0 === L.listeners.length) return !1;
          let J = L.listeners.length;
          return (
            (L.listeners = L.listeners.filter(({ listener: L, once: J }) => {
              let W = new ee.EventPayload(this, J ? null : L, O);
              try {
                L.call(this, ...T, W);
              } catch (O) {}
              return !J;
            })),
            0 === L.listeners.length &&
              (L.started && L.subscriber.stop(), this.R__0.delete(L.tag)),
            J > 0
          );
        }
        async listenerCount(O) {
          if (O) {
            let T = await this.Q__0(O);
            return T ? T.listeners.length : 0;
          }
          let T = 0;
          for (let { listeners: O } of this.R__0.values()) T += O.length;
          return T;
        }
        async listeners(O) {
          if (O) {
            let T = await this.Q__0(O);
            return T ? T.listeners.map(({ listener: O }) => O) : [];
          }
          let T = [];
          for (let { listeners: O } of this.R__0.values())
            T = T.concat(O.map(({ listener: O }) => O));
          return T;
        }
        async off(O, T) {
          let L = await this.Q__0(O);
          if (!L) return this;
          if (T) {
            let O = L.listeners.map(({ listener: O }) => O).indexOf(T);
            O >= 0 && L.listeners.splice(O, 1);
          }
          return (
            (T && 0 !== L.listeners.length) ||
              (L.started && L.subscriber.stop(), this.R__0.delete(L.tag)),
            this
          );
        }
        async removeAllListeners(O) {
          if (O) {
            let { tag: T, started: L, subscriber: J } = await this.q__0(O);
            L && J.stop(), this.R__0.delete(T);
          } else
            for (let [O, { started: T, subscriber: L }] of this.R__0)
              T && L.stop(), this.R__0.delete(O);
          return this;
        }
        async addListener(O, T) {
          return await this.on(O, T);
        }
        async removeListener(O, T) {
          return this.off(O, T);
        }
        get destroyed() {
          return this.U__0;
        }
        destroy() {
          for (let O of (this.removeAllListeners(), this.j__0.keys()))
            this._clearTimeout(O);
          this.U__0 = !0;
        }
        get paused() {
          return null != this.M__0;
        }
        set paused(O) {
          !!O !== this.paused && (this.paused ? this.resume() : this.pause(!1));
        }
        pause(O) {
          if (((this.F__0 = -1), null != this.M__0)) {
            if (!!O == this.M__0) return;
            (0, ee.assert)(
              !1,
              "cannot change pause type; resume first",
              "UNSUPPORTED_OPERATION",
              { operation: "pause" }
            );
          }
          for (let T of (this._forEachSubscriber((T) => T.pause(O)),
          (this.M__0 = !!O),
          this.j__0.values()))
            T.timer && clearTimeout(T.timer), (T.time = ey() - T.time);
        }
        resume() {
          if (null != this.M__0)
            for (let O of (this._forEachSubscriber((O) => O.resume()),
            (this.M__0 = null),
            this.j__0.values())) {
              let T = O.time;
              T < 0 && (T = 0), (O.time = ey()), setTimeout(O.func, T);
            }
        }
      }
      function eA(O, T) {
        try {
          let L = ew(O, T);
          if (L) return (0, ee.toUtf8String)(L);
        } catch (O) {}
        return null;
      }
      function ew(O, T) {
        if ("0x" === O) return null;
        try {
          let L = (0, ee.getNumber)((0, ee.dataSlice)(O, T, T + 32)),
            J = (0, ee.getNumber)((0, ee.dataSlice)(O, L, L + 32));
          return (0, ee.dataSlice)(O, L + 32, L + 32 + J);
        } catch (O) {}
        return null;
      }
      function ev(O) {
        let T = (0, ee.toBeArray)(O);
        if (T.length > 32) throw Error("internal; should not happen");
        let L = new Uint8Array(32);
        return L.set(T, 32 - T.length), L;
      }
      function ek(O) {
        if (O.length % 32 == 0) return O;
        let T = new Uint8Array(32 * Math.ceil(O.length / 32));
        return T.set(O), T;
      }
      T.AbstractProvider = eb;
      let eE = new Uint8Array([]);
      function eS(O) {
        let T = [],
          L = 0;
        for (let J = 0; J < O.length; J++) T.push(eE), (L += 32);
        for (let J = 0; J < O.length; J++) {
          let W = (0, ee.getBytes)(O[J]);
          (T[J] = ev(L)),
            T.push(ev(W.length)),
            T.push(ek(W)),
            (L += 32 + 32 * Math.ceil(W.length / 32));
        }
        return (0, ee.concat)(T);
      }
      let eP =
        "0x0000000000000000000000000000000000000000000000000000000000000000";
      function eC(O) {
        let T = {
          sender: "",
          urls: [],
          calldata: "",
          selector: "",
          extraData: "",
          errorArgs: [],
        };
        (0, ee.assert)(
          (0, ee.dataLength)(O) >= 160,
          "insufficient OffchainLookup data",
          "OFFCHAIN_FAULT",
          { reason: "insufficient OffchainLookup data" }
        );
        let L = (0, ee.dataSlice)(O, 0, 32);
        (0, ee.assert)(
          (0, ee.dataSlice)(L, 0, 12) === (0, ee.dataSlice)(eP, 0, 12),
          "corrupt OffchainLookup sender",
          "OFFCHAIN_FAULT",
          { reason: "corrupt OffchainLookup sender" }
        ),
          (T.sender = (0, ee.dataSlice)(L, 12));
        try {
          let L = [],
            J = (0, ee.getNumber)((0, ee.dataSlice)(O, 32, 64)),
            W = (0, ee.getNumber)((0, ee.dataSlice)(O, J, J + 32)),
            Y = (0, ee.dataSlice)(O, J + 32);
          for (let O = 0; O < W; O++) {
            let T = eA(Y, 32 * O);
            if (null == T) throw Error("abort");
            L.push(T);
          }
          T.urls = L;
        } catch (O) {
          (0, ee.assert)(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup urls",
          });
        }
        try {
          let L = ew(O, 64);
          if (null == L) throw Error("abort");
          T.calldata = L;
        } catch (O) {
          (0, ee.assert)(
            !1,
            "corrupt OffchainLookup calldata",
            "OFFCHAIN_FAULT",
            { reason: "corrupt OffchainLookup calldata" }
          );
        }
        (0, ee.assert)(
          (0, ee.dataSlice)(O, 100, 128) === (0, ee.dataSlice)(eP, 0, 28),
          "corrupt OffchainLookup callbaackSelector",
          "OFFCHAIN_FAULT",
          { reason: "corrupt OffchainLookup callbaackSelector" }
        ),
          (T.selector = (0, ee.dataSlice)(O, 96, 100));
        try {
          let L = ew(O, 128);
          if (null == L) throw Error("abort");
          T.extraData = L;
        } catch (O) {
          (0, ee.assert)(
            !1,
            "corrupt OffchainLookup extraData",
            "OFFCHAIN_FAULT",
            { reason: "corrupt OffchainLookup extraData" }
          );
        }
        return (
          (T.errorArgs = "sender,urls,calldata,selector,extraData"
            .split(/,/)
            .map((O) => T[O])),
          T
        );
      }
    },
    70690: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.VoidSigner = T.AbstractSigner = void 0);
      let J = L(40431),
        W = L(16989),
        Y = L(38478),
        Z = L(27773);
      function X(O, T) {
        if (O.provider) return O.provider;
        (0, Y.assert)(!1, "missing provider", "UNSUPPORTED_OPERATION", {
          operation: T,
        });
      }
      async function ee(O, T) {
        let L = (0, Z.copyRequest)(T);
        if (
          (null != L.to && (L.to = (0, J.resolveAddress)(L.to, O)),
          null != L.from)
        ) {
          let T = L.from;
          L.from = Promise.all([
            O.getAddress(),
            (0, J.resolveAddress)(T, O),
          ]).then(
            ([O, T]) => (
              (0, Y.assertArgument)(
                O.toLowerCase() === T.toLowerCase(),
                "transaction from mismatch",
                "tx.from",
                T
              ),
              O
            )
          );
        } else L.from = O.getAddress();
        return await (0, Y.resolveProperties)(L);
      }
      class et {
        constructor(O) {
          (0, Y.defineProperties)(this, { provider: O || null });
        }
        async getNonce(O) {
          return X(this, "getTransactionCount").getTransactionCount(
            await this.getAddress(),
            O
          );
        }
        async populateCall(O) {
          return await ee(this, O);
        }
        async populateTransaction(O) {
          let T = X(this, "populateTransaction"),
            L = await ee(this, O);
          null == L.nonce && (L.nonce = await this.getNonce("pending")),
            null == L.gasLimit && (L.gasLimit = await this.estimateGas(L));
          let J = await this.provider.getNetwork();
          if (null != L.chainId) {
            let T = (0, Y.getBigInt)(L.chainId);
            (0, Y.assertArgument)(
              T === J.chainId,
              "transaction chainId mismatch",
              "tx.chainId",
              O.chainId
            );
          } else L.chainId = J.chainId;
          let W = null != L.maxFeePerGas || null != L.maxPriorityFeePerGas;
          if (
            (null != L.gasPrice && (2 === L.type || W)
              ? (0, Y.assertArgument)(
                  !1,
                  "eip-1559 transaction do not support gasPrice",
                  "tx",
                  O
                )
              : (0 === L.type || 1 === L.type) &&
                W &&
                (0, Y.assertArgument)(
                  !1,
                  "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
                  "tx",
                  O
                ),
            (2 === L.type || null == L.type) &&
              null != L.maxFeePerGas &&
              null != L.maxPriorityFeePerGas)
          )
            L.type = 2;
          else if (0 === L.type || 1 === L.type) {
            let O = await T.getFeeData();
            (0, Y.assert)(
              null != O.gasPrice,
              "network does not support gasPrice",
              "UNSUPPORTED_OPERATION",
              { operation: "getGasPrice" }
            ),
              null == L.gasPrice && (L.gasPrice = O.gasPrice);
          } else {
            let O = await T.getFeeData();
            if (null == L.type) {
              if (null != O.maxFeePerGas && null != O.maxPriorityFeePerGas) {
                if (((L.type = 2), null != L.gasPrice)) {
                  let O = L.gasPrice;
                  delete L.gasPrice,
                    (L.maxFeePerGas = O),
                    (L.maxPriorityFeePerGas = O);
                } else
                  null == L.maxFeePerGas && (L.maxFeePerGas = O.maxFeePerGas),
                    null == L.maxPriorityFeePerGas &&
                      (L.maxPriorityFeePerGas = O.maxPriorityFeePerGas);
              } else
                null != O.gasPrice
                  ? ((0, Y.assert)(
                      !W,
                      "network does not support EIP-1559",
                      "UNSUPPORTED_OPERATION",
                      { operation: "populateTransaction" }
                    ),
                    null == L.gasPrice && (L.gasPrice = O.gasPrice),
                    (L.type = 0))
                  : (0, Y.assert)(
                      !1,
                      "failed to get consistent fee data",
                      "UNSUPPORTED_OPERATION",
                      { operation: "signer.getFeeData" }
                    );
            } else
              2 === L.type &&
                (null == L.maxFeePerGas && (L.maxFeePerGas = O.maxFeePerGas),
                null == L.maxPriorityFeePerGas &&
                  (L.maxPriorityFeePerGas = O.maxPriorityFeePerGas));
          }
          return await (0, Y.resolveProperties)(L);
        }
        async estimateGas(O) {
          return X(this, "estimateGas").estimateGas(await this.populateCall(O));
        }
        async call(O) {
          return X(this, "call").call(await this.populateCall(O));
        }
        async resolveName(O) {
          let T = X(this, "resolveName");
          return await T.resolveName(O);
        }
        async sendTransaction(O) {
          let T = X(this, "sendTransaction"),
            L = await this.populateTransaction(O);
          delete L.from;
          let J = W.Transaction.from(L);
          return await T.broadcastTransaction(await this.signTransaction(J));
        }
      }
      T.AbstractSigner = et;
      class er extends et {
        constructor(O, T) {
          super(T), (0, Y.defineProperties)(this, { address: O });
        }
        async getAddress() {
          return this.address;
        }
        connect(O) {
          return new er(this.address, O);
        }
        __W(O, T) {
          (0, Y.assert)(
            !1,
            `VoidSigner cannot sign ${O}`,
            "UNSUPPORTED_OPERATION",
            { operation: T }
          );
        }
        async signTransaction(O) {
          this.__W("transactions", "signTransaction");
        }
        async signMessage(O) {
          this.__W("messages", "signMessage");
        }
        async signTypedData(O, T, L) {
          this.__W("typed-data", "signTypedData");
        }
      }
      T.VoidSigner = er;
    },
    80734: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.showThrottleMessage = void 0);
      let L = new Set();
      function J(O) {
        L.has(O) ||
          (L.add(O),
          console.log("========= NOTICE ========="),
          console.log(
            `Request-Rate Exceeded for ${O} (this message will not be repeated)`
          ),
          console.log(""),
          console.log(
            "The default API keys for each service are provided as a highly-throttled,"
          ),
          console.log(
            "community resource for low-traffic projects and early prototyping."
          ),
          console.log(""),
          console.log(
            "While your application will continue to function, we highly recommended"
          ),
          console.log(
            "signing up for your own API keys to improve performance, increase your"
          ),
          console.log(
            "request rate/limit and enable other perks, such as metrics and advanced APIs."
          ),
          console.log(""),
          console.log("For more details: https://docs.ethers.org/api-keys/"),
          console.log("=========================="));
      }
      T.showThrottleMessage = J;
    },
    48904: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.getDefaultProvider = void 0);
      let J = L(38478),
        W = L(19416),
        Y = L(7285),
        Z = L(97448),
        X = L(38580),
        ee = L(26860),
        et = L(41980),
        er = L(36843),
        en = L(88997),
        es = L(61927),
        ei = L(82083);
      function ea(O) {
        return O && "function" == typeof O.send && "function" == typeof O.close;
      }
      let eo =
        "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(
          " "
        );
      function ec(O, T) {
        null == T && (T = {});
        let L = (O) =>
          "-" !== T[O] &&
          ("string" == typeof T.exclusive
            ? O === T.exclusive
            : !Array.isArray(T.exclusive) || -1 !== T.exclusive.indexOf(O));
        if ("string" == typeof O && O.match(/^https?:/))
          return new en.JsonRpcProvider(O);
        if (("string" == typeof O && O.match(/^wss?:/)) || ea(O))
          return new ei.WebSocketProvider(O);
        let ec = null;
        try {
          ec = es.Network.from(O);
        } catch (O) {}
        let eu = [];
        if (
          (L("publicPolygon") &&
            ec &&
            "matic" === ec.name &&
            eu.push(
              new en.JsonRpcProvider("https://polygon-rpc.com/", ec, {
                staticNetwork: ec,
              })
            ),
          L("alchemy"))
        )
          try {
            eu.push(new Y.AlchemyProvider(O, T.alchemy));
          } catch (O) {}
        if (L("ankr") && null != T.ankr)
          try {
            eu.push(new W.AnkrProvider(O, T.ankr));
          } catch (O) {}
        if (L("cloudflare"))
          try {
            eu.push(new Z.CloudflareProvider(O));
          } catch (O) {}
        if (L("etherscan"))
          try {
            eu.push(new X.EtherscanProvider(O, T.etherscan));
          } catch (O) {}
        if (L("infura"))
          try {
            let L,
              J = T.infura;
            "object" == typeof J && ((L = J.projectSecret), (J = J.projectId)),
              eu.push(new ee.InfuraProvider(O, J, L));
          } catch (O) {}
        if (L("quicknode"))
          try {
            let L = T.quicknode;
            eu.push(new et.QuickNodeProvider(O, L));
          } catch (O) {}
        if (
          ((0, J.assert)(
            eu.length,
            "unsupported default network",
            "UNSUPPORTED_OPERATION",
            { operation: "getDefaultProvider" }
          ),
          1 === eu.length)
        )
          return eu[0];
        let eh = Math.floor(eu.length / 2);
        return (
          eh > 2 && (eh = 2),
          ec && -1 !== eo.indexOf(ec.name) && (eh = 1),
          T && T.quorum && (eh = T.quorum),
          new er.FallbackProvider(eu, void 0, { quorum: eh })
        );
      }
      T.getDefaultProvider = ec;
    },
    25812: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.EnsResolver =
          T.BasicMulticoinProviderPlugin =
          T.MulticoinProviderPlugin =
            void 0);
      let J = L(40431),
        W = L(98148),
        Y = L(15311),
        Z = L(41648),
        X = L(38478);
      function ee(O) {
        return (
          O.match(/^ipfs:\/\/ipfs\//i)
            ? (O = O.substring(12))
            : O.match(/^ipfs:\/\//i)
            ? (O = O.substring(7))
            : (0, X.assertArgument)(!1, "unsupported IPFS format", "link", O),
          `https://gateway.ipfs.io/ipfs/${O}`
        );
      }
      class et {
        constructor(O) {
          (0, X.defineProperties)(this, { name: O });
        }
        connect(O) {
          return this;
        }
        supportsCoinType(O) {
          return !1;
        }
        async encodeAddress(O, T) {
          throw Error("unsupported coin");
        }
        async decodeAddress(O, T) {
          throw Error("unsupported coin");
        }
      }
      T.MulticoinProviderPlugin = et;
      let er = "org.ethers.plugins.provider.BasicMulticoin";
      class en extends et {
        constructor() {
          super(er);
        }
      }
      T.BasicMulticoinProviderPlugin = en;
      let es = RegExp("^(ipfs)://(.*)$", "i"),
        ei = [
          RegExp("^(https)://(.*)$", "i"),
          RegExp("^(data):(.*)$", "i"),
          es,
          RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
        ];
      class ea {
        constructor(O, T, L) {
          (0, X.defineProperties)(this, { provider: O, address: T, name: L }),
            (this.Y__0 = null),
            (this.Z__0 = new Y.Contract(
              T,
              [
                "function supportsInterface(bytes4) view returns (bool)",
                "function resolve(bytes, bytes) view returns (bytes)",
                "function addr(bytes32) view returns (address)",
                "function addr(bytes32, uint) view returns (bytes)",
                "function text(bytes32, string) view returns (string)",
                "function contenthash(bytes32) view returns (bytes)",
              ],
              O
            ));
        }
        async supportsWildcard() {
          return (
            null == this.Y__0 &&
              (this.Y__0 = (async () => {
                try {
                  return await this.Z__0.supportsInterface("0x9061b923");
                } catch (O) {
                  if ((0, X.isError)(O, "CALL_EXCEPTION")) return !1;
                  throw ((this.Y__0 = null), O);
                }
              })()),
            await this.Y__0
          );
        }
        async __X(O, T) {
          T = (T || []).slice();
          let L = this.Z__0.interface;
          T.unshift((0, Z.namehash)(this.name));
          let J = null;
          (await this.supportsWildcard()) &&
            ((J = L.getFunction(O)),
            (0, X.assert)(J, "missing fragment", "UNKNOWN_ERROR", {
              info: { funcName: O },
            }),
            (T = [
              (0, Z.dnsEncode)(this.name, 255),
              L.encodeFunctionData(J, T),
            ]),
            (O = "resolve(bytes,bytes)")),
            T.push({ enableCcipRead: !0 });
          try {
            let W = await this.Z__0[O](...T);
            if (J) return L.decodeFunctionResult(J, W)[0];
            return W;
          } catch (O) {
            if (!(0, X.isError)(O, "CALL_EXCEPTION")) throw O;
          }
          return null;
        }
        async getAddress(O) {
          if ((null == O && (O = 60), 60 === O))
            try {
              let O = await this.__X("addr(bytes32)");
              if (null == O || O === W.ZeroAddress) return null;
              return O;
            } catch (O) {
              if ((0, X.isError)(O, "CALL_EXCEPTION")) return null;
              throw O;
            }
          if (O >= 0 && O < 2147483648) {
            let T = O + 2147483648,
              L = await this.__X("addr(bytes32,uint)", [T]);
            if ((0, X.isHexString)(L, 20)) return (0, J.getAddress)(L);
          }
          let T = null;
          for (let L of this.provider.plugins)
            if (L instanceof et && L.supportsCoinType(O)) {
              T = L;
              break;
            }
          if (null == T) return null;
          let L = await this.__X("addr(bytes32,uint)", [O]);
          if (null == L || "0x" === L) return null;
          let Y = await T.decodeAddress(O, L);
          if (null != Y) return Y;
          (0, X.assert)(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
            operation: `getAddress(${O})`,
            info: { coinType: O, data: L },
          });
        }
        async getText(O) {
          let T = await this.__X("text(bytes32,string)", [O]);
          return null == T || "0x" === T ? null : T;
        }
        async getContentHash() {
          let O = await this.__X("contenthash(bytes32)");
          if (null == O || "0x" === O) return null;
          let T = O.match(
            /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
          );
          if (T) {
            let O = "e3010170" === T[1] ? "ipfs" : "ipns",
              L = parseInt(T[4], 16);
            if (T[5].length === 2 * L)
              return `${O}://${(0, X.encodeBase58)("0x" + T[2])}`;
          }
          let L = O.match(/^0xe40101fa011b20([0-9a-f]*)$/);
          if (L && 64 === L[1].length) return `bzz://${L[1]}`;
          (0, X.assert)(
            !1,
            "invalid or unsupported content hash data",
            "UNSUPPORTED_OPERATION",
            { operation: "getContentHash()", info: { data: O } }
          );
        }
        async getAvatar() {
          return (await this._getAvatar()).url;
        }
        async _getAvatar() {
          let O = [{ type: "name", value: this.name }];
          try {
            let T = await this.getText("avatar");
            if (null == T)
              return (
                O.push({ type: "!avatar", value: "" }),
                { url: null, linkage: O }
              );
            O.push({ type: "avatar", value: T });
            for (let L = 0; L < ei.length; L++) {
              let J = T.match(ei[L]);
              if (null == J) continue;
              let W = J[1].toLowerCase();
              switch (W) {
                case "https":
                case "data":
                  return (
                    O.push({ type: "url", value: T }), { linkage: O, url: T }
                  );
                case "ipfs": {
                  let L = ee(T);
                  return (
                    O.push({ type: "ipfs", value: T }),
                    O.push({ type: "url", value: L }),
                    { linkage: O, url: L }
                  );
                }
                case "erc721":
                case "erc1155": {
                  let L = "erc721" === W ? "tokenURI(uint256)" : "uri(uint256)";
                  O.push({ type: W, value: T });
                  let Z = await this.getAddress();
                  if (null == Z)
                    return (
                      O.push({ type: "!owner", value: "" }),
                      { url: null, linkage: O }
                    );
                  let et = (J[2] || "").split("/");
                  if (2 !== et.length)
                    return (
                      O.push({ type: `!${W}caip`, value: J[2] || "" }),
                      { url: null, linkage: O }
                    );
                  let er = et[1],
                    en = new Y.Contract(
                      et[0],
                      [
                        "function tokenURI(uint) view returns (string)",
                        "function ownerOf(uint) view returns (address)",
                        "function uri(uint) view returns (string)",
                        "function balanceOf(address, uint256) view returns (uint)",
                      ],
                      this.provider
                    );
                  if ("erc721" === W) {
                    let T = await en.ownerOf(er);
                    if (Z !== T)
                      return (
                        O.push({ type: "!owner", value: T }),
                        { url: null, linkage: O }
                      );
                    O.push({ type: "owner", value: T });
                  } else if ("erc1155" === W) {
                    let T = await en.balanceOf(Z, er);
                    if (!T)
                      return (
                        O.push({ type: "!balance", value: "0" }),
                        { url: null, linkage: O }
                      );
                    O.push({ type: "balance", value: T.toString() });
                  }
                  let ei = await en[L](er);
                  if (null == ei || "0x" === ei)
                    return (
                      O.push({ type: "!metadata-url", value: "" }),
                      { url: null, linkage: O }
                    );
                  O.push({ type: "metadata-url-base", value: ei }),
                    "erc1155" === W &&
                      ((ei = ei.replace(
                        "{id}",
                        (0, X.toBeHex)(er, 32).substring(2)
                      )),
                      O.push({ type: "metadata-url-expanded", value: ei })),
                    ei.match(/^ipfs:/i) && (ei = ee(ei)),
                    O.push({ type: "metadata-url", value: ei });
                  let ea = {},
                    eo = await new X.FetchRequest(ei).send();
                  eo.assertOk();
                  try {
                    ea = eo.bodyJson;
                  } catch (T) {
                    try {
                      O.push({ type: "!metadata", value: eo.bodyText });
                    } catch (L) {
                      let T = eo.body;
                      T &&
                        O.push({ type: "!metadata", value: (0, X.hexlify)(T) });
                    }
                    return { url: null, linkage: O };
                  }
                  if (!ea)
                    return (
                      O.push({ type: "!metadata", value: "" }),
                      { url: null, linkage: O }
                    );
                  O.push({ type: "metadata", value: JSON.stringify(ea) });
                  let ec = ea.image;
                  if ("string" != typeof ec)
                    return (
                      O.push({ type: "!imageUrl", value: "" }),
                      { url: null, linkage: O }
                    );
                  if (ec.match(/^(https:\/\/|data:)/i));
                  else {
                    let T = ec.match(es);
                    if (null == T)
                      return (
                        O.push({ type: "!imageUrl-ipfs", value: ec }),
                        { url: null, linkage: O }
                      );
                    O.push({ type: "imageUrl-ipfs", value: ec }), (ec = ee(ec));
                  }
                  return (
                    O.push({ type: "url", value: ec }), { linkage: O, url: ec }
                  );
                }
              }
            }
          } catch (O) {}
          return { linkage: O, url: null };
        }
        static async getEnsAddress(O) {
          let T = await O.getNetwork(),
            L = T.getPlugin("org.ethers.plugins.network.Ens");
          return (
            (0, X.assert)(
              L,
              "network does not support ENS",
              "UNSUPPORTED_OPERATION",
              { operation: "getEnsAddress", info: { network: T } }
            ),
            L.address
          );
        }
        static async #ee(O, T) {
          let L = await ea.getEnsAddress(O);
          try {
            let J = new Y.Contract(
                L,
                ["function resolver(bytes32) view returns (address)"],
                O
              ),
              X = await J.resolver((0, Z.namehash)(T), { enableCcipRead: !0 });
            if (X === W.ZeroAddress) return null;
            return X;
          } catch (O) {
            throw O;
          }
          return null;
        }
        static async fromName(O, T) {
          let L = T;
          for (;;) {
            if ("" === L || "." === L || ("eth" !== T && "eth" === L))
              return null;
            let J = await ea.#ee(O, L);
            if (null != J) {
              let W = new ea(O, J, T);
              if (L !== T && !(await W.supportsWildcard())) return null;
              return W;
            }
            L = L.split(".").slice(1).join(".");
          }
        }
      }
      T.EnsResolver = ea;
    },
    42560: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.formatTransactionResponse =
          T.formatTransactionReceipt =
          T.formatReceiptLog =
          T.formatBlock =
          T.formatLog =
          T.formatUint256 =
          T.formatHash =
          T.formatData =
          T.formatBoolean =
          T.object =
          T.arrayOf =
          T.allowNull =
            void 0);
      let J = L(40431),
        W = L(3382),
        Y = L(16989),
        Z = L(38478),
        X = BigInt(0);
      function ee(O, T) {
        return function (L) {
          return null == L ? T : O(L);
        };
      }
      function et(O, T) {
        return (L) => {
          if (T && null == L) return null;
          if (!Array.isArray(L)) throw Error("not an array");
          return L.map((T) => O(T));
        };
      }
      function er(O, T) {
        return (L) => {
          let J = {};
          for (let W in O) {
            let Y = W;
            if (T && W in T && !(Y in L)) {
              for (let O of T[W])
                if (O in L) {
                  Y = O;
                  break;
                }
            }
            try {
              let T = O[W](L[Y]);
              void 0 !== T && (J[W] = T);
            } catch (T) {
              let O = T instanceof Error ? T.message : "not-an-error";
              (0, Z.assert)(
                !1,
                `invalid value for value.${W} (${O})`,
                "BAD_DATA",
                { value: L }
              );
            }
          }
          return J;
        };
      }
      function en(O) {
        switch (O) {
          case !0:
          case "true":
            return !0;
          case !1:
          case "false":
            return !1;
        }
        (0, Z.assertArgument)(
          !1,
          `invalid boolean; ${JSON.stringify(O)}`,
          "value",
          O
        );
      }
      function es(O) {
        return (
          (0, Z.assertArgument)(
            (0, Z.isHexString)(O, !0),
            "invalid data",
            "value",
            O
          ),
          O
        );
      }
      function ei(O) {
        return (
          (0, Z.assertArgument)(
            (0, Z.isHexString)(O, 32),
            "invalid hash",
            "value",
            O
          ),
          O
        );
      }
      function ea(O) {
        if (!(0, Z.isHexString)(O)) throw Error("invalid uint256");
        return (0, Z.zeroPadValue)(O, 32);
      }
      (T.allowNull = ee),
        (T.arrayOf = et),
        (T.object = er),
        (T.formatBoolean = en),
        (T.formatData = es),
        (T.formatHash = ei),
        (T.formatUint256 = ea);
      let eo = er(
        {
          address: J.getAddress,
          blockHash: ei,
          blockNumber: Z.getNumber,
          data: es,
          index: Z.getNumber,
          removed: ee(en, !1),
          topics: et(ei),
          transactionHash: ei,
          transactionIndex: Z.getNumber,
        },
        { index: ["logIndex"] }
      );
      function ec(O) {
        return eo(O);
      }
      T.formatLog = ec;
      let eu = er({
        hash: ee(ei),
        parentHash: ei,
        parentBeaconBlockRoot: ee(ei, null),
        number: Z.getNumber,
        timestamp: Z.getNumber,
        nonce: ee(es),
        difficulty: Z.getBigInt,
        gasLimit: Z.getBigInt,
        gasUsed: Z.getBigInt,
        stateRoot: ee(ei, null),
        receiptsRoot: ee(ei, null),
        blobGasUsed: ee(Z.getBigInt, null),
        excessBlobGas: ee(Z.getBigInt, null),
        miner: ee(J.getAddress),
        extraData: es,
        baseFeePerGas: ee(Z.getBigInt),
      });
      function eh(O) {
        let T = eu(O);
        return (
          (T.transactions = O.transactions.map((O) =>
            "string" == typeof O ? O : em(O)
          )),
          T
        );
      }
      T.formatBlock = eh;
      let ed = er(
        {
          transactionIndex: Z.getNumber,
          blockNumber: Z.getNumber,
          transactionHash: ei,
          address: J.getAddress,
          topics: et(ei),
          data: es,
          index: Z.getNumber,
          blockHash: ei,
        },
        { index: ["logIndex"] }
      );
      function ep(O) {
        return ed(O);
      }
      T.formatReceiptLog = ep;
      let eg = er(
        {
          to: ee(J.getAddress, null),
          from: ee(J.getAddress, null),
          contractAddress: ee(J.getAddress, null),
          index: Z.getNumber,
          root: ee(Z.hexlify),
          gasUsed: Z.getBigInt,
          blobGasUsed: ee(Z.getBigInt, null),
          logsBloom: ee(es),
          blockHash: ei,
          hash: ei,
          logs: et(ep),
          blockNumber: Z.getNumber,
          cumulativeGasUsed: Z.getBigInt,
          effectiveGasPrice: ee(Z.getBigInt),
          blobGasPrice: ee(Z.getBigInt, null),
          status: ee(Z.getNumber),
          type: ee(Z.getNumber, 0),
        },
        {
          effectiveGasPrice: ["gasPrice"],
          hash: ["transactionHash"],
          index: ["transactionIndex"],
        }
      );
      function ey(O) {
        return eg(O);
      }
      function em(O) {
        O.to &&
          (0, Z.getBigInt)(O.to) === X &&
          (O.to = "0x0000000000000000000000000000000000000000");
        let T = er(
          {
            hash: ei,
            index: ee(Z.getNumber, void 0),
            type: (O) => ("0x" === O || null == O ? 0 : (0, Z.getNumber)(O)),
            accessList: ee(Y.accessListify, null),
            blobVersionedHashes: ee(et(ei, !0), null),
            blockHash: ee(ei, null),
            blockNumber: ee(Z.getNumber, null),
            transactionIndex: ee(Z.getNumber, null),
            from: J.getAddress,
            gasPrice: ee(Z.getBigInt),
            maxPriorityFeePerGas: ee(Z.getBigInt),
            maxFeePerGas: ee(Z.getBigInt),
            maxFeePerBlobGas: ee(Z.getBigInt, null),
            gasLimit: Z.getBigInt,
            to: ee(J.getAddress, null),
            value: Z.getBigInt,
            nonce: Z.getNumber,
            data: es,
            creates: ee(J.getAddress, null),
            chainId: ee(Z.getBigInt, null),
          },
          { data: ["input"], gasLimit: ["gas"], index: ["transactionIndex"] }
        )(O);
        if (
          (null == T.to &&
            null == T.creates &&
            (T.creates = (0, J.getCreateAddress)(T)),
          (1 === O.type || 2 === O.type) &&
            null == O.accessList &&
            (T.accessList = []),
          O.signature
            ? (T.signature = W.Signature.from(O.signature))
            : (T.signature = W.Signature.from(O)),
          null == T.chainId)
        ) {
          let O = T.signature.legacyChainId;
          null != O && (T.chainId = O);
        }
        return (
          T.blockHash &&
            (0, Z.getBigInt)(T.blockHash) === X &&
            (T.blockHash = null),
          T
        );
      }
      (T.formatTransactionReceipt = ey), (T.formatTransactionResponse = em);
    },
    37431: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.SocketEventSubscriber =
          T.SocketPendingSubscriber =
          T.SocketBlockSubscriber =
          T.SocketSubscriber =
          T.WebSocketProvider =
          T.SocketProvider =
          T.IpcSocketProvider =
          T.QuickNodeProvider =
          T.PocketProvider =
          T.InfuraWebSocketProvider =
          T.InfuraProvider =
          T.EtherscanPlugin =
          T.EtherscanProvider =
          T.CloudflareProvider =
          T.AnkrProvider =
          T.AlchemyProvider =
          T.BrowserProvider =
          T.JsonRpcSigner =
          T.JsonRpcProvider =
          T.JsonRpcApiProvider =
          T.FallbackProvider =
          T.copyRequest =
          T.TransactionResponse =
          T.TransactionReceipt =
          T.Log =
          T.FeeData =
          T.Block =
          T.FetchUrlFeeDataNetworkPlugin =
          T.FeeDataNetworkPlugin =
          T.EnsPlugin =
          T.GasCostPlugin =
          T.NetworkPlugin =
          T.NonceManager =
          T.Network =
          T.MulticoinProviderPlugin =
          T.EnsResolver =
          T.getDefaultProvider =
          T.showThrottleMessage =
          T.VoidSigner =
          T.AbstractSigner =
          T.UnmanagedSubscriber =
          T.AbstractProvider =
            void 0);
      var J = L(58978);
      Object.defineProperty(T, "AbstractProvider", {
        enumerable: !0,
        get: function () {
          return J.AbstractProvider;
        },
      }),
        Object.defineProperty(T, "UnmanagedSubscriber", {
          enumerable: !0,
          get: function () {
            return J.UnmanagedSubscriber;
          },
        });
      var W = L(70690);
      Object.defineProperty(T, "AbstractSigner", {
        enumerable: !0,
        get: function () {
          return W.AbstractSigner;
        },
      }),
        Object.defineProperty(T, "VoidSigner", {
          enumerable: !0,
          get: function () {
            return W.VoidSigner;
          },
        });
      var Y = L(80734);
      Object.defineProperty(T, "showThrottleMessage", {
        enumerable: !0,
        get: function () {
          return Y.showThrottleMessage;
        },
      });
      var Z = L(48904);
      Object.defineProperty(T, "getDefaultProvider", {
        enumerable: !0,
        get: function () {
          return Z.getDefaultProvider;
        },
      });
      var X = L(25812);
      Object.defineProperty(T, "EnsResolver", {
        enumerable: !0,
        get: function () {
          return X.EnsResolver;
        },
      }),
        Object.defineProperty(T, "MulticoinProviderPlugin", {
          enumerable: !0,
          get: function () {
            return X.MulticoinProviderPlugin;
          },
        });
      var ee = L(61927);
      Object.defineProperty(T, "Network", {
        enumerable: !0,
        get: function () {
          return ee.Network;
        },
      });
      var et = L(39603);
      Object.defineProperty(T, "NonceManager", {
        enumerable: !0,
        get: function () {
          return et.NonceManager;
        },
      });
      var er = L(21165);
      Object.defineProperty(T, "NetworkPlugin", {
        enumerable: !0,
        get: function () {
          return er.NetworkPlugin;
        },
      }),
        Object.defineProperty(T, "GasCostPlugin", {
          enumerable: !0,
          get: function () {
            return er.GasCostPlugin;
          },
        }),
        Object.defineProperty(T, "EnsPlugin", {
          enumerable: !0,
          get: function () {
            return er.EnsPlugin;
          },
        }),
        Object.defineProperty(T, "FeeDataNetworkPlugin", {
          enumerable: !0,
          get: function () {
            return er.FeeDataNetworkPlugin;
          },
        }),
        Object.defineProperty(T, "FetchUrlFeeDataNetworkPlugin", {
          enumerable: !0,
          get: function () {
            return er.FetchUrlFeeDataNetworkPlugin;
          },
        });
      var en = L(27773);
      Object.defineProperty(T, "Block", {
        enumerable: !0,
        get: function () {
          return en.Block;
        },
      }),
        Object.defineProperty(T, "FeeData", {
          enumerable: !0,
          get: function () {
            return en.FeeData;
          },
        }),
        Object.defineProperty(T, "Log", {
          enumerable: !0,
          get: function () {
            return en.Log;
          },
        }),
        Object.defineProperty(T, "TransactionReceipt", {
          enumerable: !0,
          get: function () {
            return en.TransactionReceipt;
          },
        }),
        Object.defineProperty(T, "TransactionResponse", {
          enumerable: !0,
          get: function () {
            return en.TransactionResponse;
          },
        }),
        Object.defineProperty(T, "copyRequest", {
          enumerable: !0,
          get: function () {
            return en.copyRequest;
          },
        });
      var es = L(36843);
      Object.defineProperty(T, "FallbackProvider", {
        enumerable: !0,
        get: function () {
          return es.FallbackProvider;
        },
      });
      var ei = L(88997);
      Object.defineProperty(T, "JsonRpcApiProvider", {
        enumerable: !0,
        get: function () {
          return ei.JsonRpcApiProvider;
        },
      }),
        Object.defineProperty(T, "JsonRpcProvider", {
          enumerable: !0,
          get: function () {
            return ei.JsonRpcProvider;
          },
        }),
        Object.defineProperty(T, "JsonRpcSigner", {
          enumerable: !0,
          get: function () {
            return ei.JsonRpcSigner;
          },
        });
      var ea = L(19957);
      Object.defineProperty(T, "BrowserProvider", {
        enumerable: !0,
        get: function () {
          return ea.BrowserProvider;
        },
      });
      var eo = L(7285);
      Object.defineProperty(T, "AlchemyProvider", {
        enumerable: !0,
        get: function () {
          return eo.AlchemyProvider;
        },
      });
      var ec = L(19416);
      Object.defineProperty(T, "AnkrProvider", {
        enumerable: !0,
        get: function () {
          return ec.AnkrProvider;
        },
      });
      var eu = L(97448);
      Object.defineProperty(T, "CloudflareProvider", {
        enumerable: !0,
        get: function () {
          return eu.CloudflareProvider;
        },
      });
      var eh = L(38580);
      Object.defineProperty(T, "EtherscanProvider", {
        enumerable: !0,
        get: function () {
          return eh.EtherscanProvider;
        },
      }),
        Object.defineProperty(T, "EtherscanPlugin", {
          enumerable: !0,
          get: function () {
            return eh.EtherscanPlugin;
          },
        });
      var ed = L(26860);
      Object.defineProperty(T, "InfuraProvider", {
        enumerable: !0,
        get: function () {
          return ed.InfuraProvider;
        },
      }),
        Object.defineProperty(T, "InfuraWebSocketProvider", {
          enumerable: !0,
          get: function () {
            return ed.InfuraWebSocketProvider;
          },
        });
      var ep = L(61665);
      Object.defineProperty(T, "PocketProvider", {
        enumerable: !0,
        get: function () {
          return ep.PocketProvider;
        },
      });
      var eg = L(41980);
      Object.defineProperty(T, "QuickNodeProvider", {
        enumerable: !0,
        get: function () {
          return eg.QuickNodeProvider;
        },
      });
      let ey = L(62524);
      Object.defineProperty(T, "IpcSocketProvider", {
        enumerable: !0,
        get: function () {
          return ey.IpcSocketProvider;
        },
      });
      var em = L(27329);
      Object.defineProperty(T, "SocketProvider", {
        enumerable: !0,
        get: function () {
          return em.SocketProvider;
        },
      });
      var eb = L(82083);
      Object.defineProperty(T, "WebSocketProvider", {
        enumerable: !0,
        get: function () {
          return eb.WebSocketProvider;
        },
      });
      var eA = L(27329);
      Object.defineProperty(T, "SocketSubscriber", {
        enumerable: !0,
        get: function () {
          return eA.SocketSubscriber;
        },
      }),
        Object.defineProperty(T, "SocketBlockSubscriber", {
          enumerable: !0,
          get: function () {
            return eA.SocketBlockSubscriber;
          },
        }),
        Object.defineProperty(T, "SocketPendingSubscriber", {
          enumerable: !0,
          get: function () {
            return eA.SocketPendingSubscriber;
          },
        }),
        Object.defineProperty(T, "SocketEventSubscriber", {
          enumerable: !0,
          get: function () {
            return eA.SocketEventSubscriber;
          },
        });
    },
    61927: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Network = void 0);
      let J = L(16989),
        W = L(38478),
        Y = L(21165),
        Z = new Map();
      class X {
        constructor(O, T) {
          (this._et = O),
            (this._er = (0, W.getBigInt)(T)),
            (this.I__0 = new Map());
        }
        toJSON() {
          return { name: this.name, chainId: String(this.chainId) };
        }
        get name() {
          return this._et;
        }
        set name(O) {
          this._et = O;
        }
        get chainId() {
          return this._er;
        }
        set chainId(O) {
          this._er = (0, W.getBigInt)(O, "chainId");
        }
        matches(O) {
          if (null == O) return !1;
          if ("string" == typeof O) {
            try {
              return this.chainId === (0, W.getBigInt)(O);
            } catch (O) {}
            return this.name === O;
          }
          if ("number" == typeof O || "bigint" == typeof O) {
            try {
              return this.chainId === (0, W.getBigInt)(O);
            } catch (O) {}
            return !1;
          }
          if ("object" == typeof O) {
            if (null != O.chainId) {
              try {
                return this.chainId === (0, W.getBigInt)(O.chainId);
              } catch (O) {}
              return !1;
            }
            if (null != O.name) return this.name === O.name;
          }
          return !1;
        }
        get plugins() {
          return Array.from(this.I__0.values());
        }
        attachPlugin(O) {
          if (this.I__0.get(O.name))
            throw Error(`cannot replace existing plugin: ${O.name} `);
          return this.I__0.set(O.name, O.clone()), this;
        }
        getPlugin(O) {
          return this.I__0.get(O) || null;
        }
        getPlugins(O) {
          return this.plugins.filter((T) => T.name.split("#")[0] === O);
        }
        clone() {
          let O = new X(this.name, this.chainId);
          return (
            this.plugins.forEach((T) => {
              O.attachPlugin(T.clone());
            }),
            O
          );
        }
        computeIntrinsicGas(O) {
          let T =
              this.getPlugin("org.ethers.plugins.network.GasCost") ||
              new Y.GasCostPlugin(),
            L = T.txBase;
          if ((null == O.to && (L += T.txCreate), O.data))
            for (let J = 2; J < O.data.length; J += 2)
              "00" === O.data.substring(J, J + 2)
                ? (L += T.txDataZero)
                : (L += T.txDataNonzero);
          if (O.accessList) {
            let W = (0, J.accessListify)(O.accessList);
            for (let O in W)
              L +=
                T.txAccessListAddress +
                T.txAccessListStorageKey * W[O].storageKeys.length;
          }
          return L;
        }
        static from(O) {
          if ((en(), null == O)) return X.from("mainnet");
          if (
            ("number" == typeof O && (O = BigInt(O)),
            "string" == typeof O || "bigint" == typeof O)
          ) {
            let T = Z.get(O);
            if (T) return T();
            if ("bigint" == typeof O) return new X("unknown", O);
            (0, W.assertArgument)(!1, "unknown network", "network", O);
          }
          if ("function" == typeof O.clone) return O.clone();
          if ("object" == typeof O) {
            (0, W.assertArgument)(
              "string" == typeof O.name && "number" == typeof O.chainId,
              "invalid network object name or chainId",
              "network",
              O
            );
            let T = new X(O.name, O.chainId);
            return (
              (O.ensAddress || null != O.ensNetwork) &&
                T.attachPlugin(new Y.EnsPlugin(O.ensAddress, O.ensNetwork)),
              T
            );
          }
          (0, W.assertArgument)(!1, "invalid network", "network", O);
        }
        static register(O, T) {
          "number" == typeof O && (O = BigInt(O));
          let L = Z.get(O);
          L &&
            (0, W.assertArgument)(
              !1,
              `conflicting network for ${JSON.stringify(L.name)}`,
              "nameOrChainId",
              O
            ),
            Z.set(O, T);
        }
      }
      function ee(O, T) {
        let L = String(O);
        if (!L.match(/^[0-9.]+$/)) throw Error(`invalid gwei value: ${O}`);
        let J = L.split(".");
        if ((1 === J.length && J.push(""), 2 !== J.length))
          throw Error(`invalid gwei value: ${O}`);
        for (; J[1].length < T; ) J[1] += "0";
        if (J[1].length > 9) {
          let O = BigInt(J[1].substring(0, 9));
          !J[1].substring(9).match(/^0+$/) && O++, (J[1] = O.toString());
        }
        return BigInt(J[0] + J[1]);
      }
      function et(O) {
        return new Y.FetchUrlFeeDataNetworkPlugin(O, async (O, T, L) => {
          let J;
          L.setHeader("User-Agent", "ethers");
          try {
            let [T, W] = await Promise.all([L.send(), O()]),
              Y = (J = T).bodyJson.standard;
            return {
              gasPrice: W.gasPrice,
              maxFeePerGas: ee(Y.maxFee, 9),
              maxPriorityFeePerGas: ee(Y.maxPriorityFee, 9),
            };
          } catch (O) {
            (0, W.assert)(
              !1,
              `error encountered with polygon gas station (${JSON.stringify(
                L.url
              )})`,
              "SERVER_ERROR",
              { request: L, response: J, error: O }
            );
          }
        });
      }
      T.Network = X;
      let er = !1;
      function en() {
        er ||
          ((er = !0),
          O("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }),
          O("ropsten", 3, { ensNetwork: 3 }),
          O("rinkeby", 4, { ensNetwork: 4 }),
          O("goerli", 5, { ensNetwork: 5 }),
          O("kovan", 42, { ensNetwork: 42 }),
          O("sepolia", 11155111, { ensNetwork: 11155111 }),
          O("holesky", 17e3, { ensNetwork: 17e3 }),
          O("classic", 61, {}),
          O("classicKotti", 6, {}),
          O("arbitrum", 42161, { ensNetwork: 1 }),
          O("arbitrum-goerli", 421613, {}),
          O("arbitrum-sepolia", 421614, {}),
          O("base", 8453, { ensNetwork: 1 }),
          O("base-goerli", 84531, {}),
          O("base-sepolia", 84532, {}),
          O("bnb", 56, { ensNetwork: 1 }),
          O("bnbt", 97, {}),
          O("linea", 59144, { ensNetwork: 1 }),
          O("linea-goerli", 59140, {}),
          O("matic", 137, {
            ensNetwork: 1,
            plugins: [et("https://gasstation.polygon.technology/v2")],
          }),
          O("matic-mumbai", 80001, {
            altNames: ["maticMumbai", "maticmum"],
            plugins: [et("https://gasstation-testnet.polygon.technology/v2")],
          }),
          O("optimism", 10, { ensNetwork: 1, plugins: [] }),
          O("optimism-goerli", 420, {}),
          O("optimism-sepolia", 11155420, {}),
          O("xdai", 100, { ensNetwork: 1 }));
        function O(O, T, L) {
          let J = function () {
            let J = new X(O, T);
            return (
              null != L.ensNetwork &&
                J.attachPlugin(new Y.EnsPlugin(null, L.ensNetwork)),
              J.attachPlugin(new Y.GasCostPlugin()),
              (L.plugins || []).forEach((O) => {
                J.attachPlugin(O);
              }),
              J
            );
          };
          X.register(O, J),
            X.register(T, J),
            L.altNames &&
              L.altNames.forEach((O) => {
                X.register(O, J);
              });
        }
      }
    },
    21165: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.FetchUrlFeeDataNetworkPlugin =
          T.FeeDataNetworkPlugin =
          T.EnsPlugin =
          T.GasCostPlugin =
          T.NetworkPlugin =
            void 0);
      let J = L(43980),
        W = L(38478),
        Y = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
      class Z {
        constructor(O) {
          (0, J.defineProperties)(this, { name: O });
        }
        clone() {
          return new Z(this.name);
        }
      }
      T.NetworkPlugin = Z;
      class X extends Z {
        constructor(O, T) {
          null == O && (O = 0),
            super(`org.ethers.network.plugins.GasCost#${O || 0}`);
          let L = { effectiveBlock: O };
          function Y(O, J) {
            let Y = (T || {})[O];
            null == Y && (Y = J),
              (0, W.assertArgument)(
                "number" == typeof Y,
                `invalud value for ${O}`,
                "costs",
                T
              ),
              (L[O] = Y);
          }
          Y("txBase", 21e3),
            Y("txCreate", 32e3),
            Y("txDataZero", 4),
            Y("txDataNonzero", 16),
            Y("txAccessListStorageKey", 1900),
            Y("txAccessListAddress", 2400),
            (0, J.defineProperties)(this, L);
        }
        clone() {
          return new X(this.effectiveBlock, this);
        }
      }
      T.GasCostPlugin = X;
      class ee extends Z {
        constructor(O, T) {
          super("org.ethers.plugins.network.Ens"),
            (0, J.defineProperties)(this, {
              address: O || Y,
              targetNetwork: null == T ? 1 : T,
            });
        }
        clone() {
          return new ee(this.address, this.targetNetwork);
        }
      }
      T.EnsPlugin = ee;
      class et extends Z {
        get feeDataFunc() {
          return this._en;
        }
        constructor(O) {
          super("org.ethers.plugins.network.FeeData"), (this._en = O);
        }
        async getFeeData(O) {
          return await this._en(O);
        }
        clone() {
          return new et(this._en);
        }
      }
      T.FeeDataNetworkPlugin = et;
      class er extends Z {
        get url() {
          return this._es;
        }
        get processFunc() {
          return this._ei;
        }
        constructor(O, T) {
          super("org.ethers.plugins.network.FetchUrlFeeDataPlugin"),
            (this._es = O),
            (this._ei = T);
        }
        clone() {
          return this;
        }
      }
      T.FetchUrlFeeDataNetworkPlugin = er;
    },
    7285: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.AlchemyProvider = void 0);
      let J = L(38478),
        W = L(80734),
        Y = L(61927),
        Z = L(88997),
        X = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
      function ee(O) {
        switch (O) {
          case "mainnet":
            return "eth-mainnet.alchemyapi.io";
          case "goerli":
            return "eth-goerli.g.alchemy.com";
          case "sepolia":
            return "eth-sepolia.g.alchemy.com";
          case "arbitrum":
            return "arb-mainnet.g.alchemy.com";
          case "arbitrum-goerli":
            return "arb-goerli.g.alchemy.com";
          case "arbitrum-sepolia":
            return "arb-sepolia.g.alchemy.com";
          case "base":
            return "base-mainnet.g.alchemy.com";
          case "base-goerli":
            return "base-goerli.g.alchemy.com";
          case "base-sepolia":
            return "base-sepolia.g.alchemy.com";
          case "matic":
            return "polygon-mainnet.g.alchemy.com";
          case "matic-mumbai":
            return "polygon-mumbai.g.alchemy.com";
          case "optimism":
            return "opt-mainnet.g.alchemy.com";
          case "optimism-goerli":
            return "opt-goerli.g.alchemy.com";
          case "optimism-sepolia":
            return "opt-sepolia.g.alchemy.com";
        }
        (0, J.assertArgument)(!1, "unsupported network", "network", O);
      }
      class et extends Z.JsonRpcProvider {
        constructor(O, T) {
          null == O && (O = "mainnet");
          let L = Y.Network.from(O);
          null == T && (T = X),
            super(et.getRequest(L, T), L, { staticNetwork: L }),
            (0, J.defineProperties)(this, { apiKey: T });
        }
        _getProvider(O) {
          try {
            return new et(O, this.apiKey);
          } catch (O) {}
          return super._getProvider(O);
        }
        async _perform(O) {
          if ("getTransactionResult" === O.method) {
            let T;
            let { trace: L, tx: W } = await (0, J.resolveProperties)({
              trace: this.send("trace_transaction", [O.hash]),
              tx: this.getTransaction(O.hash),
            });
            if (null == L || null == W) return null;
            let Y = !1;
            try {
              (T = L[0].result.output), (Y = "Reverted" === L[0].error);
            } catch (O) {}
            if (T)
              return (
                (0, J.assert)(
                  !Y,
                  "an error occurred during transaction executions",
                  "CALL_EXCEPTION",
                  {
                    action: "getTransactionResult",
                    data: T,
                    reason: null,
                    transaction: W,
                    invocation: null,
                    revert: null,
                  }
                ),
                T
              );
            (0, J.assert)(!1, "could not parse trace result", "BAD_DATA", {
              value: L,
            });
          }
          return await super._perform(O);
        }
        isCommunityResource() {
          return this.apiKey === X;
        }
        static getRequest(O, T) {
          null == T && (T = X);
          let L = new J.FetchRequest(`https://${ee(O.name)}/v2/${T}`);
          return (
            (L.allowGzip = !0),
            T === X &&
              (L.retryFunc = async (O, T, L) => (
                (0, W.showThrottleMessage)("alchemy"), !0
              )),
            L
          );
        }
      }
      T.AlchemyProvider = et;
    },
    19416: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.AnkrProvider = void 0);
      let J = L(38478),
        W = L(80734),
        Y = L(61927),
        Z = L(88997),
        X = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
      function ee(O) {
        switch (O) {
          case "mainnet":
            return "rpc.ankr.com/eth";
          case "goerli":
            return "rpc.ankr.com/eth_goerli";
          case "sepolia":
            return "rpc.ankr.com/eth_sepolia";
          case "arbitrum":
            return "rpc.ankr.com/arbitrum";
          case "base":
            return "rpc.ankr.com/base";
          case "base-goerli":
            return "rpc.ankr.com/base_goerli";
          case "base-sepolia":
            return "rpc.ankr.com/base_sepolia";
          case "bnb":
            return "rpc.ankr.com/bsc";
          case "bnbt":
            return "rpc.ankr.com/bsc_testnet_chapel";
          case "matic":
            return "rpc.ankr.com/polygon";
          case "matic-mumbai":
            return "rpc.ankr.com/polygon_mumbai";
          case "optimism":
            return "rpc.ankr.com/optimism";
          case "optimism-goerli":
            return "rpc.ankr.com/optimism_testnet";
          case "optimism-sepolia":
            return "rpc.ankr.com/optimism_sepolia";
        }
        (0, J.assertArgument)(!1, "unsupported network", "network", O);
      }
      class et extends Z.JsonRpcProvider {
        constructor(O, T) {
          null == O && (O = "mainnet");
          let L = Y.Network.from(O);
          null == T && (T = X),
            super(et.getRequest(L, T), L, { polling: !0, staticNetwork: L }),
            (0, J.defineProperties)(this, { apiKey: T });
        }
        _getProvider(O) {
          try {
            return new et(O, this.apiKey);
          } catch (O) {}
          return super._getProvider(O);
        }
        static getRequest(O, T) {
          null == T && (T = X);
          let L = new J.FetchRequest(`https://${ee(O.name)}/${T}`);
          return (
            (L.allowGzip = !0),
            T === X &&
              (L.retryFunc = async (O, T, L) => (
                (0, W.showThrottleMessage)("AnkrProvider"), !0
              )),
            L
          );
        }
        getRpcError(O, T) {
          return (
            "eth_sendRawTransaction" === O.method &&
              T &&
              T.error &&
              "INTERNAL_ERROR: could not replace existing tx" ===
                T.error.message &&
              (T.error.message = "replacement transaction underpriced"),
            super.getRpcError(O, T)
          );
        }
        isCommunityResource() {
          return this.apiKey === X;
        }
      }
      T.AnkrProvider = et;
    },
    19957: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.BrowserProvider = void 0);
      let J = L(38478),
        W = L(88997);
      class Y extends W.JsonRpcApiPollingProvider {
        constructor(O, T) {
          (0, J.assertArgument)(
            O && O.request,
            "invalid EIP-1193 provider",
            "ethereum",
            O
          ),
            super(T, { batchMaxCount: 1 }),
            (this._ea = async (T, L) => {
              let J = { method: T, params: L };
              this.emit("debug", { action: "sendEip1193Request", payload: J });
              try {
                let T = await O.request(J);
                return (
                  this.emit("debug", {
                    action: "receiveEip1193Result",
                    result: T,
                  }),
                  T
                );
              } catch (T) {
                let O = Error(T.message);
                throw (
                  ((O.code = T.code),
                  (O.data = T.data),
                  (O.payload = J),
                  this.emit("debug", {
                    action: "receiveEip1193Error",
                    error: O,
                  }),
                  O)
                );
              }
            });
        }
        async send(O, T) {
          return await this._start(), await super.send(O, T);
        }
        async _send(O) {
          (0, J.assertArgument)(
            !Array.isArray(O),
            "EIP-1193 does not support batch request",
            "payload",
            O
          );
          try {
            let T = await this._ea(O.method, O.params || []);
            return [{ id: O.id, result: T }];
          } catch (T) {
            return [
              {
                id: O.id,
                error: { code: T.code, data: T.data, message: T.message },
              },
            ];
          }
        }
        getRpcError(O, T) {
          switch ((T = JSON.parse(JSON.stringify(T))).error.code || -1) {
            case 4001:
              T.error.message = `ethers-user-denied: ${T.error.message}`;
              break;
            case 4200:
              T.error.message = `ethers-unsupported: ${T.error.message}`;
          }
          return super.getRpcError(O, T);
        }
        async hasSigner(O) {
          null == O && (O = 0);
          let T = await this.send("eth_accounts", []);
          return "number" == typeof O
            ? T.length > O
            : ((O = O.toLowerCase()),
              0 !== T.filter((T) => T.toLowerCase() === O).length);
        }
        async getSigner(O) {
          if ((null == O && (O = 0), !(await this.hasSigner(O))))
            try {
              await this._ea("eth_requestAccounts", []);
            } catch (T) {
              let O = T.payload;
              throw this.getRpcError(O, { id: O.id, error: T });
            }
          return await super.getSigner(O);
        }
      }
      T.BrowserProvider = Y;
    },
    97448: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.CloudflareProvider = void 0);
      let J = L(38478),
        W = L(61927),
        Y = L(88997);
      class Z extends Y.JsonRpcProvider {
        constructor(O) {
          null == O && (O = "mainnet");
          let T = W.Network.from(O);
          (0, J.assertArgument)(
            "mainnet" === T.name,
            "unsupported network",
            "network",
            O
          ),
            super("https://cloudflare-eth.com/", T, { staticNetwork: T });
        }
      }
      T.CloudflareProvider = Z;
    },
    38580: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.EtherscanProvider = T.EtherscanPlugin = void 0);
      let J = L(16330),
        W = L(15311),
        Y = L(16989),
        Z = L(38478),
        X = L(58978),
        ee = L(61927),
        et = L(21165),
        er = L(80734),
        en = 2e3;
      function es(O) {
        return O && "function" == typeof O.then;
      }
      let ei = "org.ethers.plugins.provider.Etherscan";
      class ea extends et.NetworkPlugin {
        constructor(O) {
          super(ei), (0, Z.defineProperties)(this, { baseUrl: O });
        }
        clone() {
          return new ea(this.baseUrl);
        }
      }
      T.EtherscanPlugin = ea;
      let eo = ["enableCcipRead"],
        ec = 1;
      class eu extends X.AbstractProvider {
        constructor(O, T) {
          let L = null != T ? T : null;
          super();
          let J = ee.Network.from(O);
          (this._eo = J.getPlugin(ei)),
            (0, Z.defineProperties)(this, { apiKey: L, network: J }),
            this.getBaseUrl();
        }
        getBaseUrl() {
          if (this._eo) return this._eo.baseUrl;
          switch (this.network.name) {
            case "mainnet":
              return "https://api.etherscan.io";
            case "goerli":
              return "https://api-goerli.etherscan.io";
            case "sepolia":
              return "https://api-sepolia.etherscan.io";
            case "holesky":
              return "https://api-holesky.etherscan.io";
            case "arbitrum":
              return "https://api.arbiscan.io";
            case "arbitrum-goerli":
              return "https://api-goerli.arbiscan.io";
            case "bnb":
              return "https://api.bscscan.com";
            case "bnbt":
              return "https://api-testnet.bscscan.com";
            case "matic":
              return "https://api.polygonscan.com";
            case "matic-mumbai":
              return "https://api-testnet.polygonscan.com";
            case "optimism":
              return "https://api-optimistic.etherscan.io";
            case "optimism-goerli":
              return "https://api-goerli-optimistic.etherscan.io";
          }
          (0, Z.assertArgument)(
            !1,
            "unsupported network",
            "network",
            this.network
          );
        }
        getUrl(O, T) {
          let L = Object.keys(T).reduce((O, L) => {
              let J = T[L];
              return null != J && (O += `&${L}=${J}`), O;
            }, ""),
            J = this.apiKey ? `&apikey=${this.apiKey}` : "";
          return `${this.getBaseUrl()}/api?module=${O}${L}${J}`;
        }
        getPostUrl() {
          return `${this.getBaseUrl()}/api`;
        }
        getPostData(O, T) {
          return (T.module = O), (T.apikey = this.apiKey), T;
        }
        async detectNetwork() {
          return this.network;
        }
        async fetch(O, T, L) {
          let J = ec++,
            W = L ? this.getPostUrl() : this.getUrl(O, T),
            Y = L ? this.getPostData(O, T) : null;
          this.emit("debug", {
            action: "sendRequest",
            id: J,
            url: W,
            payload: Y,
          });
          let X = new Z.FetchRequest(W);
          X.setThrottleParams({ slotInterval: 1e3 }),
            (X.retryFunc = (O, T, L) => (
              this.isCommunityResource() &&
                (0, er.showThrottleMessage)("Etherscan"),
              Promise.resolve(!0)
            )),
            (X.processFunc = async (T, L) => {
              let W = L.hasBody()
                  ? JSON.parse((0, Z.toUtf8String)(L.body))
                  : {},
                Y =
                  ("string" == typeof W.result ? W.result : "")
                    .toLowerCase()
                    .indexOf("rate limit") >= 0;
              return (
                "proxy" === O
                  ? W &&
                    0 == W.status &&
                    "NOTOK" == W.message &&
                    Y &&
                    (this.emit("debug", {
                      action: "receiveError",
                      id: J,
                      reason: "proxy-NOTOK",
                      error: W,
                    }),
                    L.throwThrottleError(W.result, en))
                  : Y &&
                    (this.emit("debug", {
                      action: "receiveError",
                      id: J,
                      reason: "null result",
                      error: W.result,
                    }),
                    L.throwThrottleError(W.result, en)),
                L
              );
            }),
            Y &&
              (X.setHeader(
                "content-type",
                "application/x-www-form-urlencoded; charset=UTF-8"
              ),
              (X.body = Object.keys(Y)
                .map((O) => `${O}=${Y[O]}`)
                .join("&")));
          let ee = await X.send();
          try {
            ee.assertOk();
          } catch (O) {
            this.emit("debug", {
              action: "receiveError",
              id: J,
              error: O,
              reason: "assertOk",
            }),
              (0, Z.assert)(!1, "response error", "SERVER_ERROR", {
                request: X,
                response: ee,
              });
          }
          ee.hasBody() ||
            (this.emit("debug", {
              action: "receiveError",
              id: J,
              error: "missing body",
              reason: "null body",
            }),
            (0, Z.assert)(!1, "missing response", "SERVER_ERROR", {
              request: X,
              response: ee,
            }));
          let et = JSON.parse((0, Z.toUtf8String)(ee.body));
          return (
            "proxy" === O
              ? ("2.0" != et.jsonrpc &&
                  (this.emit("debug", {
                    action: "receiveError",
                    id: J,
                    result: et,
                    reason: "invalid JSON-RPC",
                  }),
                  (0, Z.assert)(
                    !1,
                    "invalid JSON-RPC response (missing jsonrpc='2.0')",
                    "SERVER_ERROR",
                    { request: X, response: ee, info: { result: et } }
                  )),
                et.error &&
                  (this.emit("debug", {
                    action: "receiveError",
                    id: J,
                    result: et,
                    reason: "JSON-RPC error",
                  }),
                  (0, Z.assert)(!1, "error response", "SERVER_ERROR", {
                    request: X,
                    response: ee,
                    info: { result: et },
                  })))
              : (0 == et.status &&
                  ("No records found" === et.message ||
                    "No transactions found" === et.message)) ||
                (1 == et.status &&
                  ("string" != typeof et.message || et.message.match(/^OK/))) ||
                (this.emit("debug", {
                  action: "receiveError",
                  id: J,
                  result: et,
                }),
                (0, Z.assert)(!1, "error response", "SERVER_ERROR", {
                  request: X,
                  response: ee,
                  info: { result: et },
                })),
            this.emit("debug", { action: "receiveRequest", id: J, result: et }),
            et.result
          );
        }
        _getTransactionPostData(O) {
          let T = {};
          for (let L in O) {
            if (eo.indexOf(L) >= 0 || null == O[L]) continue;
            let J = O[L];
            ("type" !== L || 0 !== J) &&
              ("blockTag" !== L || "latest" !== J) &&
              ((J = {
                type: !0,
                gasLimit: !0,
                gasPrice: !0,
                maxFeePerGs: !0,
                maxPriorityFeePerGas: !0,
                nonce: !0,
                value: !0,
              }[L]
                ? (0, Z.toQuantity)(J)
                : "accessList" === L
                ? "[" +
                  (0, Y.accessListify)(J)
                    .map(
                      (O) =>
                        `{address:"${
                          O.address
                        }",storageKeys:["${O.storageKeys.join('","')}"]}`
                    )
                    .join(",") +
                  "]"
                : (0, Z.hexlify)(J)),
              (T[L] = J));
          }
          return T;
        }
        _checkError(O, T, L) {
          let W = "";
          if ((0, Z.isError)(T, "SERVER_ERROR")) {
            try {
              W = T.info.result.error.message;
            } catch (O) {}
            if (!W)
              try {
                W = T.info.message;
              } catch (O) {}
          }
          if (
            ("estimateGas" === O.method &&
              !W.match(/revert/i) &&
              W.match(/insufficient funds/i) &&
              (0, Z.assert)(!1, "insufficient funds", "INSUFFICIENT_FUNDS", {
                transaction: O.transaction,
              }),
            ("call" === O.method || "estimateGas" === O.method) &&
              W.match(/execution reverted/i))
          ) {
            let L = "";
            try {
              L = T.info.result.error.data;
            } catch (O) {}
            let W = J.AbiCoder.getBuiltinCallException(
              O.method,
              O.transaction,
              L
            );
            throw ((W.info = { request: O, error: T }), W);
          }
          if (W && "broadcastTransaction" === O.method) {
            let T = Y.Transaction.from(O.signedTransaction);
            W.match(/replacement/i) &&
              W.match(/underpriced/i) &&
              (0, Z.assert)(
                !1,
                "replacement fee too low",
                "REPLACEMENT_UNDERPRICED",
                { transaction: T }
              ),
              W.match(/insufficient funds/) &&
                (0, Z.assert)(
                  !1,
                  "insufficient funds for intrinsic transaction cost",
                  "INSUFFICIENT_FUNDS",
                  { transaction: T }
                ),
              W.match(
                /same hash was already imported|transaction nonce is too low|nonce too low/
              ) &&
                (0, Z.assert)(
                  !1,
                  "nonce has already been used",
                  "NONCE_EXPIRED",
                  { transaction: T }
                );
          }
          throw T;
        }
        async _detectNetwork() {
          return this.network;
        }
        async _perform(O) {
          switch (O.method) {
            case "chainId":
              return this.network.chainId;
            case "getBlockNumber":
              return this.fetch("proxy", { action: "eth_blockNumber" });
            case "getGasPrice":
              return this.fetch("proxy", { action: "eth_gasPrice" });
            case "getPriorityFee":
              if ("mainnet" === this.network.name) return "1000000000";
              if ("optimism" === this.network.name) return "1000000";
              throw Error("fallback onto the AbstractProvider default");
            case "getBalance":
              return this.fetch("account", {
                action: "balance",
                address: O.address,
                tag: O.blockTag,
              });
            case "getTransactionCount":
              return this.fetch("proxy", {
                action: "eth_getTransactionCount",
                address: O.address,
                tag: O.blockTag,
              });
            case "getCode":
              return this.fetch("proxy", {
                action: "eth_getCode",
                address: O.address,
                tag: O.blockTag,
              });
            case "getStorage":
              return this.fetch("proxy", {
                action: "eth_getStorageAt",
                address: O.address,
                position: O.position,
                tag: O.blockTag,
              });
            case "broadcastTransaction":
              return this.fetch(
                "proxy",
                { action: "eth_sendRawTransaction", hex: O.signedTransaction },
                !0
              ).catch((T) => this._checkError(O, T, O.signedTransaction));
            case "getBlock":
              if ("blockTag" in O)
                return this.fetch("proxy", {
                  action: "eth_getBlockByNumber",
                  tag: O.blockTag,
                  boolean: O.includeTransactions ? "true" : "false",
                });
              (0, Z.assert)(
                !1,
                "getBlock by blockHash not supported by Etherscan",
                "UNSUPPORTED_OPERATION",
                { operation: "getBlock(blockHash)" }
              );
            case "getTransaction":
              return this.fetch("proxy", {
                action: "eth_getTransactionByHash",
                txhash: O.hash,
              });
            case "getTransactionReceipt":
              return this.fetch("proxy", {
                action: "eth_getTransactionReceipt",
                txhash: O.hash,
              });
            case "call": {
              if ("latest" !== O.blockTag)
                throw Error(
                  "EtherscanProvider does not support blockTag for call"
                );
              let T = this._getTransactionPostData(O.transaction);
              (T.module = "proxy"), (T.action = "eth_call");
              try {
                return await this.fetch("proxy", T, !0);
              } catch (T) {
                return this._checkError(O, T, O.transaction);
              }
            }
            case "estimateGas": {
              let T = this._getTransactionPostData(O.transaction);
              (T.module = "proxy"), (T.action = "eth_estimateGas");
              try {
                return await this.fetch("proxy", T, !0);
              } catch (T) {
                return this._checkError(O, T, O.transaction);
              }
            }
          }
          return super._perform(O);
        }
        async getNetwork() {
          return this.network;
        }
        async getEtherPrice() {
          return "mainnet" !== this.network.name
            ? 0
            : parseFloat(
                (await this.fetch("stats", { action: "ethprice" })).ethusd
              );
        }
        async getContract(O) {
          let T = this._getAddress(O);
          es(T) && (T = await T);
          try {
            let O = await this.fetch("contract", {
                action: "getabi",
                address: T,
              }),
              L = JSON.parse(O);
            return new W.Contract(T, L, this);
          } catch (O) {
            return null;
          }
        }
        isCommunityResource() {
          return null == this.apiKey;
        }
      }
      T.EtherscanProvider = eu;
    },
    36843: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.FallbackProvider = void 0);
      let J = L(38478),
        W = L(58978),
        Y = L(61927),
        Z = BigInt("1"),
        X = BigInt("2");
      function ee(O) {
        for (let T = O.length - 1; T > 0; T--) {
          let L = Math.floor(Math.random() * (T + 1)),
            J = O[T];
          (O[T] = O[L]), (O[L] = J);
        }
      }
      function et(O) {
        return new Promise((T) => {
          setTimeout(T, O);
        });
      }
      function er() {
        return new Date().getTime();
      }
      function en(O) {
        return JSON.stringify(O, (O, T) =>
          "bigint" == typeof T ? { type: "bigint", value: T.toString() } : T
        );
      }
      let es = { stallTimeout: 400, priority: 1, weight: 1 },
        ei = {
          blockNumber: -2,
          requests: 0,
          lateResponses: 0,
          errorResponses: 0,
          outOfSync: -1,
          unsupportedEvents: 0,
          rollingDuration: 0,
          score: 0,
          _network: null,
          _updateNumber: null,
          _totalTime: 0,
          _lastFatalError: null,
          _lastFatalErrorTimestamp: 0,
        };
      async function ea(O, T) {
        for (
          ;
          (O.blockNumber < 0 || O.blockNumber < T) &&
          (O._updateNumber ||
            (O._updateNumber = (async () => {
              try {
                let T = await O.provider.getBlockNumber();
                T > O.blockNumber && (O.blockNumber = T);
              } catch (T) {
                (O.blockNumber = -2),
                  (O._lastFatalError = T),
                  (O._lastFatalErrorTimestamp = er());
              }
              O._updateNumber = null;
            })()),
          await O._updateNumber,
          O.outOfSync++,
          !O._lastFatalError);

        );
      }
      function eo(O) {
        if (null == O) return "null";
        if (Array.isArray(O)) return "[" + O.map(eo).join(",") + "]";
        if ("object" == typeof O && "function" == typeof O.toJSON)
          return eo(O.toJSON());
        switch (typeof O) {
          case "boolean":
          case "symbol":
            return O.toString();
          case "bigint":
          case "number":
            return BigInt(O).toString();
          case "string":
            return JSON.stringify(O);
          case "object": {
            let T = Object.keys(O);
            return (
              T.sort(),
              "{" +
                T.map((T) => `${JSON.stringify(T)}:${eo(O[T])}`).join(",") +
                "}"
            );
          }
        }
        throw (console.log("Could not serialize", O), Error("Hmm..."));
      }
      function ec(O) {
        if ("error" in O) {
          let T = O.error;
          return { tag: eo(T), value: T };
        }
        let T = O.result;
        return { tag: eo(T), value: T };
      }
      function eu(O, T) {
        let L = new Map();
        for (let { value: O, tag: J, weight: W } of T) {
          let T = L.get(J) || { value: O, weight: 0 };
          (T.weight += W), L.set(J, T);
        }
        let J = null;
        for (let T of L.values())
          T.weight >= O && (!J || T.weight > J.weight) && (J = T);
        if (J) return J.value;
      }
      function eh(O, T) {
        let L = 0,
          J = new Map(),
          W = null,
          Y = [];
        for (let { value: O, tag: Z, weight: X } of T)
          if (O instanceof Error) {
            let T = J.get(Z) || { value: O, weight: 0 };
            (T.weight += X),
              J.set(Z, T),
              (null == W || T.weight > W.weight) && (W = T);
          } else Y.push(BigInt(O)), (L += X);
        if (L < O) return W && W.weight >= O ? W.value : void 0;
        Y.sort((O, T) => (O < T ? -1 : T > O ? 1 : 0));
        let ee = Math.floor(Y.length / 2);
        return Y.length % 2 ? Y[ee] : (Y[ee - 1] + Y[ee] + Z) / X;
      }
      function ed(O, T) {
        let L = eu(O, T);
        if (void 0 !== L) return L;
        for (let O of T) if (O.value) return O.value;
      }
      function ep(O, T) {
        let L;
        if (1 === O) return (0, J.getNumber)(eh(O, T), "%internal");
        let W = new Map(),
          Y = (O, T) => {
            let L = W.get(O) || { result: O, weight: 0 };
            (L.weight += T), W.set(O, L);
          };
        for (let { weight: O, value: L } of T) {
          let T = (0, J.getNumber)(L);
          Y(T - 1, O), Y(T, O), Y(T + 1, O);
        }
        let Z = 0;
        for (let { weight: T, result: J } of W.values())
          T >= O &&
            (T > Z || (null != L && T === Z && J > L)) &&
            ((Z = T), (L = J));
        return L;
      }
      class eg extends W.AbstractProvider {
        constructor(O, T, L) {
          super(T, L),
            (this._el = O.map((O) =>
              O instanceof W.AbstractProvider
                ? Object.assign({ provider: O }, es, ei)
                : Object.assign({}, es, O, ei)
            )),
            (this._ec = -2),
            (this._eu = null),
            L && null != L.quorum
              ? (this.quorum = L.quorum)
              : (this.quorum = Math.ceil(
                  this._el.reduce((O, T) => (O += T.weight), 0) / 2
                )),
            (this.eventQuorum = 1),
            (this.eventWorkers = 1),
            (0, J.assertArgument)(
              this.quorum <= this._el.reduce((O, T) => O + T.weight, 0),
              "quorum exceed provider wieght",
              "quorum",
              this.quorum
            );
        }
        get providerConfigs() {
          return this._el.map((O) => {
            let T = Object.assign({}, O);
            for (let O in T) "_" === O[0] && delete T[O];
            return T;
          });
        }
        async _detectNetwork() {
          return Y.Network.from(
            (0, J.getBigInt)(await this._perform({ method: "chainId" }))
          );
        }
        async _translatePerform(O, T) {
          switch (T.method) {
            case "broadcastTransaction":
              return await O.broadcastTransaction(T.signedTransaction);
            case "call":
              return await O.call(
                Object.assign({}, T.transaction, { blockTag: T.blockTag })
              );
            case "chainId":
              return (await O.getNetwork()).chainId;
            case "estimateGas":
              return await O.estimateGas(T.transaction);
            case "getBalance":
              return await O.getBalance(T.address, T.blockTag);
            case "getBlock": {
              let L = "blockHash" in T ? T.blockHash : T.blockTag;
              return await O.getBlock(L, T.includeTransactions);
            }
            case "getBlockNumber":
              return await O.getBlockNumber();
            case "getCode":
              return await O.getCode(T.address, T.blockTag);
            case "getGasPrice":
              return (await O.getFeeData()).gasPrice;
            case "getPriorityFee":
              return (await O.getFeeData()).maxPriorityFeePerGas;
            case "getLogs":
              return await O.getLogs(T.filter);
            case "getStorage":
              return await O.getStorage(T.address, T.position, T.blockTag);
            case "getTransaction":
              return await O.getTransaction(T.hash);
            case "getTransactionCount":
              return await O.getTransactionCount(T.address, T.blockTag);
            case "getTransactionReceipt":
              return await O.getTransactionReceipt(T.hash);
            case "getTransactionResult":
              return await O.getTransactionResult(T.hash);
          }
        }
        __eh(O) {
          let T = Array.from(O).map((O) => O.config),
            L = this._el.slice();
          for (let O of (ee(L), L.sort((O, T) => O.priority - T.priority), L))
            if (!O._lastFatalError && -1 === T.indexOf(O)) return O;
          return null;
        }
        __ed(O, T) {
          let L = this.__eh(O);
          if (null == L) return null;
          let J = {
              config: L,
              result: null,
              didBump: !1,
              perform: null,
              staller: null,
            },
            W = er();
          return (
            (J.perform = (async () => {
              try {
                L.requests++;
                let O = await this._translatePerform(L.provider, T);
                J.result = { result: O };
              } catch (O) {
                L.errorResponses++, (J.result = { error: O });
              }
              let O = er() - W;
              (L._totalTime += O),
                (L.rollingDuration = 0.95 * L.rollingDuration + 0.05 * O),
                (J.perform = null);
            })()),
            (J.staller = (async () => {
              await et(L.stallTimeout), (J.staller = null);
            })()),
            O.add(J),
            J
          );
        }
        async __ep() {
          let O = this._eu;
          if (!O) {
            let T = [];
            this._el.forEach((O) => {
              T.push(
                (async () => {
                  await ea(O, 0),
                    O._lastFatalError ||
                      (O._network = await O.provider.getNetwork());
                })()
              );
            }),
              (this._eu = O =
                (async () => {
                  await Promise.all(T);
                  let O = null;
                  for (let T of this._el) {
                    if (T._lastFatalError) continue;
                    let L = T._network;
                    null == O
                      ? (O = L.chainId)
                      : L.chainId !== O &&
                        (0, J.assert)(
                          !1,
                          "cannot mix providers on different networks",
                          "UNSUPPORTED_OPERATION",
                          { operation: "new FallbackProvider" }
                        );
                  }
                })());
          }
          await O;
        }
        async __ef(O, T) {
          let L = [];
          for (let T of O)
            if (null != T.result) {
              let { tag: O, value: J } = ec(T.result);
              L.push({ tag: O, value: J, weight: T.config.weight });
            }
          if (!(L.reduce((O, T) => O + T.weight, 0) < this.quorum)) {
            switch (T.method) {
              case "getBlockNumber": {
                -2 === this._ec &&
                  (this._ec = Math.ceil(
                    (0, J.getNumber)(
                      eh(
                        this.quorum,
                        this._el
                          .filter((O) => !O._lastFatalError)
                          .map((O) => ({
                            value: O.blockNumber,
                            tag: (0, J.getNumber)(O.blockNumber).toString(),
                            weight: O.weight,
                          }))
                      )
                    )
                  ));
                let O = ep(this.quorum, L);
                if (void 0 === O) return;
                return O > this._ec && (this._ec = O), this._ec;
              }
              case "getGasPrice":
              case "getPriorityFee":
              case "estimateGas":
                return eh(this.quorum, L);
              case "getBlock":
                if ("blockTag" in T && "pending" === T.blockTag)
                  return ed(this.quorum, L);
                return eu(this.quorum, L);
              case "call":
              case "chainId":
              case "getBalance":
              case "getTransactionCount":
              case "getCode":
              case "getStorage":
              case "getTransaction":
              case "getTransactionReceipt":
              case "getLogs":
                return eu(this.quorum, L);
              case "broadcastTransaction":
                return ed(this.quorum, L);
            }
            (0, J.assert)(!1, "unsupported method", "UNSUPPORTED_OPERATION", {
              operation: `_perform(${en(T.method)})`,
            });
          }
        }
        async __eg(O, T) {
          if (0 === O.size) throw Error("no runners?!");
          let L = [],
            W = 0;
          for (let T of O) {
            if ((T.perform && L.push(T.perform), T.staller)) {
              L.push(T.staller);
              continue;
            }
            !T.didBump && ((T.didBump = !0), W++);
          }
          let Y = await this.__ef(O, T);
          if (void 0 !== Y) {
            if (Y instanceof Error) throw Y;
            return Y;
          }
          for (let L = 0; L < W; L++) this.__ed(O, T);
          return (
            (0, J.assert)(L.length > 0, "quorum not met", "SERVER_ERROR", {
              request: "%sub-requests",
              info: {
                request: T,
                results: Array.from(O).map((O) => en(O.result)),
              },
            }),
            await Promise.race(L),
            await this.__eg(O, T)
          );
        }
        async _perform(O) {
          if ("broadcastTransaction" === O.method) {
            let T = this._el.map((O) => null),
              L = this._el.map(async ({ provider: L, weight: J }, W) => {
                try {
                  let Y = await L._perform(O);
                  T[W] = Object.assign(ec({ result: Y }), { weight: J });
                } catch (O) {
                  T[W] = Object.assign(ec({ error: O }), { weight: J });
                }
              });
            for (;;) {
              for (let { value: O } of T.filter((O) => null != O))
                if (!(O instanceof Error)) return O;
              let O = eu(
                this.quorum,
                T.filter((O) => null != O)
              );
              if ((0, J.isError)(O, "INSUFFICIENT_FUNDS")) throw O;
              let W = L.filter((O, L) => null == T[L]);
              if (0 === W.length) break;
              await Promise.race(W);
            }
            let W = ed(this.quorum, T);
            if (
              ((0, J.assert)(
                void 0 !== W,
                "problem multi-broadcasting",
                "SERVER_ERROR",
                {
                  request: "%sub-requests",
                  info: { request: O, results: T.map(en) },
                }
              ),
              W instanceof Error)
            )
              throw W;
            return W;
          }
          await this.__ep();
          let T = new Set(),
            L = 0;
          for (;;) {
            let J = this.__ed(T, O);
            if (null == J || (L += J.config.weight) >= this.quorum) break;
          }
          let W = await this.__eg(T, O);
          for (let O of T)
            O.perform && null == O.result && O.config.lateResponses++;
          return W;
        }
        async destroy() {
          for (let { provider: O } of this._el) O.destroy();
          super.destroy();
        }
      }
      T.FallbackProvider = eg;
    },
    26860: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.InfuraProvider = T.InfuraWebSocketProvider = void 0);
      let J = L(38478),
        W = L(80734),
        Y = L(61927),
        Z = L(88997),
        X = L(82083),
        ee = "84842078b09946638c03157f83405213";
      function et(O) {
        switch (O) {
          case "mainnet":
            return "mainnet.infura.io";
          case "goerli":
            return "goerli.infura.io";
          case "sepolia":
            return "sepolia.infura.io";
          case "arbitrum":
            return "arbitrum-mainnet.infura.io";
          case "arbitrum-goerli":
            return "arbitrum-goerli.infura.io";
          case "arbitrum-sepolia":
            return "arbitrum-sepolia.infura.io";
          case "base":
            return "base-mainnet.infura.io";
          case "base-goerlia":
            return "base-goerli.infura.io";
          case "base-sepolia":
            return "base-sepolia.infura.io";
          case "bnb":
            return "bnbsmartchain-mainnet.infura.io";
          case "bnbt":
            return "bnbsmartchain-testnet.infura.io";
          case "linea":
            return "linea-mainnet.infura.io";
          case "linea-goerli":
            return "linea-goerli.infura.io";
          case "matic":
            return "polygon-mainnet.infura.io";
          case "matic-mumbai":
            return "polygon-mumbai.infura.io";
          case "optimism":
            return "optimism-mainnet.infura.io";
          case "optimism-goerli":
            return "optimism-goerli.infura.io";
          case "optimism-sepolia":
            return "optimism-sepolia.infura.io";
        }
        (0, J.assertArgument)(!1, "unsupported network", "network", O);
      }
      class er extends X.WebSocketProvider {
        constructor(O, T) {
          let L = new en(O, T),
            W = L._getConnection();
          (0, J.assert)(
            !W.credentials,
            "INFURA WebSocket project secrets unsupported",
            "UNSUPPORTED_OPERATION",
            { operation: "InfuraProvider.getWebSocketProvider()" }
          ),
            super(W.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/"), O),
            (0, J.defineProperties)(this, {
              projectId: L.projectId,
              projectSecret: L.projectSecret,
            });
        }
        isCommunityResource() {
          return this.projectId === ee;
        }
      }
      T.InfuraWebSocketProvider = er;
      class en extends Z.JsonRpcProvider {
        constructor(O, T, L) {
          null == O && (O = "mainnet");
          let W = Y.Network.from(O);
          null == T && (T = ee),
            null == L && (L = null),
            super(en.getRequest(W, T, L), W, { staticNetwork: W }),
            (0, J.defineProperties)(this, { projectId: T, projectSecret: L });
        }
        _getProvider(O) {
          try {
            return new en(O, this.projectId, this.projectSecret);
          } catch (O) {}
          return super._getProvider(O);
        }
        isCommunityResource() {
          return this.projectId === ee;
        }
        static getWebSocketProvider(O, T) {
          return new er(O, T);
        }
        static getRequest(O, T, L) {
          null == T && (T = ee), null == L && (L = null);
          let Y = new J.FetchRequest(`https://${et(O.name)}/v3/${T}`);
          return (
            (Y.allowGzip = !0),
            L && Y.setCredentials("", L),
            T === ee &&
              (Y.retryFunc = async (O, T, L) => (
                (0, W.showThrottleMessage)("InfuraProvider"), !0
              )),
            Y
          );
        }
      }
      T.InfuraProvider = en;
    },
    62524: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.IpcSocketProvider = void 0);
      let L = void 0;
      T.IpcSocketProvider = L;
    },
    88997: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.JsonRpcProvider =
          T.JsonRpcApiPollingProvider =
          T.JsonRpcApiProvider =
          T.JsonRpcSigner =
            void 0);
      let J = L(16330),
        W = L(40431),
        Y = L(41648),
        Z = L(16989),
        X = L(38478),
        ee = L(58978),
        et = L(70690),
        er = L(61927),
        en = L(97288),
        es = L(22896),
        ei = "bigint,boolean,function,number,string,symbol".split(/,/g);
      function ea(O) {
        if (
          null == O ||
          ei.indexOf(typeof O) >= 0 ||
          "function" == typeof O.getAddress
        )
          return O;
        if (Array.isArray(O)) return O.map(ea);
        if ("object" == typeof O)
          return Object.keys(O).reduce((T, L) => ((T[L] = O[L]), T), {});
        throw Error(`should not happen: ${O} (${typeof O})`);
      }
      function eo(O) {
        return new Promise((T) => {
          setTimeout(T, O);
        });
      }
      function ec(O) {
        return O ? O.toLowerCase() : O;
      }
      function eu(O) {
        return O && "number" == typeof O.pollingInterval;
      }
      let eh = {
        polling: !1,
        staticNetwork: null,
        batchStallTime: 10,
        batchMaxSize: 1048576,
        batchMaxCount: 100,
        cacheTimeout: 250,
        pollingInterval: 4e3,
      };
      class ed extends et.AbstractSigner {
        constructor(O, T) {
          super(O),
            (T = (0, W.getAddress)(T)),
            (0, X.defineProperties)(this, { address: T });
        }
        connect(O) {
          (0, X.assert)(
            !1,
            "cannot reconnect JsonRpcSigner",
            "UNSUPPORTED_OPERATION",
            { operation: "signer.connect" }
          );
        }
        async getAddress() {
          return this.address;
        }
        async populateTransaction(O) {
          return await this.populateCall(O);
        }
        async sendUncheckedTransaction(O) {
          let T = ea(O),
            L = [];
          if (T.from) {
            let J = T.from;
            L.push(
              (async () => {
                let L = await (0, W.resolveAddress)(J, this.provider);
                (0, X.assertArgument)(
                  null != L && L.toLowerCase() === this.address.toLowerCase(),
                  "from address mismatch",
                  "transaction",
                  O
                ),
                  (T.from = L);
              })()
            );
          } else T.from = this.address;
          if (
            (null == T.gasLimit &&
              L.push(
                (async () => {
                  T.gasLimit = await this.provider.estimateGas({
                    ...T,
                    from: this.address,
                  });
                })()
              ),
            null != T.to)
          ) {
            let O = T.to;
            L.push(
              (async () => {
                T.to = await (0, W.resolveAddress)(O, this.provider);
              })()
            );
          }
          L.length && (await Promise.all(L));
          let J = this.provider.getRpcTransaction(T);
          return this.provider.send("eth_sendTransaction", [J]);
        }
        async sendTransaction(O) {
          let T = await this.provider.getBlockNumber(),
            L = await this.sendUncheckedTransaction(O);
          return await new Promise((O, J) => {
            let W = [1e3, 100],
              Y = 0,
              Z = async () => {
                try {
                  let J = await this.provider.getTransaction(L);
                  if (null != J) {
                    O(J.replaceableTransaction(T));
                    return;
                  }
                } catch (O) {
                  if (
                    (0, X.isError)(O, "CANCELLED") ||
                    (0, X.isError)(O, "BAD_DATA") ||
                    (0, X.isError)(O, "NETWORK_ERROR")
                  ) {
                    null == O.info && (O.info = {}),
                      (O.info.sendTransactionHash = L),
                      J(O);
                    return;
                  }
                  if (
                    (0, X.isError)(O, "INVALID_ARGUMENT") &&
                    (Y++,
                    null == O.info && (O.info = {}),
                    (O.info.sendTransactionHash = L),
                    Y > 10)
                  ) {
                    J(O);
                    return;
                  }
                  this.provider.emit(
                    "error",
                    (0, X.makeError)(
                      "failed to fetch transation after sending (will try again)",
                      "UNKNOWN_ERROR",
                      { error: O }
                    )
                  );
                }
                this.provider._setTimeout(() => {
                  Z();
                }, W.pop() || 4e3);
              };
            Z();
          });
        }
        async signTransaction(O) {
          let T = ea(O);
          if (T.from) {
            let L = await (0, W.resolveAddress)(T.from, this.provider);
            (0, X.assertArgument)(
              null != L && L.toLowerCase() === this.address.toLowerCase(),
              "from address mismatch",
              "transaction",
              O
            ),
              (T.from = L);
          } else T.from = this.address;
          let L = this.provider.getRpcTransaction(T);
          return await this.provider.send("eth_signTransaction", [L]);
        }
        async signMessage(O) {
          let T = "string" == typeof O ? (0, X.toUtf8Bytes)(O) : O;
          return await this.provider.send("personal_sign", [
            (0, X.hexlify)(T),
            this.address.toLowerCase(),
          ]);
        }
        async signTypedData(O, T, L) {
          let J = ea(L),
            Z = await Y.TypedDataEncoder.resolveNames(O, T, J, async (O) => {
              let T = await (0, W.resolveAddress)(O);
              return (
                (0, X.assertArgument)(
                  null != T,
                  "TypedData does not support null address",
                  "value",
                  O
                ),
                T
              );
            });
          return await this.provider.send("eth_signTypedData_v4", [
            this.address.toLowerCase(),
            JSON.stringify(Y.TypedDataEncoder.getPayload(Z.domain, T, Z.value)),
          ]);
        }
        async unlock(O) {
          return this.provider.send("personal_unlockAccount", [
            this.address.toLowerCase(),
            O,
            null,
          ]);
        }
        async _legacySignMessage(O) {
          let T = "string" == typeof O ? (0, X.toUtf8Bytes)(O) : O;
          return await this.provider.send("eth_sign", [
            this.address.toLowerCase(),
            (0, X.hexlify)(T),
          ]);
        }
      }
      T.JsonRpcSigner = ed;
      class ep extends ee.AbstractProvider {
        __ek() {
          if (this._eb) return;
          let O =
            1 === this._getOption("batchMaxCount")
              ? 0
              : this._getOption("batchStallTime");
          this._eb = setTimeout(() => {
            this._eb = null;
            let O = this._em;
            for (this._em = []; O.length; ) {
              let T = [O.shift()];
              for (; O.length && T.length !== this.w__0.batchMaxCount; )
                if (
                  (T.push(O.shift()),
                  JSON.stringify(T.map((O) => O.payload)).length >
                    this.w__0.batchMaxSize)
                ) {
                  O.unshift(T.pop());
                  break;
                }
              (async () => {
                let O = 1 === T.length ? T[0].payload : T.map((O) => O.payload);
                this.emit("debug", { action: "sendRpcPayload", payload: O });
                try {
                  let L = await this._send(O);
                  for (let { resolve: O, reject: J, payload: W } of (this.emit(
                    "debug",
                    { action: "receiveRpcResult", result: L }
                  ),
                  T)) {
                    if (this.destroyed) {
                      J(
                        (0, X.makeError)(
                          "provider destroyed; cancelled request",
                          "UNSUPPORTED_OPERATION",
                          { operation: W.method }
                        )
                      );
                      continue;
                    }
                    let T = L.filter((O) => O.id === W.id)[0];
                    if (null == T) {
                      let O = (0, X.makeError)(
                        "missing response for request",
                        "BAD_DATA",
                        { value: L, info: { payload: W } }
                      );
                      this.emit("error", O), J(O);
                      continue;
                    }
                    if ("error" in T) {
                      J(this.getRpcError(W, T));
                      continue;
                    }
                    O(T.result);
                  }
                } catch (O) {
                  for (let { reject: L } of (this.emit("debug", {
                    action: "receiveRpcError",
                    error: O,
                  }),
                  T))
                    L(O);
                }
              })();
            }
          }, O);
        }
        constructor(O, T) {
          super(O, T),
            (this._ey = 1),
            (this.w__0 = Object.assign({}, eh, T || {})),
            (this._em = []),
            (this._eb = null),
            (this._ew = null),
            (this._ev = null);
          {
            let O = null,
              T = new Promise((T) => {
                O = T;
              });
            this._eA = { promise: T, resolve: O };
          }
          let L = this._getOption("staticNetwork");
          "boolean" == typeof L
            ? ((0, X.assertArgument)(
                !L || "any" !== O,
                "staticNetwork cannot be used on special network 'any'",
                "options",
                T
              ),
              L && null != O && (this._ew = er.Network.from(O)))
            : L &&
              ((0, X.assertArgument)(
                null == O || L.matches(O),
                "staticNetwork MUST match network object",
                "options",
                T
              ),
              (this._ew = L));
        }
        _getOption(O) {
          return this.w__0[O];
        }
        get _network() {
          return (
            (0, X.assert)(
              this._ew,
              "network is not available yet",
              "NETWORK_ERROR"
            ),
            this._ew
          );
        }
        async _perform(O) {
          if ("call" === O.method || "estimateGas" === O.method) {
            let T = O.transaction;
            if (
              T &&
              null != T.type &&
              (0, X.getBigInt)(T.type) &&
              null == T.maxFeePerGas &&
              null == T.maxPriorityFeePerGas
            ) {
              let L = await this.getFeeData();
              null == L.maxFeePerGas &&
                null == L.maxPriorityFeePerGas &&
                (O = Object.assign({}, O, {
                  transaction: Object.assign({}, T, { type: void 0 }),
                }));
            }
          }
          let T = this.getRpcRequest(O);
          return null != T
            ? await this.send(T.method, T.args)
            : super._perform(O);
        }
        async _detectNetwork() {
          let O = this._getOption("staticNetwork");
          if (O) {
            if (!0 !== O) return O;
            if (this._ew) return this._ew;
          }
          return (
            this._ev ||
              (this.ready
                ? (this._ev = (async () => {
                    try {
                      let O = er.Network.from(
                        (0, X.getBigInt)(await this.send("eth_chainId", []))
                      );
                      return (this._ev = null), O;
                    } catch (O) {
                      throw ((this._ev = null), O);
                    }
                  })())
                : (this._ev = (async () => {
                    let O;
                    let T = {
                      id: this._ey++,
                      method: "eth_chainId",
                      params: [],
                      jsonrpc: "2.0",
                    };
                    this.emit("debug", {
                      action: "sendRpcPayload",
                      payload: T,
                    });
                    try {
                      (O = (await this._send(T))[0]), (this._ev = null);
                    } catch (O) {
                      throw (
                        ((this._ev = null),
                        this.emit("debug", {
                          action: "receiveRpcError",
                          error: O,
                        }),
                        O)
                      );
                    }
                    if (
                      (this.emit("debug", {
                        action: "receiveRpcResult",
                        result: O,
                      }),
                      "result" in O)
                    )
                      return er.Network.from((0, X.getBigInt)(O.result));
                    throw this.getRpcError(T, O);
                  })())),
            await this._ev
          );
        }
        _start() {
          null != this._eA &&
            null != this._eA.resolve &&
            (this._eA.resolve(),
            (this._eA = null),
            (async () => {
              for (; null == this._ew && !this.destroyed; )
                try {
                  this._ew = await this._detectNetwork();
                } catch (O) {
                  if (this.destroyed) break;
                  console.log(
                    "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
                  ),
                    this.emit(
                      "error",
                      (0, X.makeError)(
                        "failed to bootstrap network detection",
                        "NETWORK_ERROR",
                        {
                          event: "initial-network-discovery",
                          info: { error: O },
                        }
                      )
                    ),
                    await eo(1e3);
                }
              this.__ek();
            })());
        }
        async _waitUntilReady() {
          if (null != this._eA) return await this._eA.promise;
        }
        _getSubscriber(O) {
          return "pending" === O.type
            ? new en.FilterIdPendingSubscriber(this)
            : "event" === O.type
            ? this._getOption("polling")
              ? new es.PollingEventSubscriber(this, O.filter)
              : new en.FilterIdEventSubscriber(this, O.filter)
            : "orphan" === O.type && "drop-log" === O.filter.orphan
            ? new ee.UnmanagedSubscriber("orphan")
            : super._getSubscriber(O);
        }
        get ready() {
          return null == this._eA;
        }
        getRpcTransaction(O) {
          let T = {};
          return (
            [
              "chainId",
              "gasLimit",
              "gasPrice",
              "type",
              "maxFeePerGas",
              "maxPriorityFeePerGas",
              "nonce",
              "value",
            ].forEach((L) => {
              if (null == O[L]) return;
              let J = L;
              "gasLimit" === L && (J = "gas"),
                (T[J] = (0, X.toQuantity)((0, X.getBigInt)(O[L], `tx.${L}`)));
            }),
            ["from", "to", "data"].forEach((L) => {
              null != O[L] && (T[L] = (0, X.hexlify)(O[L]));
            }),
            O.accessList && (T.accessList = (0, Z.accessListify)(O.accessList)),
            T
          );
        }
        getRpcRequest(O) {
          switch (O.method) {
            case "chainId":
              return { method: "eth_chainId", args: [] };
            case "getBlockNumber":
              return { method: "eth_blockNumber", args: [] };
            case "getGasPrice":
              return { method: "eth_gasPrice", args: [] };
            case "getPriorityFee":
              return { method: "eth_maxPriorityFeePerGas", args: [] };
            case "getBalance":
              return {
                method: "eth_getBalance",
                args: [ec(O.address), O.blockTag],
              };
            case "getTransactionCount":
              return {
                method: "eth_getTransactionCount",
                args: [ec(O.address), O.blockTag],
              };
            case "getCode":
              return {
                method: "eth_getCode",
                args: [ec(O.address), O.blockTag],
              };
            case "getStorage":
              return {
                method: "eth_getStorageAt",
                args: [
                  ec(O.address),
                  "0x" + O.position.toString(16),
                  O.blockTag,
                ],
              };
            case "broadcastTransaction":
              return {
                method: "eth_sendRawTransaction",
                args: [O.signedTransaction],
              };
            case "getBlock":
              if ("blockTag" in O)
                return {
                  method: "eth_getBlockByNumber",
                  args: [O.blockTag, !!O.includeTransactions],
                };
              if ("blockHash" in O)
                return {
                  method: "eth_getBlockByHash",
                  args: [O.blockHash, !!O.includeTransactions],
                };
              break;
            case "getTransaction":
              return { method: "eth_getTransactionByHash", args: [O.hash] };
            case "getTransactionReceipt":
              return { method: "eth_getTransactionReceipt", args: [O.hash] };
            case "call":
              return {
                method: "eth_call",
                args: [this.getRpcTransaction(O.transaction), O.blockTag],
              };
            case "estimateGas":
              return {
                method: "eth_estimateGas",
                args: [this.getRpcTransaction(O.transaction)],
              };
            case "getLogs":
              return (
                O.filter &&
                  null != O.filter.address &&
                  (Array.isArray(O.filter.address)
                    ? (O.filter.address = O.filter.address.map(ec))
                    : (O.filter.address = ec(O.filter.address))),
                { method: "eth_getLogs", args: [O.filter] }
              );
          }
          return null;
        }
        getRpcError(O, T) {
          let { method: L } = O,
            { error: W } = T;
          if ("eth_estimateGas" === L && W.message) {
            let T = W.message;
            if (!T.match(/revert/i) && T.match(/insufficient funds/i))
              return (0, X.makeError)(
                "insufficient funds",
                "INSUFFICIENT_FUNDS",
                { transaction: O.params[0], info: { payload: O, error: W } }
              );
          }
          if ("eth_call" === L || "eth_estimateGas" === L) {
            let T = em(W),
              Y = J.AbiCoder.getBuiltinCallException(
                "eth_call" === L ? "call" : "estimateGas",
                O.params[0],
                T ? T.data : null
              );
            return (Y.info = { error: W, payload: O }), Y;
          }
          let Y = JSON.stringify(eA(W));
          if (
            "string" == typeof W.message &&
            W.message.match(/user denied|ethers-user-denied/i)
          ) {
            let T = {
              eth_sign: "signMessage",
              personal_sign: "signMessage",
              eth_signTypedData_v4: "signTypedData",
              eth_signTransaction: "signTransaction",
              eth_sendTransaction: "sendTransaction",
              eth_requestAccounts: "requestAccess",
              wallet_requestAccounts: "requestAccess",
            };
            return (0, X.makeError)("user rejected action", "ACTION_REJECTED", {
              action: T[L] || "unknown",
              reason: "rejected",
              info: { payload: O, error: W },
            });
          }
          if ("eth_sendRawTransaction" === L || "eth_sendTransaction" === L) {
            let T = O.params[0];
            if (Y.match(/insufficient funds|base fee exceeds gas limit/i))
              return (0, X.makeError)(
                "insufficient funds for intrinsic transaction cost",
                "INSUFFICIENT_FUNDS",
                { transaction: T, info: { error: W } }
              );
            if (Y.match(/nonce/i) && Y.match(/too low/i))
              return (0, X.makeError)(
                "nonce has already been used",
                "NONCE_EXPIRED",
                { transaction: T, info: { error: W } }
              );
            if (Y.match(/replacement transaction/i) && Y.match(/underpriced/i))
              return (0, X.makeError)(
                "replacement fee too low",
                "REPLACEMENT_UNDERPRICED",
                { transaction: T, info: { error: W } }
              );
            if (Y.match(/only replay-protected/i))
              return (0, X.makeError)(
                "legacy pre-eip-155 transactions not supported",
                "UNSUPPORTED_OPERATION",
                { operation: L, info: { transaction: T, info: { error: W } } }
              );
          }
          let Z = !!Y.match(/the method .* does not exist/i);
          return (!Z &&
            W &&
            W.details &&
            W.details.startsWith("Unauthorized method:") &&
            (Z = !0),
          Z)
            ? (0, X.makeError)(
                "unsupported operation",
                "UNSUPPORTED_OPERATION",
                { operation: O.method, info: { error: W, payload: O } }
              )
            : (0, X.makeError)("could not coalesce error", "UNKNOWN_ERROR", {
                error: W,
                payload: O,
              });
        }
        send(O, T) {
          if (this.destroyed)
            return Promise.reject(
              (0, X.makeError)(
                "provider destroyed; cancelled request",
                "UNSUPPORTED_OPERATION",
                { operation: O }
              )
            );
          let L = this._ey++,
            J = new Promise((J, W) => {
              this._em.push({
                resolve: J,
                reject: W,
                payload: { method: O, params: T, id: L, jsonrpc: "2.0" },
              });
            });
          return this.__ek(), J;
        }
        async getSigner(O) {
          null == O && (O = 0);
          let T = this.send("eth_accounts", []);
          if ("number" == typeof O) {
            let L = await T;
            if (O >= L.length) throw Error("no such account");
            return new ed(this, L[O]);
          }
          let { accounts: L } = await (0, X.resolveProperties)({
            network: this.getNetwork(),
            accounts: T,
          });
          for (let T of ((O = (0, W.getAddress)(O)), L))
            if ((0, W.getAddress)(T) === O) return new ed(this, O);
          throw Error("invalid account");
        }
        async listAccounts() {
          return (await this.send("eth_accounts", [])).map(
            (O) => new ed(this, O)
          );
        }
        destroy() {
          for (let { payload: O, reject: T } of (this._eb &&
            (clearTimeout(this._eb), (this._eb = null)),
          this._em))
            T(
              (0, X.makeError)(
                "provider destroyed; cancelled request",
                "UNSUPPORTED_OPERATION",
                { operation: O.method }
              )
            );
          (this._em = []), super.destroy();
        }
      }
      T.JsonRpcApiProvider = ep;
      class eg extends ep {
        constructor(O, T) {
          super(O, T), (this._eE = 4e3);
        }
        _getSubscriber(O) {
          let T = super._getSubscriber(O);
          return eu(T) && (T.pollingInterval = this._eE), T;
        }
        get pollingInterval() {
          return this._eE;
        }
        set pollingInterval(O) {
          if (!Number.isInteger(O) || O < 0) throw Error("invalid interval");
          (this._eE = O),
            this._forEachSubscriber((O) => {
              eu(O) && (O.pollingInterval = this._eE);
            });
        }
      }
      T.JsonRpcApiPollingProvider = eg;
      class ey extends eg {
        constructor(O, T, L) {
          null == O && (O = "http://localhost:8545"),
            super(T, L),
            "string" == typeof O
              ? (this._eS = new X.FetchRequest(O))
              : (this._eS = O.clone());
        }
        _getConnection() {
          return this._eS.clone();
        }
        async send(O, T) {
          return await this._start(), await super.send(O, T);
        }
        async _send(O) {
          let T = this._getConnection();
          (T.body = JSON.stringify(O)),
            T.setHeader("content-type", "application/json");
          let L = await T.send();
          L.assertOk();
          let J = L.bodyJson;
          return Array.isArray(J) || (J = [J]), J;
        }
      }
      function em(O) {
        if (null == O) return null;
        if (
          "string" == typeof O.message &&
          O.message.match(/revert/i) &&
          (0, X.isHexString)(O.data)
        )
          return { message: O.message, data: O.data };
        if ("object" == typeof O) {
          for (let T in O) {
            let L = em(O[T]);
            if (L) return L;
          }
          return null;
        }
        if ("string" == typeof O)
          try {
            return em(JSON.parse(O));
          } catch (O) {}
        return null;
      }
      function eb(O, T) {
        if (null != O) {
          if (
            ("string" == typeof O.message && T.push(O.message),
            "object" == typeof O)
          )
            for (let L in O) eb(O[L], T);
          if ("string" == typeof O)
            try {
              return eb(JSON.parse(O), T);
            } catch (O) {}
        }
      }
      function eA(O) {
        let T = [];
        return eb(O, T), T;
      }
      T.JsonRpcProvider = ey;
    },
    61665: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.PocketProvider = void 0);
      let J = L(38478),
        W = L(80734),
        Y = L(61927),
        Z = L(88997),
        X = "62e1ad51b37b8e00394bda3b";
      function ee(O) {
        switch (O) {
          case "mainnet":
            return "eth-mainnet.gateway.pokt.network";
          case "goerli":
            return "eth-goerli.gateway.pokt.network";
          case "matic":
            return "poly-mainnet.gateway.pokt.network";
          case "matic-mumbai":
            return "polygon-mumbai-rpc.gateway.pokt.network";
        }
        (0, J.assertArgument)(!1, "unsupported network", "network", O);
      }
      class et extends Z.JsonRpcProvider {
        constructor(O, T, L) {
          null == O && (O = "mainnet");
          let W = Y.Network.from(O);
          null == T && (T = X),
            null == L && (L = null),
            super(et.getRequest(W, T, L), W, { staticNetwork: W }),
            (0, J.defineProperties)(this, {
              applicationId: T,
              applicationSecret: L,
            });
        }
        _getProvider(O) {
          try {
            return new et(O, this.applicationId, this.applicationSecret);
          } catch (O) {}
          return super._getProvider(O);
        }
        static getRequest(O, T, L) {
          null == T && (T = X);
          let Y = new J.FetchRequest(`https://${ee(O.name)}/v1/lb/${T}`);
          return (
            (Y.allowGzip = !0),
            L && Y.setCredentials("", L),
            T === X &&
              (Y.retryFunc = async (O, T, L) => (
                (0, W.showThrottleMessage)("PocketProvider"), !0
              )),
            Y
          );
        }
        isCommunityResource() {
          return this.applicationId === X;
        }
      }
      T.PocketProvider = et;
    },
    41980: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.QuickNodeProvider = void 0);
      let J = L(38478),
        W = L(80734),
        Y = L(61927),
        Z = L(88997),
        X = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
      function ee(O) {
        switch (O) {
          case "mainnet":
            return "ethers.quiknode.pro";
          case "goerli":
            return "ethers.ethereum-goerli.quiknode.pro";
          case "sepolia":
            return "ethers.ethereum-sepolia.quiknode.pro";
          case "holesky":
            return "ethers.ethereum-holesky.quiknode.pro";
          case "arbitrum":
            return "ethers.arbitrum-mainnet.quiknode.pro";
          case "arbitrum-goerli":
            return "ethers.arbitrum-goerli.quiknode.pro";
          case "arbitrum-sepolia":
            return "ethers.arbitrum-sepolia.quiknode.pro";
          case "base":
            return "ethers.base-mainnet.quiknode.pro";
          case "base-goerli":
            return "ethers.base-goerli.quiknode.pro";
          case "base-spolia":
            return "ethers.base-sepolia.quiknode.pro";
          case "bnb":
            return "ethers.bsc.quiknode.pro";
          case "bnbt":
            return "ethers.bsc-testnet.quiknode.pro";
          case "matic":
            return "ethers.matic.quiknode.pro";
          case "matic-mumbai":
            return "ethers.matic-testnet.quiknode.pro";
          case "optimism":
            return "ethers.optimism.quiknode.pro";
          case "optimism-goerli":
            return "ethers.optimism-goerli.quiknode.pro";
          case "optimism-sepolia":
            return "ethers.optimism-sepolia.quiknode.pro";
          case "xdai":
            return "ethers.xdai.quiknode.pro";
        }
        (0, J.assertArgument)(!1, "unsupported network", "network", O);
      }
      class et extends Z.JsonRpcProvider {
        constructor(O, T) {
          null == O && (O = "mainnet");
          let L = Y.Network.from(O);
          null == T && (T = X),
            super(et.getRequest(L, T), L, { staticNetwork: L }),
            (0, J.defineProperties)(this, { token: T });
        }
        _getProvider(O) {
          try {
            return new et(O, this.token);
          } catch (O) {}
          return super._getProvider(O);
        }
        isCommunityResource() {
          return this.token === X;
        }
        static getRequest(O, T) {
          null == T && (T = X);
          let L = new J.FetchRequest(`https://${ee(O.name)}/${T}`);
          return (
            (L.allowGzip = !0),
            T === X &&
              (L.retryFunc = async (O, T, L) => (
                (0, W.showThrottleMessage)("QuickNodeProvider"), !0
              )),
            L
          );
        }
      }
      T.QuickNodeProvider = et;
    },
    27329: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.SocketProvider =
          T.SocketEventSubscriber =
          T.SocketPendingSubscriber =
          T.SocketBlockSubscriber =
          T.SocketSubscriber =
            void 0);
      let J = L(58978),
        W = L(38478),
        Y = L(88997);
      class Z {
        get filter() {
          return JSON.parse(this.v__0);
        }
        _ex;
        _eC;
        _eB;
        constructor(O, T) {
          (this._eP = O),
            (this.v__0 = JSON.stringify(T)),
            (this._ex = null),
            (this._eC = null),
            (this._eB = null);
        }
        start() {
          this._ex = this._eP
            .send("eth_subscribe", this.filter)
            .then((O) => (this._eP._register(O, this), O));
        }
        stop() {
          this._ex.then((O) => {
            this._eP.send("eth_unsubscribe", [O]);
          }),
            (this._ex = null);
        }
        pause(O) {
          (0, W.assert)(
            O,
            "preserve logs while paused not supported by SocketSubscriber yet",
            "UNSUPPORTED_OPERATION",
            { operation: "pause(false)" }
          ),
            (this._eC = !!O);
        }
        resume() {
          this._eC = null;
        }
        _handleMessage(O) {
          if (null != this._ex && null === this._eC) {
            let T = this._eB;
            (T =
              null == T
                ? this._emit(this._eP, O)
                : T.then(async () => {
                    await this._emit(this._eP, O);
                  })),
              (this._eB = T.then(() => {
                this._eB === T && (this._eB = null);
              }));
          }
        }
        async _emit(O, T) {
          throw Error("sub-classes must implemente this; _emit");
        }
      }
      T.SocketSubscriber = Z;
      class X extends Z {
        constructor(O) {
          super(O, ["newHeads"]);
        }
        async _emit(O, T) {
          O.emit("block", parseInt(T.number));
        }
      }
      T.SocketBlockSubscriber = X;
      class ee extends Z {
        constructor(O) {
          super(O, ["newPendingTransactions"]);
        }
        async _emit(O, T) {
          O.emit("pending", T);
        }
      }
      T.SocketPendingSubscriber = ee;
      class et extends Z {
        get logFilter() {
          return JSON.parse(this._eO);
        }
        constructor(O, T) {
          super(O, ["logs", T]), (this._eO = JSON.stringify(T));
        }
        async _emit(O, T) {
          O.emit(this.logFilter, O._wrapLog(T, O._network));
        }
      }
      T.SocketEventSubscriber = et;
      class er extends Y.JsonRpcApiProvider {
        constructor(O, T) {
          let L = Object.assign({}, null != T ? T : {});
          (0, W.assertArgument)(
            null == L.batchMaxCount || 1 === L.batchMaxCount,
            "sockets-based providers do not support batches",
            "options.batchMaxCount",
            T
          ),
            (L.batchMaxCount = 1),
            null == L.staticNetwork && (L.staticNetwork = !0),
            super(O, L),
            (this._eT = new Map()),
            (this.R__0 = new Map()),
            (this._eN = new Map());
        }
        _getSubscriber(O) {
          switch (O.type) {
            case "close":
              return new J.UnmanagedSubscriber("close");
            case "block":
              return new X(this);
            case "pending":
              return new ee(this);
            case "event":
              return new et(this, O.filter);
            case "orphan":
              if ("drop-log" === O.filter.orphan)
                return new J.UnmanagedSubscriber("drop-log");
          }
          return super._getSubscriber(O);
        }
        _register(O, T) {
          this.R__0.set(O, T);
          let L = this._eN.get(O);
          if (L) {
            for (let O of L) T._handleMessage(O);
            this._eN.delete(O);
          }
        }
        async _send(O) {
          (0, W.assertArgument)(
            !Array.isArray(O),
            "WebSocket does not support batch send",
            "payload",
            O
          );
          let T = new Promise((T, L) => {
            this._eT.set(O.id, { payload: O, resolve: T, reject: L });
          });
          return (
            await this._waitUntilReady(),
            await this._write(JSON.stringify(O)),
            [await T]
          );
        }
        async _processMessage(O) {
          let T = JSON.parse(O);
          if (T && "object" == typeof T && "id" in T) {
            let O = this._eT.get(T.id);
            if (null == O) {
              this.emit(
                "error",
                (0, W.makeError)(
                  "received result for unknown id",
                  "UNKNOWN_ERROR",
                  { reasonCode: "UNKNOWN_ID", result: T }
                )
              );
              return;
            }
            this._eT.delete(T.id), O.resolve(T);
          } else if (T && "eth_subscription" === T.method) {
            let O = T.params.subscription,
              L = this.R__0.get(O);
            if (L) L._handleMessage(T.params.result);
            else {
              let L = this._eN.get(O);
              null == L && ((L = []), this._eN.set(O, L)),
                L.push(T.params.result);
            }
          } else {
            this.emit(
              "error",
              (0, W.makeError)("received unexpected message", "UNKNOWN_ERROR", {
                reasonCode: "UNEXPECTED_MESSAGE",
                result: T,
              })
            );
            return;
          }
        }
        async _write(O) {
          throw Error("sub-classes must override this");
        }
      }
      T.SocketProvider = er;
    },
    82083: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.WebSocketProvider = void 0);
      let J = L(43778),
        W = L(27329);
      class Y extends W.SocketProvider {
        get websocket() {
          if (null == this._eR) throw Error("websocket closed");
          return this._eR;
        }
        constructor(O, T, L) {
          super(T, L),
            "string" == typeof O
              ? ((this._eS = () => new J.WebSocket(O)), (this._eR = this._eS()))
              : "function" == typeof O
              ? ((this._eS = O), (this._eR = O()))
              : ((this._eS = null), (this._eR = O)),
            (this.websocket.onopen = async () => {
              try {
                await this._start(), this.resume();
              } catch (O) {
                console.log("failed to start WebsocketProvider", O);
              }
            }),
            (this.websocket.onmessage = (O) => {
              this._processMessage(O.data);
            });
        }
        async _write(O) {
          this.websocket.send(O);
        }
        async destroy() {
          null != this._eR && (this._eR.close(), (this._eR = null)),
            super.destroy();
        }
      }
      T.WebSocketProvider = Y;
    },
    27773: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.TransactionResponse =
          T.TransactionReceipt =
          T.Log =
          T.Block =
          T.copyRequest =
          T.FeeData =
            void 0);
      let J = L(38478),
        W = L(16989),
        Y = BigInt(0);
      function Z(O) {
        return null == O ? null : O;
      }
      function X(O) {
        return null == O ? null : O.toString();
      }
      class ee {
        constructor(O, T, L) {
          (0, J.defineProperties)(this, {
            gasPrice: Z(O),
            maxFeePerGas: Z(T),
            maxPriorityFeePerGas: Z(L),
          });
        }
        toJSON() {
          let { gasPrice: O, maxFeePerGas: T, maxPriorityFeePerGas: L } = this;
          return {
            _type: "FeeData",
            gasPrice: X(O),
            maxFeePerGas: X(T),
            maxPriorityFeePerGas: X(L),
          };
        }
      }
      function et(O) {
        let T = {};
        for (let L of (O.to && (T.to = O.to),
        O.from && (T.from = O.from),
        O.data && (T.data = (0, J.hexlify)(O.data)),
        "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(
          /,/
        )))
          L in O &&
            null != O[L] &&
            (T[L] = (0, J.getBigInt)(O[L], `request.${L}`));
        for (let L of "type,nonce".split(/,/))
          L in O &&
            null != O[L] &&
            (T[L] = (0, J.getNumber)(O[L], `request.${L}`));
        return (
          O.accessList && (T.accessList = (0, W.accessListify)(O.accessList)),
          "blockTag" in O && (T.blockTag = O.blockTag),
          "enableCcipRead" in O && (T.enableCcipRead = !!O.enableCcipRead),
          "customData" in O && (T.customData = O.customData),
          T
        );
      }
      (T.FeeData = ee), (T.copyRequest = et);
      class er {
        constructor(O, T) {
          (this._eI = O.transactions.map((O) =>
            "string" != typeof O ? new ei(O, T) : O
          )),
            (0, J.defineProperties)(this, {
              provider: T,
              hash: Z(O.hash),
              number: O.number,
              timestamp: O.timestamp,
              parentHash: O.parentHash,
              parentBeaconBlockRoot: O.parentBeaconBlockRoot,
              nonce: O.nonce,
              difficulty: O.difficulty,
              gasLimit: O.gasLimit,
              gasUsed: O.gasUsed,
              blobGasUsed: O.blobGasUsed,
              excessBlobGas: O.excessBlobGas,
              miner: O.miner,
              extraData: O.extraData,
              baseFeePerGas: Z(O.baseFeePerGas),
              stateRoot: O.stateRoot,
              receiptsRoot: O.receiptsRoot,
            });
        }
        get transactions() {
          return this._eI.map((O) => ("string" == typeof O ? O : O.hash));
        }
        get prefetchedTransactions() {
          let O = this._eI.slice();
          return 0 === O.length
            ? []
            : ((0, J.assert)(
                "object" == typeof O[0],
                "transactions were not prefetched with block request",
                "UNSUPPORTED_OPERATION",
                { operation: "transactionResponses()" }
              ),
              O);
        }
        toJSON() {
          let {
            baseFeePerGas: O,
            difficulty: T,
            extraData: L,
            gasLimit: J,
            gasUsed: W,
            hash: Y,
            miner: Z,
            nonce: ee,
            number: et,
            parentHash: er,
            parentBeaconBlockRoot: en,
            stateRoot: es,
            receiptsRoot: ei,
            timestamp: ea,
            transactions: eo,
          } = this;
          return {
            _type: "Block",
            baseFeePerGas: X(O),
            difficulty: X(T),
            extraData: L,
            gasLimit: X(J),
            gasUsed: X(W),
            blobGasUsed: X(this.blobGasUsed),
            excessBlobGas: X(this.excessBlobGas),
            hash: Y,
            miner: Z,
            nonce: ee,
            number: et,
            parentHash: er,
            timestamp: ea,
            parentBeaconBlockRoot: en,
            stateRoot: es,
            receiptsRoot: ei,
            transactions: eo,
          };
        }
        [Symbol.iterator]() {
          let O = 0,
            T = this.transactions;
          return {
            next: () =>
              O < this.length
                ? { value: T[O++], done: !1 }
                : { value: void 0, done: !0 },
          };
        }
        get length() {
          return this._eI.length;
        }
        get date() {
          return null == this.timestamp ? null : new Date(1e3 * this.timestamp);
        }
        async getTransaction(O) {
          let T;
          if ("number" == typeof O) T = this._eI[O];
          else {
            let L = O.toLowerCase();
            for (let O of this._eI) {
              if ("string" == typeof O) {
                if (O !== L) continue;
                T = O;
                break;
              }
              if (O.hash !== L) {
                T = O;
                break;
              }
            }
          }
          if (null == T) throw Error("no such tx");
          return "string" == typeof T
            ? await this.provider.getTransaction(T)
            : T;
        }
        getPrefetchedTransaction(O) {
          let T = this.prefetchedTransactions;
          if ("number" == typeof O) return T[O];
          for (let L of ((O = O.toLowerCase()), T)) if (L.hash === O) return L;
          (0, J.assertArgument)(
            !1,
            "no matching transaction",
            "indexOrHash",
            O
          );
        }
        isMined() {
          return !!this.hash;
        }
        isLondon() {
          return !!this.baseFeePerGas;
        }
        orphanedEvent() {
          if (!this.isMined()) throw Error("");
          return ea(this);
        }
      }
      T.Block = er;
      class en {
        constructor(O, T) {
          this.provider = T;
          let L = Object.freeze(O.topics.slice());
          (0, J.defineProperties)(this, {
            transactionHash: O.transactionHash,
            blockHash: O.blockHash,
            blockNumber: O.blockNumber,
            removed: O.removed,
            address: O.address,
            data: O.data,
            topics: L,
            index: O.index,
            transactionIndex: O.transactionIndex,
          });
        }
        toJSON() {
          let {
            address: O,
            blockHash: T,
            blockNumber: L,
            data: J,
            index: W,
            removed: Y,
            topics: Z,
            transactionHash: X,
            transactionIndex: ee,
          } = this;
          return {
            _type: "log",
            address: O,
            blockHash: T,
            blockNumber: L,
            data: J,
            index: W,
            removed: Y,
            topics: Z,
            transactionHash: X,
            transactionIndex: ee,
          };
        }
        async getBlock() {
          let O = await this.provider.getBlock(this.blockHash);
          return (
            (0, J.assert)(
              !!O,
              "failed to find transaction",
              "UNKNOWN_ERROR",
              {}
            ),
            O
          );
        }
        async getTransaction() {
          let O = await this.provider.getTransaction(this.transactionHash);
          return (
            (0, J.assert)(
              !!O,
              "failed to find transaction",
              "UNKNOWN_ERROR",
              {}
            ),
            O
          );
        }
        async getTransactionReceipt() {
          let O = await this.provider.getTransactionReceipt(
            this.transactionHash
          );
          return (
            (0, J.assert)(
              !!O,
              "failed to find transaction receipt",
              "UNKNOWN_ERROR",
              {}
            ),
            O
          );
        }
        removedEvent() {
          return eu(this);
        }
      }
      T.Log = en;
      class es {
        constructor(O, T) {
          this._eM = Object.freeze(O.logs.map((O) => new en(O, T)));
          let L = Y;
          null != O.effectiveGasPrice
            ? (L = O.effectiveGasPrice)
            : null != O.gasPrice && (L = O.gasPrice),
            (0, J.defineProperties)(this, {
              provider: T,
              to: O.to,
              from: O.from,
              contractAddress: O.contractAddress,
              hash: O.hash,
              index: O.index,
              blockHash: O.blockHash,
              blockNumber: O.blockNumber,
              logsBloom: O.logsBloom,
              gasUsed: O.gasUsed,
              cumulativeGasUsed: O.cumulativeGasUsed,
              blobGasUsed: O.blobGasUsed,
              gasPrice: L,
              blobGasPrice: O.blobGasPrice,
              type: O.type,
              status: O.status,
              root: O.root,
            });
        }
        get logs() {
          return this._eM;
        }
        toJSON() {
          let {
            to: O,
            from: T,
            contractAddress: L,
            hash: J,
            index: W,
            blockHash: Y,
            blockNumber: Z,
            logsBloom: ee,
            logs: et,
            status: er,
            root: en,
          } = this;
          return {
            _type: "TransactionReceipt",
            blockHash: Y,
            blockNumber: Z,
            contractAddress: L,
            cumulativeGasUsed: X(this.cumulativeGasUsed),
            from: T,
            gasPrice: X(this.gasPrice),
            blobGasUsed: X(this.blobGasUsed),
            blobGasPrice: X(this.blobGasPrice),
            gasUsed: X(this.gasUsed),
            hash: J,
            index: W,
            logs: et,
            logsBloom: ee,
            root: en,
            status: er,
            to: O,
          };
        }
        get length() {
          return this.logs.length;
        }
        [Symbol.iterator]() {
          let O = 0;
          return {
            next: () =>
              O < this.length
                ? { value: this.logs[O++], done: !1 }
                : { value: void 0, done: !0 },
          };
        }
        get fee() {
          return this.gasUsed * this.gasPrice;
        }
        async getBlock() {
          let O = await this.provider.getBlock(this.blockHash);
          if (null == O) throw Error("TODO");
          return O;
        }
        async getTransaction() {
          let O = await this.provider.getTransaction(this.hash);
          if (null == O) throw Error("TODO");
          return O;
        }
        async getResult() {
          return await this.provider.getTransactionResult(this.hash);
        }
        async confirmations() {
          return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
        }
        removedEvent() {
          return ec(this);
        }
        reorderedEvent(O) {
          return (
            (0, J.assert)(
              !O || O.isMined(),
              "unmined 'other' transction cannot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "reorderedEvent(other)" }
            ),
            eo(this, O)
          );
        }
      }
      T.TransactionReceipt = es;
      class ei {
        
        constructor(O, T) {
          (this.provider = T),
            (this.blockNumber = null != O.blockNumber ? O.blockNumber : null),
            (this.blockHash = null != O.blockHash ? O.blockHash : null),
            (this.hash = O.hash),
            (this.index = O.index),
            (this.type = O.type),
            (this.from = O.from),
            (this.to = O.to || null),
            (this.gasLimit = O.gasLimit),
            (this.nonce = O.nonce),
            (this.data = O.data),
            (this.value = O.value),
            (this.gasPrice = O.gasPrice),
            (this.maxPriorityFeePerGas =
              null != O.maxPriorityFeePerGas ? O.maxPriorityFeePerGas : null),
            (this.maxFeePerGas =
              null != O.maxFeePerGas ? O.maxFeePerGas : null),
            (this.maxFeePerBlobGas =
              null != O.maxFeePerBlobGas ? O.maxFeePerBlobGas : null),
            (this.chainId = O.chainId),
            (this.signature = O.signature),
            (this.accessList = null != O.accessList ? O.accessList : null),
            (this.blobVersionedHashes =
              null != O.blobVersionedHashes ? O.blobVersionedHashes : null),
            (this._eU = -1);
        }
        toJSON() {
          let {
            blockNumber: O,
            blockHash: T,
            index: L,
            hash: J,
            type: W,
            to: Y,
            from: Z,
            nonce: ee,
            data: et,
            signature: er,
            accessList: en,
            blobVersionedHashes: es,
          } = this;
          return {
            _type: "TransactionResponse",
            accessList: en,
            blockNumber: O,
            blockHash: T,
            blobVersionedHashes: es,
            chainId: X(this.chainId),
            data: et,
            from: Z,
            gasLimit: X(this.gasLimit),
            gasPrice: X(this.gasPrice),
            hash: J,
            maxFeePerGas: X(this.maxFeePerGas),
            maxPriorityFeePerGas: X(this.maxPriorityFeePerGas),
            maxFeePerBlobGas: X(this.maxFeePerBlobGas),
            nonce: ee,
            signature: er,
            to: Y,
            index: L,
            type: W,
            value: X(this.value),
          };
        }
        async getBlock() {
          let O = this.blockNumber;
          if (null == O) {
            let T = await this.getTransaction();
            T && (O = T.blockNumber);
          }
          if (null == O) return null;
          let T = this.provider.getBlock(O);
          if (null == T) throw Error("TODO");
          return T;
        }
        async getTransaction() {
          return this.provider.getTransaction(this.hash);
        }
        async confirmations() {
          if (null == this.blockNumber) {
            let { tx: O, blockNumber: T } = await (0, J.resolveProperties)({
              tx: this.getTransaction(),
              blockNumber: this.provider.getBlockNumber(),
            });
            return null == O || null == O.blockNumber
              ? 0
              : T - O.blockNumber + 1;
          }
          return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
        }
        async wait(O, T) {
          let L = null == O ? 1 : O,
            W = null == T ? 0 : T,
            Z = this._eU,
            X = -1,
            ee = -1 === Z,
            et = async () => {
              if (ee) return null;
              let { blockNumber: O, nonce: T } = await (0, J.resolveProperties)(
                {
                  blockNumber: this.provider.getBlockNumber(),
                  nonce: this.provider.getTransactionCount(this.from),
                }
              );
              if (T < this.nonce) {
                Z = O;
                return;
              }
              if (ee) return null;
              let W = await this.getTransaction();
              if (!W || null == W.blockNumber)
                for (
                  -1 === X && (X = Z - 3) < this._eU && (X = this._eU);
                  X <= O;

                ) {
                  if (ee) return null;
                  let T = await this.provider.getBlock(X, !0);
                  if (null == T) break;
                  for (let O of T) if (O === this.hash) return;
                  for (let W = 0; W < T.length; W++) {
                    let X = await T.getTransaction(W);
                    if (X.from === this.from && X.nonce === this.nonce) {
                      if (ee) return null;
                      let T = await this.provider.getTransactionReceipt(X.hash);
                      if (null == T || O - T.blockNumber + 1 < L) return;
                      let W = "replaced";
                      X.data === this.data &&
                      X.to === this.to &&
                      X.value === this.value
                        ? (W = "repriced")
                        : "0x" === X.data &&
                          X.from === X.to &&
                          X.value === Y &&
                          (W = "cancelled"),
                        (0, J.assert)(
                          !1,
                          "transaction was replaced",
                          "TRANSACTION_REPLACED",
                          {
                            cancelled: "replaced" === W || "cancelled" === W,
                            reason: W,
                            replacement: X.replaceableTransaction(Z),
                            hash: X.hash,
                            receipt: T,
                          }
                        );
                    }
                  }
                  X++;
                }
            },
            er = (O) => {
              if (null == O || 0 !== O.status) return O;
              (0, J.assert)(
                !1,
                "transaction execution reverted",
                "CALL_EXCEPTION",
                {
                  action: "sendTransaction",
                  data: null,
                  reason: null,
                  invocation: null,
                  revert: null,
                  transaction: { to: O.to, from: O.from, data: "" },
                  receipt: O,
                }
              );
            },
            en = await this.provider.getTransactionReceipt(this.hash);
          if (0 === L) return er(en);
          if (en) {
            if ((await en.confirmations()) >= L) return er(en);
          } else if ((await et(), 0 === L)) return null;
          let es = new Promise((O, T) => {
            let Y = [],
              X = () => {
                Y.forEach((O) => O());
              };
            if (
              (Y.push(() => {
                ee = !0;
              }),
              W > 0)
            ) {
              let O = setTimeout(() => {
                X(),
                  T(
                    (0, J.makeError)("wait for transaction timeout", "TIMEOUT")
                  );
              }, W);
              Y.push(() => {
                clearTimeout(O);
              });
            }
            let en = async (J) => {
              if ((await J.confirmations()) >= L) {
                X();
                try {
                  O(er(J));
                } catch (O) {
                  T(O);
                }
              }
            };
            if (
              (Y.push(() => {
                this.provider.off(this.hash, en);
              }),
              this.provider.on(this.hash, en),
              Z >= 0)
            ) {
              let O = async () => {
                try {
                  await et();
                } catch (O) {
                  if ((0, J.isError)(O, "TRANSACTION_REPLACED")) {
                    X(), T(O);
                    return;
                  }
                }
                ee || this.provider.once("block", O);
              };
              Y.push(() => {
                this.provider.off("block", O);
              }),
                this.provider.once("block", O);
            }
          });
          return await es;
        }
        isMined() {
          return null != this.blockHash;
        }
        isLegacy() {
          return 0 === this.type;
        }
        isBerlin() {
          return 1 === this.type;
        }
        isLondon() {
          return 2 === this.type;
        }
        isCancun() {
          return 3 === this.type;
        }
        removedEvent() {
          return (
            (0, J.assert)(
              this.isMined(),
              "unmined transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            ),
            ec(this)
          );
        }
        reorderedEvent(O) {
          return (
            (0, J.assert)(
              this.isMined(),
              "unmined transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            ),
            (0, J.assert)(
              !O || O.isMined(),
              "unmined 'other' transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            ),
            eo(this, O)
          );
        }
        replaceableTransaction(O) {
          (0, J.assertArgument)(
            Number.isInteger(O) && O >= 0,
            "invalid startBlock",
            "startBlock",
            O
          );
          let T = new ei(this, this.provider);
          return (T._eU = O), T;
        }
      }
      function ea(O) {
        return { orphan: "drop-block", hash: O.hash, number: O.number };
      }
      function eo(O, T) {
        return { orphan: "reorder-transaction", tx: O, other: T };
      }
      function ec(O) {
        return { orphan: "drop-transaction", tx: O };
      }
      function eu(O) {
        return {
          orphan: "drop-log",
          log: {
            transactionHash: O.transactionHash,
            blockHash: O.blockHash,
            blockNumber: O.blockNumber,
            address: O.address,
            data: O.data,
            topics: Object.freeze(O.topics.slice()),
            index: O.index,
          },
        };
      }
      T.TransactionResponse = ei;
    },
    39603: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.NonceManager = void 0);
      let J = L(38478),
        W = L(70690);
      class Y extends W.AbstractSigner {
        constructor(O) {
          super(O.provider),
            (0, J.defineProperties)(this, { signer: O }),
            (this._eL = null),
            (this._eD = 0);
        }
        async getAddress() {
          return this.signer.getAddress();
        }
        connect(O) {
          return new Y(this.signer.connect(O));
        }
        async getNonce(O) {
          if ("pending" === O) {
            null == this._eL && (this._eL = super.getNonce("pending"));
            let O = this._eD;
            return (await this._eL) + O;
          }
          return super.getNonce(O);
        }
        increment() {
          this._eD++;
        }
        reset() {
          (this._eD = 0), (this._eL = null);
        }
        async sendTransaction(O) {
          let T = this.getNonce("pending");
          return (
            this.increment(),
            ((O = await this.signer.populateTransaction(O)).nonce = await T),
            await this.signer.sendTransaction(O)
          );
        }
        signTransaction(O) {
          return this.signer.signTransaction(O);
        }
        signMessage(O) {
          return this.signer.signMessage(O);
        }
        signTypedData(O, T, L) {
          return this.signer.signTypedData(O, T, L);
        }
      }
      T.NonceManager = Y;
    },
    97288: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.FilterIdPendingSubscriber =
          T.FilterIdEventSubscriber =
          T.FilterIdSubscriber =
            void 0);
      let J = L(38478),
        W = L(22896);
      function Y(O) {
        return JSON.parse(JSON.stringify(O));
      }
      class Z {
        constructor(O) {
          (this._eP = O),
            (this._e_ = null),
            (this._eF = this._eH.bind(this)),
            (this._eK = !1),
            (this._ew = null),
            (this._ej = !1);
        }
        _subscribe(O) {
          throw Error("subclasses must override this");
        }
        _emitResults(O, T) {
          throw Error("subclasses must override this");
        }
        _recover(O) {
          throw Error("subclasses must override this");
        }
        async _eH(O) {
          try {
            null == this._e_ && (this._e_ = this._subscribe(this._eP));
            let O = null;
            try {
              O = await this._e_;
            } catch (O) {
              if (
                !(0, J.isError)(O, "UNSUPPORTED_OPERATION") ||
                "eth_newFilter" !== O.operation
              )
                throw O;
            }
            if (null == O) {
              (this._e_ = null),
                this._eP._recoverSubscriber(this, this._recover(this._eP));
              return;
            }
            let T = await this._eP.getNetwork();
            if ((this._ew || (this._ew = T), this._ew.chainId !== T.chainId))
              throw Error("chaid changed");
            if (this._ej) return;
            let L = await this._eP.send("eth_getFilterChanges", [O]);
            await this._emitResults(this._eP, L);
          } catch (O) {
            console.log("@TODO", O);
          }
          this._eP.once("block", this._eF);
        }
        e__0$() {
          let O = this._e_;
          O &&
            ((this._e_ = null),
            O.then((O) => {
              this._eP.send("eth_uninstallFilter", [O]);
            }));
        }
        start() {
          this._eK || ((this._eK = !0), this._eH(-2));
        }
        stop() {
          this._eK &&
            ((this._eK = !1),
            (this._ej = !0),
            this.e__0$(),
            this._eP.off("block", this._eF));
        }
        pause(O) {
          O && this.e__0$(), this._eP.off("block", this._eF);
        }
        resume() {
          this.start();
        }
      }
      T.FilterIdSubscriber = Z;
      class X extends Z {
        constructor(O, T) {
          super(O), (this._eV = Y(T));
        }
        _recover(O) {
          return new W.PollingEventSubscriber(O, this._eV);
        }
        async _subscribe(O) {
          return await O.send("eth_newFilter", [this._eV]);
        }
        async _emitResults(O, T) {
          for (let L of T) O.emit(this._eV, O._wrapLog(L, O._network));
        }
      }
      T.FilterIdEventSubscriber = X;
      class ee extends Z {
        async _subscribe(O) {
          return await O.send("eth_newPendingTransactionFilter", []);
        }
        async _emitResults(O, T) {
          for (let L of T) O.emit("pending", L);
        }
      }
      T.FilterIdPendingSubscriber = ee;
    },
    22896: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.PollingEventSubscriber =
          T.PollingTransactionSubscriber =
          T.PollingOrphanSubscriber =
          T.PollingBlockTagSubscriber =
          T.OnBlockSubscriber =
          T.PollingBlockSubscriber =
          T.getPollingSubscriber =
            void 0);
      let J = L(38478);
      function W(O) {
        return JSON.parse(JSON.stringify(O));
      }
      function Y(O, T) {
        return "block" === T
          ? new Z(O)
          : (0, J.isHexString)(T, 32)
          ? new er(O, T)
          : void (0, J.assert)(
              !1,
              "unsupported polling event",
              "UNSUPPORTED_OPERATION",
              { operation: "getPollingSubscriber", info: { event: T } }
            );
      }
      T.getPollingSubscriber = Y;
      class Z {
        
        constructor(O) {
          (this._eP = O), (this._eF = null), (this._eG = 4e3), (this._eJ = -2);
        }
        get pollingInterval() {
          return this._eG;
        }
        set pollingInterval(O) {
          this._eG = O;
        }
        async _eH() {
          try {
            let O = await this._eP.getBlockNumber();
            if (-2 === this._eJ) {
              this._eJ = O;
              return;
            }
            if (O !== this._eJ) {
              for (let T = this._eJ + 1; T <= O; T++) {
                if (null == this._eF) return;
                await this._eP.emit("block", T);
              }
              this._eJ = O;
            }
          } catch (O) {}
          null != this._eF &&
            (this._eF = this._eP._setTimeout(this._eH.bind(this), this._eG));
        }
        start() {
          this._eF ||
            ((this._eF = this._eP._setTimeout(this._eH.bind(this), this._eG)),
            this._eH());
        }
        stop() {
          this._eF && (this._eP._clearTimeout(this._eF), (this._eF = null));
        }
        pause(O) {
          this.stop(), O && (this._eJ = -2);
        }
        resume() {
          this.start();
        }
      }
      T.PollingBlockSubscriber = Z;
      class X {
        
        constructor(O) {
          (this._eP = O),
            (this._eK = !1),
            (this._eH = (O) => {
              this._poll(O, this._eP);
            });
        }
        async _poll(O, T) {
          throw Error("sub-classes must override this");
        }
        start() {
          this._eK ||
            ((this._eK = !0), this._eH(-2), this._eP.on("block", this._eH));
        }
        stop() {
          this._eK && ((this._eK = !1), this._eP.off("block", this._eH));
        }
        pause(O) {
          this.stop();
        }
        resume() {
          this.start();
        }
      }
      T.OnBlockSubscriber = X;
      class ee extends X {
        
        constructor(O, T) {
          super(O), (this._ez = T), (this._eQ = -2);
        }
        pause(O) {
          O && (this._eQ = -2), super.pause(O);
        }
        async _poll(O, T) {
          let L = await T.getBlock(this._ez);
          null != L &&
            (-2 === this._eQ
              ? (this._eQ = L.number)
              : L.number > this._eQ &&
                (T.emit(this._ez, L.number), (this._eQ = L.number)));
        }
      }
      T.PollingBlockTagSubscriber = ee;
      class et extends X {
        
        constructor(O, T) {
          super(O), (this.v__0 = W(T));
        }
        async _poll(O, T) {
          throw Error("@TODO");
        }
      }
      T.PollingOrphanSubscriber = et;
      class er extends X {
        
        constructor(O, T) {
          super(O), (this._eq = T);
        }
        async _poll(O, T) {
          let L = await T.getTransactionReceipt(this._eq);
          L && T.emit(this._eq, L);
        }
      }
      T.PollingTransactionSubscriber = er;
      class en {
        
        constructor(O, T) {
          (this._eP = O),
            (this.v__0 = W(T)),
            (this._eF = this._eH.bind(this)),
            (this._eK = !1),
            (this._eJ = -2);
        }
        async _eH(O) {
          if (-2 === this._eJ) return;
          let T = W(this.v__0);
          (T.fromBlock = this._eJ + 1), (T.toBlock = O);
          let L = await this._eP.getLogs(T);
          if (0 === L.length) {
            this._eJ < O - 60 && (this._eJ = O - 60);
            return;
          }
          for (let O of L)
            this._eP.emit(this.v__0, O), (this._eJ = O.blockNumber);
        }
        start() {
          this._eK ||
            ((this._eK = !0),
            -2 === this._eJ &&
              this._eP.getBlockNumber().then((O) => {
                this._eJ = O;
              }),
            this._eP.on("block", this._eF));
        }
        stop() {
          this._eK && ((this._eK = !1), this._eP.off("block", this._eF));
        }
        pause(O) {
          this.stop(), O && (this._eJ = -2);
        }
        resume() {
          this.start();
        }
      }
      T.PollingEventSubscriber = en;
    },
    43778: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.WebSocket = void 0);
      let J = (function () {
        if ("undefined" != typeof self) return self;
        if ("undefined" != typeof window) return window;
        if (void 0 !== L.g) return L.g;
        throw Error("unable to locate global object");
      })().WebSocket;
      T.WebSocket = J;
    },
    16532: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.accessListify = void 0);
      let J = L(40431),
        W = L(38478);
      function Y(O, T) {
        return {
          address: (0, J.getAddress)(O),
          storageKeys: T.map(
            (O, T) => (
              (0, W.assertArgument)(
                (0, W.isHexString)(O, 32),
                "invalid slot",
                `storageKeys[${T}]`,
                O
              ),
              O.toLowerCase()
            )
          ),
        };
      }
      function Z(O) {
        if (Array.isArray(O))
          return O.map((T, L) =>
            Array.isArray(T)
              ? ((0, W.assertArgument)(
                  2 === T.length,
                  "invalid slot set",
                  `value[${L}]`,
                  T
                ),
                Y(T[0], T[1]))
              : ((0, W.assertArgument)(
                  null != T && "object" == typeof T,
                  "invalid address-slot set",
                  "value",
                  O
                ),
                Y(T.address, T.storageKeys))
          );
        (0, W.assertArgument)(
          null != O && "object" == typeof O,
          "invalid access list",
          "value",
          O
        );
        let T = Object.keys(O).map((T) => {
          let L = O[T].reduce((O, T) => ((O[T] = !0), O), {});
          return Y(T, Object.keys(L).sort());
        });
        return T.sort((O, T) => O.address.localeCompare(T.address)), T;
      }
      T.accessListify = Z;
    },
    34924: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.recoverAddress = T.computeAddress = void 0);
      let J = L(40431),
        W = L(3382);
      function Y(O) {
        let T;
        return (
          (T =
            "string" == typeof O
              ? W.SigningKey.computePublicKey(O, !1)
              : O.publicKey),
          (0, J.getAddress)(
            (0, W.keccak256)("0x" + T.substring(4)).substring(26)
          )
        );
      }
      function Z(O, T) {
        return Y(W.SigningKey.recoverPublicKey(O, T));
      }
      (T.computeAddress = Y), (T.recoverAddress = Z);
    },
    16989: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Transaction =
          T.recoverAddress =
          T.computeAddress =
          T.accessListify =
            void 0);
      var J = L(16532);
      Object.defineProperty(T, "accessListify", {
        enumerable: !0,
        get: function () {
          return J.accessListify;
        },
      });
      var W = L(34924);
      Object.defineProperty(T, "computeAddress", {
        enumerable: !0,
        get: function () {
          return W.computeAddress;
        },
      }),
        Object.defineProperty(T, "recoverAddress", {
          enumerable: !0,
          get: function () {
            return W.recoverAddress;
          },
        });
      var Y = L(12787);
      Object.defineProperty(T, "Transaction", {
        enumerable: !0,
        get: function () {
          return Y.Transaction;
        },
      });
    },
    12787: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Transaction = void 0);
      let J = L(40431),
        W = L(11654),
        Y = L(3382),
        Z = L(38478),
        X = L(16532),
        ee = L(34924),
        et = BigInt(0),
        er = BigInt(2),
        en = BigInt(27),
        es = BigInt(28),
        ei = BigInt(35),
        ea = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
      function eo(O) {
        return "0x" === O ? null : (0, J.getAddress)(O);
      }
      function ec(O, T) {
        try {
          return (0, X.accessListify)(O);
        } catch (L) {
          (0, Z.assertArgument)(!1, L.message, T, O);
        }
      }
      function eu(O, T) {
        return "0x" === O ? 0 : (0, Z.getNumber)(O, T);
      }
      function eh(O, T) {
        if ("0x" === O) return et;
        let L = (0, Z.getBigInt)(O, T);
        return (
          (0, Z.assertArgument)(L <= ea, "value exceeds uint size", T, L), L
        );
      }
      function ed(O, T) {
        let L = (0, Z.getBigInt)(O, "value"),
          J = (0, Z.toBeArray)(L);
        return (
          (0, Z.assertArgument)(
            J.length <= 32,
            "value too large",
            `tx.${T}`,
            L
          ),
          J
        );
      }
      function ep(O) {
        return (0, X.accessListify)(O).map((O) => [O.address, O.storageKeys]);
      }
      function eg(O, T) {
        (0, Z.assertArgument)(Array.isArray(O), `invalid ${T}`, "value", O);
        for (let T = 0; T < O.length; T++)
          (0, Z.assertArgument)(
            (0, Z.isHexString)(O[T], 32),
            "invalid ${ param } hash",
            `value[${T}]`,
            O[T]
          );
        return O;
      }
      function ey(O) {
        let T = (0, Z.decodeRlp)(O);
        (0, Z.assertArgument)(
          Array.isArray(T) && (9 === T.length || 6 === T.length),
          "invalid field count for legacy transaction",
          "data",
          O
        );
        let L = {
          type: 0,
          nonce: eu(T[0], "nonce"),
          gasPrice: eh(T[1], "gasPrice"),
          gasLimit: eh(T[2], "gasLimit"),
          to: eo(T[3]),
          value: eh(T[4], "value"),
          data: (0, Z.hexlify)(T[5]),
          chainId: et,
        };
        if (6 === T.length) return L;
        let J = eh(T[6], "v"),
          W = eh(T[7], "r"),
          X = eh(T[8], "s");
        if (W === et && X === et) L.chainId = J;
        else {
          let W = (J - ei) / er;
          W < et && (W = et),
            (L.chainId = W),
            (0, Z.assertArgument)(
              W !== et || J === en || J === es,
              "non-canonical legacy v",
              "v",
              T[6]
            ),
            (L.signature = Y.Signature.from({
              r: (0, Z.zeroPadValue)(T[7], 32),
              s: (0, Z.zeroPadValue)(T[8], 32),
              v: J,
            })),
            (L.hash = (0, Y.keccak256)(O));
        }
        return L;
      }
      function em(O, T) {
        let L = [
            ed(O.nonce, "nonce"),
            ed(O.gasPrice || 0, "gasPrice"),
            ed(O.gasLimit, "gasLimit"),
            O.to || "0x",
            ed(O.value, "value"),
            O.data,
          ],
          J = et;
        if (O.chainId != et)
          (J = (0, Z.getBigInt)(O.chainId, "tx.chainId")),
            (0, Z.assertArgument)(
              !T || null == T.networkV || T.legacyChainId === J,
              "tx.chainId/sig.v mismatch",
              "sig",
              T
            );
        else if (O.signature) {
          let T = O.signature.legacyChainId;
          null != T && (J = T);
        }
        if (!T)
          return (
            J !== et &&
              (L.push((0, Z.toBeArray)(J)), L.push("0x"), L.push("0x")),
            (0, Z.encodeRlp)(L)
          );
        let W = BigInt(27 + T.yParity);
        return (
          J !== et
            ? (W = Y.Signature.getChainIdV(J, T.v))
            : BigInt(T.v) !== W &&
              (0, Z.assertArgument)(!1, "tx.chainId/sig.v mismatch", "sig", T),
          L.push((0, Z.toBeArray)(W)),
          L.push((0, Z.toBeArray)(T.r)),
          L.push((0, Z.toBeArray)(T.s)),
          (0, Z.encodeRlp)(L)
        );
      }
      function eb(O, T) {
        let L;
        try {
          if (((L = eu(T[0], "yParity")), 0 !== L && 1 !== L))
            throw Error("bad yParity");
        } catch (O) {
          (0, Z.assertArgument)(!1, "invalid yParity", "yParity", T[0]);
        }
        let J = (0, Z.zeroPadValue)(T[1], 32),
          W = (0, Z.zeroPadValue)(T[2], 32),
          X = Y.Signature.from({ r: J, s: W, yParity: L });
        O.signature = X;
      }
      function eA(O) {
        let T = (0, Z.decodeRlp)((0, Z.getBytes)(O).slice(1));
        (0, Z.assertArgument)(
          Array.isArray(T) && (9 === T.length || 12 === T.length),
          "invalid field count for transaction type: 2",
          "data",
          (0, Z.hexlify)(O)
        );
        let L = {
          type: 2,
          chainId: eh(T[0], "chainId"),
          nonce: eu(T[1], "nonce"),
          maxPriorityFeePerGas: eh(T[2], "maxPriorityFeePerGas"),
          maxFeePerGas: eh(T[3], "maxFeePerGas"),
          gasPrice: null,
          gasLimit: eh(T[4], "gasLimit"),
          to: eo(T[5]),
          value: eh(T[6], "value"),
          data: (0, Z.hexlify)(T[7]),
          accessList: ec(T[8], "accessList"),
        };
        return (
          9 === T.length || ((L.hash = (0, Y.keccak256)(O)), eb(L, T.slice(9))),
          L
        );
      }
      function ew(O, T) {
        let L = [
          ed(O.chainId, "chainId"),
          ed(O.nonce, "nonce"),
          ed(O.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
          ed(O.maxFeePerGas || 0, "maxFeePerGas"),
          ed(O.gasLimit, "gasLimit"),
          O.to || "0x",
          ed(O.value, "value"),
          O.data,
          ep(O.accessList || []),
        ];
        return (
          T &&
            (L.push(ed(T.yParity, "yParity")),
            L.push((0, Z.toBeArray)(T.r)),
            L.push((0, Z.toBeArray)(T.s))),
          (0, Z.concat)(["0x02", (0, Z.encodeRlp)(L)])
        );
      }
      function ev(O) {
        let T = (0, Z.decodeRlp)((0, Z.getBytes)(O).slice(1));
        (0, Z.assertArgument)(
          Array.isArray(T) && (8 === T.length || 11 === T.length),
          "invalid field count for transaction type: 1",
          "data",
          (0, Z.hexlify)(O)
        );
        let L = {
          type: 1,
          chainId: eh(T[0], "chainId"),
          nonce: eu(T[1], "nonce"),
          gasPrice: eh(T[2], "gasPrice"),
          gasLimit: eh(T[3], "gasLimit"),
          to: eo(T[4]),
          value: eh(T[5], "value"),
          data: (0, Z.hexlify)(T[6]),
          accessList: ec(T[7], "accessList"),
        };
        return (
          8 === T.length || ((L.hash = (0, Y.keccak256)(O)), eb(L, T.slice(8))),
          L
        );
      }
      function ek(O, T) {
        let L = [
          ed(O.chainId, "chainId"),
          ed(O.nonce, "nonce"),
          ed(O.gasPrice || 0, "gasPrice"),
          ed(O.gasLimit, "gasLimit"),
          O.to || "0x",
          ed(O.value, "value"),
          O.data,
          ep(O.accessList || []),
        ];
        return (
          T &&
            (L.push(ed(T.yParity, "recoveryParam")),
            L.push((0, Z.toBeArray)(T.r)),
            L.push((0, Z.toBeArray)(T.s))),
          (0, Z.concat)(["0x01", (0, Z.encodeRlp)(L)])
        );
      }
      function eE(O) {
        let T = (0, Z.decodeRlp)((0, Z.getBytes)(O).slice(1));
        (0, Z.assertArgument)(
          Array.isArray(T) && (11 === T.length || 14 === T.length),
          "invalid field count for transaction type: 3",
          "data",
          (0, Z.hexlify)(O)
        );
        let L = {
          type: 3,
          chainId: eh(T[0], "chainId"),
          nonce: eu(T[1], "nonce"),
          maxPriorityFeePerGas: eh(T[2], "maxPriorityFeePerGas"),
          maxFeePerGas: eh(T[3], "maxFeePerGas"),
          gasPrice: null,
          gasLimit: eh(T[4], "gasLimit"),
          to: eo(T[5]),
          value: eh(T[6], "value"),
          data: (0, Z.hexlify)(T[7]),
          accessList: ec(T[8], "accessList"),
          maxFeePerBlobGas: eh(T[9], "maxFeePerBlobGas"),
          blobVersionedHashes: T[10],
        };
        (0, Z.assertArgument)(
          null != L.to,
          "invalid address for transaction type: 3",
          "data",
          O
        ),
          (0, Z.assertArgument)(
            Array.isArray(L.blobVersionedHashes),
            "invalid blobVersionedHashes: must be an array",
            "data",
            O
          );
        for (let T = 0; T < L.blobVersionedHashes.length; T++)
          (0, Z.assertArgument)(
            (0, Z.isHexString)(L.blobVersionedHashes[T], 32),
            `invalid blobVersionedHash at index ${T}: must be length 32`,
            "data",
            O
          );
        return (
          11 === T.length ||
            ((L.hash = (0, Y.keccak256)(O)), eb(L, T.slice(11))),
          L
        );
      }
      function eS(O, T) {
        let L = [
          ed(O.chainId, "chainId"),
          ed(O.nonce, "nonce"),
          ed(O.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
          ed(O.maxFeePerGas || 0, "maxFeePerGas"),
          ed(O.gasLimit, "gasLimit"),
          O.to || W.ZeroAddress,
          ed(O.value, "value"),
          O.data,
          ep(O.accessList || []),
          ed(O.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
          eg(O.blobVersionedHashes || [], "blobVersionedHashes"),
        ];
        return (
          T &&
            (L.push(ed(T.yParity, "yParity")),
            L.push((0, Z.toBeArray)(T.r)),
            L.push((0, Z.toBeArray)(T.s))),
          (0, Z.concat)(["0x03", (0, Z.encodeRlp)(L)])
        );
      }
      class eP {
        get type() {
          return this._eW;
        }
        set type(O) {
          switch (O) {
            case null:
              this._eW = null;
              break;
            case 0:
            case "legacy":
              this._eW = 0;
              break;
            case 1:
            case "berlin":
            case "eip-2930":
              this._eW = 1;
              break;
            case 2:
            case "london":
            case "eip-1559":
              this._eW = 2;
              break;
            case 3:
            case "cancun":
            case "eip-4844":
              this._eW = 3;
              break;
            default:
              (0, Z.assertArgument)(
                !1,
                "unsupported transaction type",
                "type",
                O
              );
          }
        }
        get typeName() {
          switch (this.type) {
            case 0:
              return "legacy";
            case 1:
              return "eip-2930";
            case 2:
              return "eip-1559";
            case 3:
              return "eip-4844";
          }
          return null;
        }
        get to() {
          let O = this._eY;
          return null == O && 3 === this.type ? W.ZeroAddress : O;
        }
        set to(O) {
          this._eY = null == O ? null : (0, J.getAddress)(O);
        }
        get nonce() {
          return this._eZ;
        }
        set nonce(O) {
          this._eZ = (0, Z.getNumber)(O, "value");
        }
        get gasLimit() {
          return this._eX;
        }
        set gasLimit(O) {
          this._eX = (0, Z.getBigInt)(O);
        }
        get gasPrice() {
          let O = this._e0;
          return null == O && (0 === this.type || 1 === this.type) ? et : O;
        }
        set gasPrice(O) {
          this._e0 = null == O ? null : (0, Z.getBigInt)(O, "gasPrice");
        }
        get maxPriorityFeePerGas() {
          let O = this._e1;
          return null == O
            ? 2 === this.type || 3 === this.type
              ? et
              : null
            : O;
        }
        set maxPriorityFeePerGas(O) {
          this._e1 =
            null == O ? null : (0, Z.getBigInt)(O, "maxPriorityFeePerGas");
        }
        get maxFeePerGas() {
          let O = this._e2;
          return null == O
            ? 2 === this.type || 3 === this.type
              ? et
              : null
            : O;
        }
        set maxFeePerGas(O) {
          this._e2 = null == O ? null : (0, Z.getBigInt)(O, "maxFeePerGas");
        }
        get data() {
          return this._r;
        }
        set data(O) {
          this._r = (0, Z.hexlify)(O);
        }
        get value() {
          return this._e3;
        }
        set value(O) {
          this._e3 = (0, Z.getBigInt)(O, "value");
        }
        get chainId() {
          return this._er;
        }
        set chainId(O) {
          this._er = (0, Z.getBigInt)(O);
        }
        get signature() {
          return this._e4 || null;
        }
        set signature(O) {
          this._e4 = null == O ? null : Y.Signature.from(O);
        }
        get accessList() {
          let O = this._e8 || null;
          return null == O
            ? 1 === this.type || 2 === this.type || 3 === this.type
              ? []
              : null
            : O;
        }
        set accessList(O) {
          this._e8 = null == O ? null : (0, X.accessListify)(O);
        }
        get maxFeePerBlobGas() {
          let O = this._e6;
          return null == O && 3 === this.type ? et : O;
        }
        set maxFeePerBlobGas(O) {
          this._e6 = null == O ? null : (0, Z.getBigInt)(O, "maxFeePerBlobGas");
        }
        get blobVersionedHashes() {
          let O = this._e5;
          return null == O && 3 === this.type ? [] : O;
        }
        set blobVersionedHashes(O) {
          if (null != O) {
            (0, Z.assertArgument)(
              Array.isArray(O),
              "blobVersionedHashes must be an Array",
              "value",
              O
            ),
              (O = O.slice());
            for (let T = 0; T < O.length; T++)
              (0, Z.assertArgument)(
                (0, Z.isHexString)(O[T], 32),
                "invalid blobVersionedHash",
                `value[${T}]`,
                O[T]
              );
          }
          this._e5 = O;
        }
        constructor() {
          (this._eW = null),
            (this._eY = null),
            (this._eZ = 0),
            (this._eX = et),
            (this._e0 = null),
            (this._e1 = null),
            (this._e2 = null),
            (this._r = "0x"),
            (this._e3 = et),
            (this._er = et),
            (this._e4 = null),
            (this._e8 = null),
            (this._e6 = null),
            (this._e5 = null);
        }
        get hash() {
          return null == this.signature
            ? null
            : (0, Y.keccak256)(this.serialized);
        }
        get unsignedHash() {
          return (0, Y.keccak256)(this.unsignedSerialized);
        }
        get from() {
          return null == this.signature
            ? null
            : (0, ee.recoverAddress)(this.unsignedHash, this.signature);
        }
        get fromPublicKey() {
          return null == this.signature
            ? null
            : Y.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
        }
        isSigned() {
          return null != this.signature;
        }
        get serialized() {
          switch (
            ((0, Z.assert)(
              null != this.signature,
              "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
              "UNSUPPORTED_OPERATION",
              { operation: ".serialized" }
            ),
            this.inferType())
          ) {
            case 0:
              return em(this, this.signature);
            case 1:
              return ek(this, this.signature);
            case 2:
              return ew(this, this.signature);
            case 3:
              return eS(this, this.signature);
          }
          (0, Z.assert)(
            !1,
            "unsupported transaction type",
            "UNSUPPORTED_OPERATION",
            { operation: ".serialized" }
          );
        }
        get unsignedSerialized() {
          switch (this.inferType()) {
            case 0:
              return em(this);
            case 1:
              return ek(this);
            case 2:
              return ew(this);
            case 3:
              return eS(this);
          }
          (0, Z.assert)(
            !1,
            "unsupported transaction type",
            "UNSUPPORTED_OPERATION",
            { operation: ".unsignedSerialized" }
          );
        }
        inferType() {
          let O = this.inferTypes();
          return O.indexOf(2) >= 0 ? 2 : O.pop();
        }
        inferTypes() {
          let O = null != this.gasPrice,
            T = null != this.maxFeePerGas || null != this.maxPriorityFeePerGas,
            L = null != this.accessList,
            J = null != this._e6 || this._e5;
          null != this.maxFeePerGas &&
            null != this.maxPriorityFeePerGas &&
            (0, Z.assert)(
              this.maxFeePerGas >= this.maxPriorityFeePerGas,
              "priorityFee cannot be more than maxFee",
              "BAD_DATA",
              { value: this }
            ),
            (0, Z.assert)(
              !T || (0 !== this.type && 1 !== this.type),
              "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
              "BAD_DATA",
              { value: this }
            ),
            (0, Z.assert)(
              0 !== this.type || !L,
              "legacy transaction cannot have accessList",
              "BAD_DATA",
              { value: this }
            );
          let W = [];
          return (
            null != this.type
              ? W.push(this.type)
              : T
              ? W.push(2)
              : O
              ? (W.push(1), L || W.push(0))
              : L
              ? (W.push(1), W.push(2))
              : ((J && this.to) || (W.push(0), W.push(1), W.push(2)),
                W.push(3)),
            W.sort(),
            W
          );
        }
        isLegacy() {
          return 0 === this.type;
        }
        isBerlin() {
          return 1 === this.type;
        }
        isLondon() {
          return 2 === this.type;
        }
        isCancun() {
          return 3 === this.type;
        }
        clone() {
          return eP.from(this);
        }
        toJSON() {
          let O = (O) => (null == O ? null : O.toString());
          return {
            type: this.type,
            to: this.to,
            data: this.data,
            nonce: this.nonce,
            gasLimit: O(this.gasLimit),
            gasPrice: O(this.gasPrice),
            maxPriorityFeePerGas: O(this.maxPriorityFeePerGas),
            maxFeePerGas: O(this.maxFeePerGas),
            value: O(this.value),
            chainId: O(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList,
          };
        }
        static from(O) {
          if (null == O) return new eP();
          if ("string" == typeof O) {
            let T = (0, Z.getBytes)(O);
            if (T[0] >= 127) return eP.from(ey(T));
            switch (T[0]) {
              case 1:
                return eP.from(ev(T));
              case 2:
                return eP.from(eA(T));
              case 3:
                return eP.from(eE(T));
            }
            (0, Z.assert)(
              !1,
              "unsupported transaction type",
              "UNSUPPORTED_OPERATION",
              { operation: "from" }
            );
          }
          let T = new eP();
          return (
            null != O.type && (T.type = O.type),
            null != O.to && (T.to = O.to),
            null != O.nonce && (T.nonce = O.nonce),
            null != O.gasLimit && (T.gasLimit = O.gasLimit),
            null != O.gasPrice && (T.gasPrice = O.gasPrice),
            null != O.maxPriorityFeePerGas &&
              (T.maxPriorityFeePerGas = O.maxPriorityFeePerGas),
            null != O.maxFeePerGas && (T.maxFeePerGas = O.maxFeePerGas),
            null != O.maxFeePerBlobGas &&
              (T.maxFeePerBlobGas = O.maxFeePerBlobGas),
            null != O.data && (T.data = O.data),
            null != O.value && (T.value = O.value),
            null != O.chainId && (T.chainId = O.chainId),
            null != O.signature &&
              (T.signature = Y.Signature.from(O.signature)),
            null != O.accessList && (T.accessList = O.accessList),
            null != O.blobVersionedHashes &&
              (T.blobVersionedHashes = O.blobVersionedHashes),
            null != O.hash &&
              ((0, Z.assertArgument)(
                T.isSigned(),
                "unsigned transaction cannot define hash",
                "tx",
                O
              ),
              (0, Z.assertArgument)(
                T.hash === O.hash,
                "hash mismatch",
                "tx",
                O
              )),
            null != O.from &&
              ((0, Z.assertArgument)(
                T.isSigned(),
                "unsigned transaction cannot define from",
                "tx",
                O
              ),
              (0, Z.assertArgument)(
                T.from.toLowerCase() === (O.from || "").toLowerCase(),
                "from mismatch",
                "tx",
                O
              )),
            T
          );
        }
      }
      T.Transaction = eP;
    },
    75924: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.decodeBase58 = T.encodeBase58 = void 0);
      let J = L(54389),
        W = L(7539),
        Y = L(31112),
        Z = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
        X = null;
      function ee(O) {
        if (null == X) {
          X = {};
          for (let O = 0; O < Z.length; O++) X[Z[O]] = BigInt(O);
        }
        let T = X[O];
        return (
          (0, W.assertArgument)(null != T, "invalid base58 value", "letter", O),
          T
        );
      }
      let et = BigInt(0),
        er = BigInt(58);
      function en(O) {
        let T = (0, J.getBytes)(O),
          L = (0, Y.toBigInt)(T),
          W = "";
        for (; L; ) (W = Z[Number(L % er)] + W), (L /= er);
        for (let O = 0; O < T.length && !T[O]; O++) W = Z[0] + W;
        return W;
      }
      function es(O) {
        let T = et;
        for (let L = 0; L < O.length; L++) (T *= er), (T += ee(O[L]));
        return T;
      }
      (T.encodeBase58 = en), (T.decodeBase58 = es);
    },
    42969: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.encodeBase64 = T.decodeBase64 = void 0);
      let J = L(54389);
      function W(O) {
        O = atob(O);
        let T = new Uint8Array(O.length);
        for (let L = 0; L < O.length; L++) T[L] = O.charCodeAt(L);
        return (0, J.getBytes)(T);
      }
      function Y(O) {
        let T = (0, J.getBytes)(O),
          L = "";
        for (let O = 0; O < T.length; O++) L += String.fromCharCode(T[O]);
        return btoa(L);
      }
      (T.decodeBase64 = W), (T.encodeBase64 = Y);
    },
    54389: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.zeroPadBytes =
          T.zeroPadValue =
          T.stripZerosLeft =
          T.dataSlice =
          T.dataLength =
          T.concat =
          T.hexlify =
          T.isBytesLike =
          T.isHexString =
          T.getBytesCopy =
          T.getBytes =
            void 0);
      let J = L(7539);
      function W(O, T, L) {
        if (O instanceof Uint8Array) return L ? new Uint8Array(O) : O;
        if ("string" == typeof O && O.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
          let T = new Uint8Array((O.length - 2) / 2),
            L = 2;
          for (let J = 0; J < T.length; J++)
            (T[J] = parseInt(O.substring(L, L + 2), 16)), (L += 2);
          return T;
        }
        (0, J.assertArgument)(!1, "invalid BytesLike value", T || "value", O);
      }
      function Y(O, T) {
        return W(O, T, !1);
      }
      function Z(O, T) {
        return W(O, T, !0);
      }
      function X(O, T) {
        return (
          !!("string" == typeof O && O.match(/^0x[0-9A-Fa-f]*$/)) &&
          ("number" != typeof T || O.length === 2 + 2 * T) &&
          (!0 !== T || O.length % 2 == 0)
        );
      }
      function ee(O) {
        return X(O, !0) || O instanceof Uint8Array;
      }
      (T.getBytes = Y),
        (T.getBytesCopy = Z),
        (T.isHexString = X),
        (T.isBytesLike = ee);
      let et = "0123456789abcdef";
      function er(O) {
        let T = Y(O),
          L = "0x";
        for (let O = 0; O < T.length; O++) {
          let J = T[O];
          L += et[(240 & J) >> 4] + et[15 & J];
        }
        return L;
      }
      function en(O) {
        return "0x" + O.map((O) => er(O).substring(2)).join("");
      }
      function es(O) {
        return X(O, !0) ? (O.length - 2) / 2 : Y(O).length;
      }
      function ei(O, T, L) {
        let W = Y(O);
        return (
          null != L &&
            L > W.length &&
            (0, J.assert)(
              !1,
              "cannot slice beyond data bounds",
              "BUFFER_OVERRUN",
              { buffer: W, length: W.length, offset: L }
            ),
          er(W.slice(null == T ? 0 : T, null == L ? W.length : L))
        );
      }
      function ea(O) {
        let T = er(O).substring(2);
        for (; T.startsWith("00"); ) T = T.substring(2);
        return "0x" + T;
      }
      function eo(O, T, L) {
        let W = Y(O);
        (0, J.assert)(
          T >= W.length,
          "padding exceeds data length",
          "BUFFER_OVERRUN",
          { buffer: new Uint8Array(W), length: T, offset: T + 1 }
        );
        let Z = new Uint8Array(T);
        return Z.fill(0), L ? Z.set(W, T - W.length) : Z.set(W, 0), er(Z);
      }
      function ec(O, T) {
        return eo(O, T, !0);
      }
      function eu(O, T) {
        return eo(O, T, !1);
      }
      (T.hexlify = er),
        (T.concat = en),
        (T.dataLength = es),
        (T.dataSlice = ei),
        (T.stripZerosLeft = ea),
        (T.zeroPadValue = ec),
        (T.zeroPadBytes = eu);
    },
    7539: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.assertPrivate =
          T.assertNormalize =
          T.assertArgumentCount =
          T.assertArgument =
          T.assert =
          T.makeError =
          T.isCallException =
          T.isError =
            void 0);
      let J = L(73661),
        W = L(43980);
      function Y(O) {
        if (null == O) return "null";
        if (Array.isArray(O)) return "[ " + O.map(Y).join(", ") + " ]";
        if (O instanceof Uint8Array) {
          let T = "0123456789abcdef",
            L = "0x";
          for (let J = 0; J < O.length; J++) L += T[O[J] >> 4] + T[15 & O[J]];
          return L;
        }
        if ("object" == typeof O && "function" == typeof O.toJSON)
          return Y(O.toJSON());
        switch (typeof O) {
          case "boolean":
          case "symbol":
          case "number":
            return O.toString();
          case "bigint":
            return BigInt(O).toString();
          case "string":
            return JSON.stringify(O);
          case "object": {
            let T = Object.keys(O);
            return (
              T.sort(),
              "{ " + T.map((T) => `${Y(T)}: ${Y(O[T])}`).join(", ") + " }"
            );
          }
        }
        return "[ COULD NOT SERIALIZE ]";
      }
      function Z(O, T) {
        return O && O.code === T;
      }
      function X(O) {
        return Z(O, "CALL_EXCEPTION");
      }
      function ee(O, T, L) {
        let Z,
          X = O;
        {
          let W = [];
          if (L) {
            if ("message" in L || "code" in L || "name" in L)
              throw Error(`value will overwrite populated values: ${Y(L)}`);
            for (let O in L) {
              if ("shortMessage" === O) continue;
              let T = L[O];
              W.push(O + "=" + Y(T));
            }
          }
          W.push(`code=${T}`),
            W.push(`version=${J.version}`),
            W.length && (O += " (" + W.join(", ") + ")");
        }
        switch (T) {
          case "INVALID_ARGUMENT":
            Z = TypeError(O);
            break;
          case "NUMERIC_FAULT":
          case "BUFFER_OVERRUN":
            Z = RangeError(O);
            break;
          default:
            Z = Error(O);
        }
        return (
          (0, W.defineProperties)(Z, { code: T }),
          L && Object.assign(Z, L),
          null == Z.shortMessage &&
            (0, W.defineProperties)(Z, { shortMessage: X }),
          Z
        );
      }
      function et(O, T, L, J) {
        if (!O) throw ee(T, L, J);
      }
      function er(O, T, L, J) {
        et(O, T, "INVALID_ARGUMENT", { argument: L, value: J });
      }
      function en(O, T, L) {
        null == L && (L = ""),
          L && (L = ": " + L),
          et(O >= T, "missing arguemnt" + L, "MISSING_ARGUMENT", {
            count: O,
            expectedCount: T,
          }),
          et(O <= T, "too many arguments" + L, "UNEXPECTED_ARGUMENT", {
            count: O,
            expectedCount: T,
          });
      }
      (T.isError = Z),
        (T.isCallException = X),
        (T.makeError = ee),
        (T.assert = et),
        (T.assertArgument = er),
        (T.assertArgumentCount = en);
      let es = ["NFD", "NFC", "NFKD", "NFKC"].reduce((O, T) => {
        try {
          if ("test" !== "test".normalize(T)) throw Error("bad");
          if ("NFD" === T) {
            let O = String.fromCharCode(233).normalize("NFD"),
              T = String.fromCharCode(101, 769);
            if (O !== T) throw Error("broken");
          }
          O.push(T);
        } catch (O) {}
        return O;
      }, []);
      function ei(O) {
        et(
          es.indexOf(O) >= 0,
          "platform missing String.prototype.normalize",
          "UNSUPPORTED_OPERATION",
          { operation: "String.prototype.normalize", info: { form: O } }
        );
      }
      function ea(O, T, L) {
        if ((null == L && (L = ""), O !== T)) {
          let O = L,
            T = "new";
          L && ((O += "."), (T += " " + L)),
            et(
              !1,
              `private constructor; use ${O}from* methods`,
              "UNSUPPORTED_OPERATION",
              { operation: T }
            );
        }
      }
      (T.assertNormalize = ei), (T.assertPrivate = ea);
    },
    335: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.EventPayload = void 0);
      let J = L(43980);
      class W {
        constructor(O, T, L) {
          (this.e__7 = T),
            (0, J.defineProperties)(this, { emitter: O, filter: L });
        }
        async removeListener() {
          null != this.e__7 && (await this.emitter.off(this.filter, this.e__7));
        }
      }
      T.EventPayload = W;
    },
    6815: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.FixedNumber = void 0);
      let J = L(54389),
        W = L(7539),
        Y = L(31112),
        Z = L(43980),
        X = BigInt(-1),
        ee = BigInt(0),
        et = BigInt(1),
        er = BigInt(5),
        en = {},
        es = "0000";
      for (; es.length < 80; ) es += es;
      function ei(O) {
        let T = es;
        for (; T.length < O; ) T += T;
        return BigInt("1" + T.substring(0, O));
      }
      function ea(O, T, L) {
        let J = BigInt(T.width);
        if (T.signed) {
          let T = et << (J - et);
          (0, W.assert)(
            null == L || (O >= -T && O < T),
            "overflow",
            "NUMERIC_FAULT",
            { operation: L, fault: "overflow", value: O }
          ),
            (O =
              O > ee
                ? (0, Y.fromTwos)((0, Y.mask)(O, J), J)
                : -(0, Y.fromTwos)((0, Y.mask)(-O, J), J));
        } else {
          let T = et << J;
          (0, W.assert)(
            null == L || (O >= 0 && O < T),
            "overflow",
            "NUMERIC_FAULT",
            { operation: L, fault: "overflow", value: O }
          ),
            (O = ((O % T) + T) % T & (T - et));
        }
        return O;
      }
      function eo(O) {
        "number" == typeof O && (O = `fixed128x${O}`);
        let T = !0,
          L = 128,
          J = 18;
        if ("string" == typeof O) {
          if ("fixed" === O);
          else if ("ufixed" === O) T = !1;
          else {
            let Y = O.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            (0, W.assertArgument)(Y, "invalid fixed format", "format", O),
              (T = "u" !== Y[1]),
              (L = parseInt(Y[2])),
              (J = parseInt(Y[3]));
          }
        } else if (O) {
          let Y = O,
            Z = (O, T, L) =>
              null == Y[O]
                ? L
                : ((0, W.assertArgument)(
                    typeof Y[O] === T,
                    "invalid fixed format (" + O + " not " + T + ")",
                    "format." + O,
                    Y[O]
                  ),
                  Y[O]);
          (T = Z("signed", "boolean", T)),
            (L = Z("width", "number", L)),
            (J = Z("decimals", "number", J));
        }
        (0, W.assertArgument)(
          L % 8 == 0,
          "invalid FixedNumber width (not byte aligned)",
          "format.width",
          L
        ),
          (0, W.assertArgument)(
            J <= 80,
            "invalid FixedNumber decimals (too large)",
            "format.decimals",
            J
          );
        let Y = (T ? "" : "u") + "fixed" + String(L) + "x" + String(J);
        return { signed: T, width: L, decimals: J, name: Y };
      }
      function ec(O, T) {
        let L = "";
        O < ee && ((L = "-"), (O *= X));
        let J = O.toString();
        if (0 === T) return L + J;
        for (; J.length <= T; ) J = es + J;
        let W = J.length - T;
        for (
          J = J.substring(0, W) + "." + J.substring(W);
          "0" === J[0] && "." !== J[1];

        )
          J = J.substring(1);
        for (; "0" === J[J.length - 1] && "." !== J[J.length - 2]; )
          J = J.substring(0, J.length - 1);
        return L + J;
      }
      class eu {
        
        constructor(O, T, L) {
          (0, W.assertPrivate)(O, en, "FixedNumber"),
            (this._tw = T),
            (this._tA = L);
          let J = ec(T, L.decimals);
          (0, Z.defineProperties)(this, { format: L.name, _value: J }),
            (this._tv = ei(L.decimals));
        }
        get signed() {
          return this._tA.signed;
        }
        get width() {
          return this._tA.width;
        }
        get decimals() {
          return this._tA.decimals;
        }
        get value() {
          return this._tw;
        }
        __tk(O) {
          (0, W.assertArgument)(
            this.format === O.format,
            "incompatible format; use fixedNumber.toFormat",
            "other",
            O
          );
        }
        __tE(O, T) {
          return new eu(en, (O = ea(O, this._tA, T)), this._tA);
        }
        __tS(O, T) {
          return this.__tk(O), this.__tE(this._tw + O._tw, T);
        }
        addUnsafe(O) {
          return this.__tS(O);
        }
        add(O) {
          return this.__tS(O, "add");
        }
        __tP(O, T) {
          return this.__tk(O), this.__tE(this._tw - O._tw, T);
        }
        subUnsafe(O) {
          return this.__tP(O);
        }
        sub(O) {
          return this.__tP(O, "sub");
        }
        __tx(O, T) {
          return this.__tk(O), this.__tE((this._tw * O._tw) / this._tv, T);
        }
        mulUnsafe(O) {
          return this.__tx(O);
        }
        mul(O) {
          return this.__tx(O, "mul");
        }
        mulSignal(O) {
          this.__tk(O);
          let T = this._tw * O._tw;
          return (
            (0, W.assert)(
              T % this._tv === ee,
              "precision lost during signalling mul",
              "NUMERIC_FAULT",
              { operation: "mulSignal", fault: "underflow", value: this }
            ),
            this.__tE(T / this._tv, "mulSignal")
          );
        }
        __tC(O, T) {
          return (
            (0, W.assert)(O._tw !== ee, "division by zero", "NUMERIC_FAULT", {
              operation: "div",
              fault: "divide-by-zero",
              value: this,
            }),
            this.__tk(O),
            this.__tE((this._tw * this._tv) / O._tw, T)
          );
        }
        divUnsafe(O) {
          return this.__tC(O);
        }
        div(O) {
          return this.__tC(O, "div");
        }
        divSignal(O) {
          (0, W.assert)(O._tw !== ee, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this,
          }),
            this.__tk(O);
          let T = this._tw * this._tv;
          return (
            (0, W.assert)(
              T % O._tw === ee,
              "precision lost during signalling div",
              "NUMERIC_FAULT",
              { operation: "divSignal", fault: "underflow", value: this }
            ),
            this.__tE(T / O._tw, "divSignal")
          );
        }
        cmp(O) {
          let T = this.value,
            L = O.value,
            J = this.decimals - O.decimals;
          return (J > 0 ? (L *= ei(J)) : J < 0 && (T *= ei(-J)), T < L)
            ? -1
            : T > L
            ? 1
            : 0;
        }
        eq(O) {
          return 0 === this.cmp(O);
        }
        lt(O) {
          return 0 > this.cmp(O);
        }
        lte(O) {
          return 0 >= this.cmp(O);
        }
        gt(O) {
          return this.cmp(O) > 0;
        }
        gte(O) {
          return this.cmp(O) >= 0;
        }
        floor() {
          let O = this._tw;
          return (
            this._tw < ee && (O -= this._tv - et),
            (O = (this._tw / this._tv) * this._tv),
            this.__tE(O, "floor")
          );
        }
        ceiling() {
          let O = this._tw;
          return (
            this._tw > ee && (O += this._tv - et),
            (O = (this._tw / this._tv) * this._tv),
            this.__tE(O, "ceiling")
          );
        }
        round(O) {
          if ((null == O && (O = 0), O >= this.decimals)) return this;
          let T = this.decimals - O,
            L = er * ei(T - 1),
            J = this.value + L,
            W = ei(T);
          return (
            ea((J = (J / W) * W), this._tA, "round"), new eu(en, J, this._tA)
          );
        }
        isZero() {
          return this._tw === ee;
        }
        isNegative() {
          return this._tw < ee;
        }
        toString() {
          return this._value;
        }
        toUnsafeFloat() {
          return parseFloat(this.toString());
        }
        toFormat(O) {
          return eu.fromString(this.toString(), O);
        }
        static fromValue(O, T, L) {
          let J = null == T ? 0 : (0, Y.getNumber)(T),
            Z = eo(L),
            X = (0, Y.getBigInt)(O, "value"),
            et = J - Z.decimals;
          if (et > 0) {
            let T = ei(et);
            (0, W.assert)(
              X % T === ee,
              "value loses precision for format",
              "NUMERIC_FAULT",
              { operation: "fromValue", fault: "underflow", value: O }
            ),
              (X /= T);
          } else et < 0 && (X *= ei(-et));
          return ea(X, Z, "fromValue"), new eu(en, X, Z);
        }
        static fromString(O, T) {
          let L = O.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
          (0, W.assertArgument)(
            L && L[2].length + L[3].length > 0,
            "invalid FixedNumber string value",
            "value",
            O
          );
          let J = eo(T),
            Y = L[2] || "0",
            Z = L[3] || "";
          for (; Z.length < J.decimals; ) Z += es;
          (0, W.assert)(
            Z.substring(J.decimals).match(/^0*$/),
            "too many decimals for format",
            "NUMERIC_FAULT",
            { operation: "fromString", fault: "underflow", value: O }
          ),
            (Z = Z.substring(0, J.decimals));
          let X = BigInt(L[1] + Y + Z);
          return ea(X, J, "fromString"), new eu(en, X, J);
        }
        static fromBytes(O, T) {
          let L = (0, Y.toBigInt)((0, J.getBytes)(O, "value")),
            W = eo(T);
          return (
            W.signed && (L = (0, Y.fromTwos)(L, W.width)),
            ea(L, W, "fromBytes"),
            new eu(en, L, W)
          );
        }
      }
      T.FixedNumber = eu;
    },
    80591: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.getUrl = T.createGetUrl = void 0);
      let J = L(7539);
      function W(O) {
        return async function (O, T) {
          let L;
          let W = O.url.split(":")[0].toLowerCase();
          if (
            ((0, J.assert)(
              "http" === W || "https" === W,
              `unsupported protocol ${W}`,
              "UNSUPPORTED_OPERATION",
              { info: { protocol: W }, operation: "request" }
            ),
            (0, J.assert)(
              "https" === W || !O.credentials || O.allowInsecureAuthentication,
              "insecure authorized connections unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "request" }
            ),
            T)
          ) {
            let O = new AbortController();
            (L = O.signal),
              T.addListener(() => {
                O.abort();
              });
          }
          let Y = {
              method: O.method,
              headers: new Headers(Array.from(O)),
              body: O.body || void 0,
              signal: L,
            },
            Z = await fetch(O.url, Y),
            X = {};
          Z.headers.forEach((O, T) => {
            X[T.toLowerCase()] = O;
          });
          let ee = await Z.arrayBuffer(),
            et = null == ee ? null : new Uint8Array(ee);
          return {
            statusCode: Z.status,
            statusMessage: Z.statusText,
            headers: X,
            body: et,
          };
        };
      }
      T.createGetUrl = W;
      let Y = W({});
      async function Z(O, T) {
        return Y(O, T);
      }
      T.getUrl = Z;
    },
    38478: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.toUtf8String =
          T.toUtf8CodePoints =
          T.toUtf8Bytes =
          T.parseUnits =
          T.formatUnits =
          T.parseEther =
          T.formatEther =
          T.encodeRlp =
          T.decodeRlp =
          T.defineProperties =
          T.resolveProperties =
          T.toQuantity =
          T.toBeArray =
          T.toBeHex =
          T.toNumber =
          T.toBigInt =
          T.getUint =
          T.getNumber =
          T.getBigInt =
          T.mask =
          T.toTwos =
          T.fromTwos =
          T.FixedNumber =
          T.FetchCancelSignal =
          T.FetchResponse =
          T.FetchRequest =
          T.EventPayload =
          T.makeError =
          T.assertNormalize =
          T.assertPrivate =
          T.assertArgumentCount =
          T.assertArgument =
          T.assert =
          T.isError =
          T.isCallException =
          T.zeroPadBytes =
          T.zeroPadValue =
          T.stripZerosLeft =
          T.dataSlice =
          T.dataLength =
          T.concat =
          T.hexlify =
          T.isBytesLike =
          T.isHexString =
          T.getBytesCopy =
          T.getBytes =
          T.encodeBase64 =
          T.decodeBase64 =
          T.encodeBase58 =
          T.decodeBase58 =
            void 0),
        (T.uuidV4 = T.Utf8ErrorFuncs = void 0);
      var J = L(75924);
      Object.defineProperty(T, "decodeBase58", {
        enumerable: !0,
        get: function () {
          return J.decodeBase58;
        },
      }),
        Object.defineProperty(T, "encodeBase58", {
          enumerable: !0,
          get: function () {
            return J.encodeBase58;
          },
        });
      var W = L(42969);
      Object.defineProperty(T, "decodeBase64", {
        enumerable: !0,
        get: function () {
          return W.decodeBase64;
        },
      }),
        Object.defineProperty(T, "encodeBase64", {
          enumerable: !0,
          get: function () {
            return W.encodeBase64;
          },
        });
      var Y = L(54389);
      Object.defineProperty(T, "getBytes", {
        enumerable: !0,
        get: function () {
          return Y.getBytes;
        },
      }),
        Object.defineProperty(T, "getBytesCopy", {
          enumerable: !0,
          get: function () {
            return Y.getBytesCopy;
          },
        }),
        Object.defineProperty(T, "isHexString", {
          enumerable: !0,
          get: function () {
            return Y.isHexString;
          },
        }),
        Object.defineProperty(T, "isBytesLike", {
          enumerable: !0,
          get: function () {
            return Y.isBytesLike;
          },
        }),
        Object.defineProperty(T, "hexlify", {
          enumerable: !0,
          get: function () {
            return Y.hexlify;
          },
        }),
        Object.defineProperty(T, "concat", {
          enumerable: !0,
          get: function () {
            return Y.concat;
          },
        }),
        Object.defineProperty(T, "dataLength", {
          enumerable: !0,
          get: function () {
            return Y.dataLength;
          },
        }),
        Object.defineProperty(T, "dataSlice", {
          enumerable: !0,
          get: function () {
            return Y.dataSlice;
          },
        }),
        Object.defineProperty(T, "stripZerosLeft", {
          enumerable: !0,
          get: function () {
            return Y.stripZerosLeft;
          },
        }),
        Object.defineProperty(T, "zeroPadValue", {
          enumerable: !0,
          get: function () {
            return Y.zeroPadValue;
          },
        }),
        Object.defineProperty(T, "zeroPadBytes", {
          enumerable: !0,
          get: function () {
            return Y.zeroPadBytes;
          },
        });
      var Z = L(7539);
      Object.defineProperty(T, "isCallException", {
        enumerable: !0,
        get: function () {
          return Z.isCallException;
        },
      }),
        Object.defineProperty(T, "isError", {
          enumerable: !0,
          get: function () {
            return Z.isError;
          },
        }),
        Object.defineProperty(T, "assert", {
          enumerable: !0,
          get: function () {
            return Z.assert;
          },
        }),
        Object.defineProperty(T, "assertArgument", {
          enumerable: !0,
          get: function () {
            return Z.assertArgument;
          },
        }),
        Object.defineProperty(T, "assertArgumentCount", {
          enumerable: !0,
          get: function () {
            return Z.assertArgumentCount;
          },
        }),
        Object.defineProperty(T, "assertPrivate", {
          enumerable: !0,
          get: function () {
            return Z.assertPrivate;
          },
        }),
        Object.defineProperty(T, "assertNormalize", {
          enumerable: !0,
          get: function () {
            return Z.assertNormalize;
          },
        }),
        Object.defineProperty(T, "makeError", {
          enumerable: !0,
          get: function () {
            return Z.makeError;
          },
        });
      var X = L(335);
      Object.defineProperty(T, "EventPayload", {
        enumerable: !0,
        get: function () {
          return X.EventPayload;
        },
      });
      var et = L(6815);
      Object.defineProperty(T, "FixedNumber", {
        enumerable: !0,
        get: function () {
          return et.FixedNumber;
        },
      });
      var er = L(31112);
      Object.defineProperty(T, "fromTwos", {
        enumerable: !0,
        get: function () {
          return er.fromTwos;
        },
      }),
        Object.defineProperty(T, "toTwos", {
          enumerable: !0,
          get: function () {
            return er.toTwos;
          },
        }),
        Object.defineProperty(T, "mask", {
          enumerable: !0,
          get: function () {
            return er.mask;
          },
        }),
        Object.defineProperty(T, "getBigInt", {
          enumerable: !0,
          get: function () {
            return er.getBigInt;
          },
        }),
        Object.defineProperty(T, "getNumber", {
          enumerable: !0,
          get: function () {
            return er.getNumber;
          },
        }),
        Object.defineProperty(T, "getUint", {
          enumerable: !0,
          get: function () {
            return er.getUint;
          },
        }),
        Object.defineProperty(T, "toBigInt", {
          enumerable: !0,
          get: function () {
            return er.toBigInt;
          },
        }),
        Object.defineProperty(T, "toNumber", {
          enumerable: !0,
          get: function () {
            return er.toNumber;
          },
        }),
        Object.defineProperty(T, "toBeHex", {
          enumerable: !0,
          get: function () {
            return er.toBeHex;
          },
        }),
        Object.defineProperty(T, "toBeArray", {
          enumerable: !0,
          get: function () {
            return er.toBeArray;
          },
        }),
        Object.defineProperty(T, "toQuantity", {
          enumerable: !0,
          get: function () {
            return er.toQuantity;
          },
        });
      var en = L(43980);
      Object.defineProperty(T, "resolveProperties", {
        enumerable: !0,
        get: function () {
          return en.resolveProperties;
        },
      }),
        Object.defineProperty(T, "defineProperties", {
          enumerable: !0,
          get: function () {
            return en.defineProperties;
          },
        });
      var es = L(77925);
      Object.defineProperty(T, "decodeRlp", {
        enumerable: !0,
        get: function () {
          return es.decodeRlp;
        },
      });
      var ei = L(67660);
      Object.defineProperty(T, "encodeRlp", {
        enumerable: !0,
        get: function () {
          return ei.encodeRlp;
        },
      });
      var ea = L(64407);
      Object.defineProperty(T, "formatEther", {
        enumerable: !0,
        get: function () {
          return ea.formatEther;
        },
      }),
        Object.defineProperty(T, "parseEther", {
          enumerable: !0,
          get: function () {
            return ea.parseEther;
          },
        }),
        Object.defineProperty(T, "formatUnits", {
          enumerable: !0,
          get: function () {
            return ea.formatUnits;
          },
        }),
        Object.defineProperty(T, "parseUnits", {
          enumerable: !0,
          get: function () {
            return ea.parseUnits;
          },
        });
      var eo = L(42822);
      Object.defineProperty(T, "toUtf8Bytes", {
        enumerable: !0,
        get: function () {
          return eo.toUtf8Bytes;
        },
      }),
        Object.defineProperty(T, "toUtf8CodePoints", {
          enumerable: !0,
          get: function () {
            return eo.toUtf8CodePoints;
          },
        }),
        Object.defineProperty(T, "toUtf8String", {
          enumerable: !0,
          get: function () {
            return eo.toUtf8String;
          },
        }),
        Object.defineProperty(T, "Utf8ErrorFuncs", {
          enumerable: !0,
          get: function () {
            return eo.Utf8ErrorFuncs;
          },
        });
      var ec = L(10975);
      Object.defineProperty(T, "uuidV4", {
        enumerable: !0,
        get: function () {
          return ec.uuidV4;
        },
      });
    },
    31112: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.toQuantity =
          T.toBeArray =
          T.toBeHex =
          T.toNumber =
          T.getNumber =
          T.toBigInt =
          T.getUint =
          T.getBigInt =
          T.mask =
          T.toTwos =
          T.fromTwos =
            void 0);
      let J = L(54389),
        W = L(7539),
        Y = BigInt(0),
        Z = BigInt(1),
        X = 9007199254740991;
      function ee(O, T) {
        let L = es(O, "value"),
          J = BigInt(eo(T, "width"));
        return ((0, W.assert)(L >> J === Y, "overflow", "NUMERIC_FAULT", {
          operation: "fromTwos",
          fault: "overflow",
          value: O,
        }),
        L >> (J - Z))
          ? -((~L & ((Z << J) - Z)) + Z)
          : L;
      }
      function et(O, T) {
        let L = en(O, "value"),
          J = BigInt(eo(T, "width")),
          X = Z << (J - Z);
        return L < Y
          ? ((L = -L),
            (0, W.assert)(L <= X, "too low", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: O,
            }),
            (~L & ((Z << J) - Z)) + Z)
          : ((0, W.assert)(L < X, "too high", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: O,
            }),
            L);
      }
      function er(O, T) {
        return es(O, "value") & ((Z << BigInt(eo(T, "bits"))) - Z);
      }
      function en(O, T) {
        switch (typeof O) {
          case "bigint":
            return O;
          case "number":
            return (
              (0, W.assertArgument)(
                Number.isInteger(O),
                "underflow",
                T || "value",
                O
              ),
              (0, W.assertArgument)(
                O >= -X && O <= X,
                "overflow",
                T || "value",
                O
              ),
              BigInt(O)
            );
          case "string":
            try {
              if ("" === O) throw Error("empty string");
              if ("-" === O[0] && "-" !== O[1]) return -BigInt(O.substring(1));
              return BigInt(O);
            } catch (L) {
              (0, W.assertArgument)(
                !1,
                `invalid BigNumberish string: ${L.message}`,
                T || "value",
                O
              );
            }
        }
        (0, W.assertArgument)(
          !1,
          "invalid BigNumberish value",
          T || "value",
          O
        );
      }
      function es(O, T) {
        let L = en(O, T);
        return (
          (0, W.assert)(
            L >= Y,
            "unsigned value cannot be negative",
            "NUMERIC_FAULT",
            { fault: "overflow", operation: "getUint", value: O }
          ),
          L
        );
      }
      (T.fromTwos = ee),
        (T.toTwos = et),
        (T.mask = er),
        (T.getBigInt = en),
        (T.getUint = es);
      let ei = "0123456789abcdef";
      function ea(O) {
        if (O instanceof Uint8Array) {
          let T = "0x0";
          for (let L of O) T += ei[L >> 4] + ei[15 & L];
          return BigInt(T);
        }
        return en(O);
      }
      function eo(O, T) {
        switch (typeof O) {
          case "bigint":
            return (
              (0, W.assertArgument)(
                O >= -X && O <= X,
                "overflow",
                T || "value",
                O
              ),
              Number(O)
            );
          case "number":
            return (
              (0, W.assertArgument)(
                Number.isInteger(O),
                "underflow",
                T || "value",
                O
              ),
              (0, W.assertArgument)(
                O >= -X && O <= X,
                "overflow",
                T || "value",
                O
              ),
              O
            );
          case "string":
            try {
              if ("" === O) throw Error("empty string");
              return eo(BigInt(O), T);
            } catch (L) {
              (0, W.assertArgument)(
                !1,
                `invalid numeric string: ${L.message}`,
                T || "value",
                O
              );
            }
        }
        (0, W.assertArgument)(!1, "invalid numeric value", T || "value", O);
      }
      function ec(O) {
        return eo(ea(O));
      }
      function eu(O, T) {
        let L = es(O, "value").toString(16);
        if (null == T) L.length % 2 && (L = "0" + L);
        else {
          let J = eo(T, "width");
          for (
            (0, W.assert)(
              2 * J >= L.length,
              `value exceeds width (${J} bytes)`,
              "NUMERIC_FAULT",
              { operation: "toBeHex", fault: "overflow", value: O }
            );
            L.length < 2 * J;

          )
            L = "0" + L;
        }
        return "0x" + L;
      }
      function eh(O) {
        let T = es(O, "value");
        if (T === Y) return new Uint8Array([]);
        let L = T.toString(16);
        L.length % 2 && (L = "0" + L);
        let J = new Uint8Array(L.length / 2);
        for (let O = 0; O < J.length; O++) {
          let T = 2 * O;
          J[O] = parseInt(L.substring(T, T + 2), 16);
        }
        return J;
      }
      function ed(O) {
        let T = (0, J.hexlify)((0, J.isBytesLike)(O) ? O : eh(O)).substring(2);
        for (; T.startsWith("0"); ) T = T.substring(1);
        return "" === T && (T = "0"), "0x" + T;
      }
      (T.toBigInt = ea),
        (T.getNumber = eo),
        (T.toNumber = ec),
        (T.toBeHex = eu),
        (T.toBeArray = eh),
        (T.toQuantity = ed);
    },
    43980: function (O, T) {
      // "use strict";
      function L(O, T, L) {
        let J = T.split("|").map((O) => O.trim());
        for (let L = 0; L < J.length; L++)
          switch (T) {
            case "any":
              return;
            case "bigint":
            case "boolean":
            case "number":
            case "string":
              if (typeof O === T) return;
          }
        let W = Error(`invalid value for type ${T}`);
        throw (
          ((W.code = "INVALID_ARGUMENT"),
          (W.argument = `value.${L}`),
          (W.value = O),
          W)
        );
      }
      async function J(O) {
        let T = Object.keys(O);
        return (await Promise.all(T.map((T) => Promise.resolve(O[T])))).reduce(
          (O, L, J) => ((O[T[J]] = L), O),
          {}
        );
      }
      function W(O, T, J) {
        for (let W in T) {
          let Y = T[W],
            Z = J ? J[W] : null;
          Z && L(Y, Z, W),
            Object.defineProperty(O, W, {
              enumerable: !0,
              value: Y,
              writable: !1,
            });
        }
      }
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.defineProperties = T.resolveProperties = void 0),
        (T.resolveProperties = J),
        (T.defineProperties = W);
    },
    77925: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.decodeRlp = void 0);
      let J = L(54389),
        W = L(7539),
        Y = L(54389);
      function Z(O) {
        let T = O.toString(16);
        for (; T.length < 2; ) T = "0" + T;
        return "0x" + T;
      }
      function X(O, T, L) {
        let J = 0;
        for (let W = 0; W < L; W++) J = 256 * J + O[T + W];
        return J;
      }
      function ee(O, T, L, J) {
        let Y = [];
        for (; L < T + 1 + J; ) {
          let Z = et(O, L);
          Y.push(Z.result),
            (L += Z.consumed),
            (0, W.assert)(
              L <= T + 1 + J,
              "child data too short",
              "BUFFER_OVERRUN",
              { buffer: O, length: J, offset: T }
            );
        }
        return { consumed: 1 + J, result: Y };
      }
      function et(O, T) {
        (0, W.assert)(0 !== O.length, "data too short", "BUFFER_OVERRUN", {
          buffer: O,
          length: 0,
          offset: 1,
        });
        let L = (T) => {
          (0, W.assert)(
            T <= O.length,
            "data short segment too short",
            "BUFFER_OVERRUN",
            { buffer: O, length: O.length, offset: T }
          );
        };
        if (O[T] >= 248) {
          let J = O[T] - 247;
          L(T + 1 + J);
          let W = X(O, T + 1, J);
          return L(T + 1 + J + W), ee(O, T, T + 1 + J, J + W);
        }
        if (O[T] >= 192) {
          let J = O[T] - 192;
          return L(T + 1 + J), ee(O, T, T + 1, J);
        }
        if (O[T] >= 184) {
          let W = O[T] - 183;
          L(T + 1 + W);
          let Y = X(O, T + 1, W);
          L(T + 1 + W + Y);
          let Z = (0, J.hexlify)(O.slice(T + 1 + W, T + 1 + W + Y));
          return { consumed: 1 + W + Y, result: Z };
        }
        if (O[T] >= 128) {
          let W = O[T] - 128;
          L(T + 1 + W);
          let Y = (0, J.hexlify)(O.slice(T + 1, T + 1 + W));
          return { consumed: 1 + W, result: Y };
        }
        return { consumed: 1, result: Z(O[T]) };
      }
      function er(O) {
        let T = (0, Y.getBytes)(O, "data"),
          L = et(T, 0);
        return (
          (0, W.assertArgument)(
            L.consumed === T.length,
            "unexpected junk after rlp payload",
            "data",
            O
          ),
          L.result
        );
      }
      T.decodeRlp = er;
    },
    67660: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.encodeRlp = void 0);
      let J = L(54389);
      function W(O) {
        let T = [];
        for (; O; ) T.unshift(255 & O), (O >>= 8);
        return T;
      }
      function Y(O) {
        if (Array.isArray(O)) {
          let T = [];
          if (
            (O.forEach(function (O) {
              T = T.concat(Y(O));
            }),
            T.length <= 55)
          )
            return T.unshift(192 + T.length), T;
          let L = W(T.length);
          return L.unshift(247 + L.length), L.concat(T);
        }
        let T = Array.prototype.slice.call((0, J.getBytes)(O, "object"));
        if (1 === T.length && T[0] <= 127) return T;
        if (T.length <= 55) return T.unshift(128 + T.length), T;
        let L = W(T.length);
        return L.unshift(183 + L.length), L.concat(T);
      }
      let Z = "0123456789abcdef";
      function X(O) {
        let T = "0x";
        for (let L of Y(O)) T += Z[L >> 4] + Z[15 & L];
        return T;
      }
      T.encodeRlp = X;
    },
    64407: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.parseEther = T.formatEther = T.parseUnits = T.formatUnits = void 0);
      let J = L(7539),
        W = L(6815),
        Y = L(31112),
        Z = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
      function X(O, T) {
        let L = 18;
        if ("string" == typeof T) {
          let O = Z.indexOf(T);
          (0, J.assertArgument)(O >= 0, "invalid unit", "unit", T), (L = 3 * O);
        } else null != T && (L = (0, Y.getNumber)(T, "unit"));
        return W.FixedNumber.fromValue(O, L, {
          decimals: L,
          width: 512,
        }).toString();
      }
      function ee(O, T) {
        (0, J.assertArgument)(
          "string" == typeof O,
          "value must be a string",
          "value",
          O
        );
        let L = 18;
        if ("string" == typeof T) {
          let O = Z.indexOf(T);
          (0, J.assertArgument)(O >= 0, "invalid unit", "unit", T), (L = 3 * O);
        } else null != T && (L = (0, Y.getNumber)(T, "unit"));
        return W.FixedNumber.fromString(O, { decimals: L, width: 512 }).value;
      }
      function et(O) {
        return X(O, 18);
      }
      function er(O) {
        return ee(O, 18);
      }
      (T.formatUnits = X),
        (T.parseUnits = ee),
        (T.formatEther = et),
        (T.parseEther = er);
    },
    42822: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.toUtf8CodePoints =
          T.toUtf8String =
          T.toUtf8Bytes =
          T.Utf8ErrorFuncs =
            void 0);
      let J = L(54389),
        W = L(7539);
      function Y(O, T, L, J, Y) {
        (0, W.assertArgument)(
          !1,
          `invalid codepoint at offset ${T}; ${O}`,
          "bytes",
          L
        );
      }
      function Z(O, T, L, J, W) {
        if ("BAD_PREFIX" === O || "UNEXPECTED_CONTINUE" === O) {
          let O = 0;
          for (let J = T + 1; J < L.length && L[J] >> 6 == 2; J++) O++;
          return O;
        }
        return "OVERRUN" === O ? L.length - T - 1 : 0;
      }
      function X(O, T, L, J, Y) {
        return "OVERLONG" === O
          ? ((0, W.assertArgument)(
              "number" == typeof Y,
              "invalid bad code point for replacement",
              "badCodepoint",
              Y
            ),
            J.push(Y),
            0)
          : (J.push(65533), Z(O, T, L, J, Y));
      }
      function ee(O, L) {
        null == L && (L = T.Utf8ErrorFuncs.error);
        let W = (0, J.getBytes)(O, "bytes"),
          Y = [],
          Z = 0;
        for (; Z < W.length; ) {
          let O = W[Z++];
          if (O >> 7 == 0) {
            Y.push(O);
            continue;
          }
          let T = null,
            J = null;
          if ((224 & O) == 192) (T = 1), (J = 127);
          else if ((240 & O) == 224) (T = 2), (J = 2047);
          else if ((248 & O) == 240) (T = 3), (J = 65535);
          else {
            (192 & O) == 128
              ? (Z += L("UNEXPECTED_CONTINUE", Z - 1, W, Y))
              : (Z += L("BAD_PREFIX", Z - 1, W, Y));
            continue;
          }
          if (Z - 1 + T >= W.length) {
            Z += L("OVERRUN", Z - 1, W, Y);
            continue;
          }
          let X = O & ((1 << (8 - T - 1)) - 1);
          for (let O = 0; O < T; O++) {
            let O = W[Z];
            if ((192 & O) != 128) {
              (Z += L("MISSING_CONTINUE", Z, W, Y)), (X = null);
              break;
            }
            (X = (X << 6) | (63 & O)), Z++;
          }
          if (null !== X) {
            if (X > 1114111) {
              Z += L("OUT_OF_RANGE", Z - 1 - T, W, Y, X);
              continue;
            }
            if (X >= 55296 && X <= 57343) {
              Z += L("UTF16_SURROGATE", Z - 1 - T, W, Y, X);
              continue;
            }
            if (X <= J) {
              Z += L("OVERLONG", Z - 1 - T, W, Y, X);
              continue;
            }
            Y.push(X);
          }
        }
        return Y;
      }
      function et(O, T) {
        (0, W.assertArgument)(
          "string" == typeof O,
          "invalid string value",
          "str",
          O
        ),
          null != T && ((0, W.assertNormalize)(T), (O = O.normalize(T)));
        let L = [];
        for (let T = 0; T < O.length; T++) {
          let J = O.charCodeAt(T);
          if (J < 128) L.push(J);
          else if (J < 2048) L.push((J >> 6) | 192), L.push((63 & J) | 128);
          else if ((64512 & J) == 55296) {
            T++;
            let Y = O.charCodeAt(T);
            (0, W.assertArgument)(
              T < O.length && (64512 & Y) == 56320,
              "invalid surrogate pair",
              "str",
              O
            );
            let Z = 65536 + ((1023 & J) << 10) + (1023 & Y);
            L.push((Z >> 18) | 240),
              L.push(((Z >> 12) & 63) | 128),
              L.push(((Z >> 6) & 63) | 128),
              L.push((63 & Z) | 128);
          } else
            L.push((J >> 12) | 224),
              L.push(((J >> 6) & 63) | 128),
              L.push((63 & J) | 128);
        }
        return new Uint8Array(L);
      }
      function er(O) {
        return O.map((O) =>
          O <= 65535
            ? String.fromCharCode(O)
            : String.fromCharCode(
                (((O -= 65536) >> 10) & 1023) + 55296,
                (1023 & O) + 56320
              )
        ).join("");
      }
      function en(O, T) {
        return er(ee(O, T));
      }
      function es(O, T) {
        return ee(et(O, T));
      }
      (T.Utf8ErrorFuncs = Object.freeze({ error: Y, ignore: Z, replace: X })),
        (T.toUtf8Bytes = et),
        (T.toUtf8String = en),
        (T.toUtf8CodePoints = es);
    },
    10975: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.uuidV4 = void 0);
      let J = L(54389);
      function W(O) {
        let T = (0, J.getBytes)(O, "randomBytes");
        (T[6] = (15 & T[6]) | 64), (T[8] = (63 & T[8]) | 128);
        let L = (0, J.hexlify)(T);
        return [
          L.substring(2, 10),
          L.substring(10, 14),
          L.substring(14, 18),
          L.substring(18, 22),
          L.substring(22, 34),
        ].join("-");
      }
      T.uuidV4 = W;
    },
    93383: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.BaseWallet = void 0);
      let J = L(40431),
        W = L(41648),
        Y = L(37431),
        Z = L(16989),
        X = L(38478);
      class ee extends Y.AbstractSigner {
        
        constructor(O, T) {
          super(T),
            (0, X.assertArgument)(
              O && "function" == typeof O.sign,
              "invalid private key",
              "privateKey",
              "[ REDACTED ]"
            ),
            (this._tB = O);
          let L = (0, Z.computeAddress)(this.signingKey.publicKey);
          (0, X.defineProperties)(this, { address: L });
        }
        get signingKey() {
          return this._tB;
        }
        get privateKey() {
          return this.signingKey.privateKey;
        }
        async getAddress() {
          return this.address;
        }
        connect(O) {
          return new ee(this._tB, O);
        }
        async signTransaction(O) {
          let { to: T, from: L } = await (0, X.resolveProperties)({
            to: O.to ? (0, J.resolveAddress)(O.to, this.provider) : void 0,
            from: O.from
              ? (0, J.resolveAddress)(O.from, this.provider)
              : void 0,
          });
          null != T && (O.to = T),
            null != L && (O.from = L),
            null != O.from &&
              ((0, X.assertArgument)(
                (0, J.getAddress)(O.from) === this.address,
                "transaction from address mismatch",
                "tx.from",
                O.from
              ),
              delete O.from);
          let W = Z.Transaction.from(O);
          return (
            (W.signature = this.signingKey.sign(W.unsignedHash)), W.serialized
          );
        }
        async signMessage(O) {
          return this.signMessageSync(O);
        }
        signMessageSync(O) {
          return this.signingKey.sign((0, W.hashMessage)(O)).serialized;
        }
        async signTypedData(O, T, L) {
          let J = await W.TypedDataEncoder.resolveNames(O, T, L, async (O) => {
            (0, X.assert)(
              null != this.provider,
              "cannot resolve ENS names without a provider",
              "UNSUPPORTED_OPERATION",
              { operation: "resolveName", info: { name: O } }
            );
            let T = await this.provider.resolveName(O);
            return (
              (0, X.assert)(
                null != T,
                "unconfigured ENS name",
                "UNCONFIGURED_NAME",
                { value: O }
              ),
              T
            );
          });
          return this.signingKey.sign(
            W.TypedDataEncoder.hash(J.domain, T, J.value)
          ).serialized;
        }
      }
      T.BaseWallet = ee;
    },
    11139: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.getIndexedAccountPath =
          T.getAccountPath =
          T.HDNodeVoidWallet =
          T.HDNodeWallet =
          T.defaultPath =
            void 0);
      let J = L(3382),
        W = L(37431),
        Y = L(16989),
        Z = L(38478),
        X = L(82689),
        ee = L(93383),
        et = L(28033),
        er = L(14260);
      T.defaultPath = "m/44'/60'/0'/0/0";
      let en = new Uint8Array([
          66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100,
        ]),
        es = 2147483648,
        ei = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        ),
        ea = "0123456789abcdef";
      function eo(O, T) {
        let L = "";
        for (; O; ) (L = ea[O % 16] + L), (O = Math.trunc(O / 16));
        for (; L.length < 2 * T; ) L = "0" + L;
        return "0x" + L;
      }
      function ec(O) {
        let T = (0, Z.getBytes)(O),
          L = (0, Z.dataSlice)((0, J.sha256)((0, J.sha256)(T)), 0, 4),
          W = (0, Z.concat)([T, L]);
        return (0, Z.encodeBase58)(W);
      }
      let eu = {};
      function eh(O, T, L, W) {
        let Y = new Uint8Array(37);
        O & es
          ? ((0, Z.assert)(
              null != W,
              "cannot derive child of neutered node",
              "UNSUPPORTED_OPERATION",
              { operation: "deriveChild" }
            ),
            Y.set((0, Z.getBytes)(W), 1))
          : Y.set((0, Z.getBytes)(L));
        for (let T = 24; T >= 0; T -= 8)
          Y[33 + (T >> 3)] = (O >> (24 - T)) & 255;
        let X = (0, Z.getBytes)((0, J.computeHmac)("sha512", T, Y));
        return { IL: X.slice(0, 32), IR: X.slice(32) };
      }
      function ed(O, T) {
        let L = T.split("/");
        (0, Z.assertArgument)(L.length > 0, "invalid path", "path", T),
          "m" === L[0] &&
            ((0, Z.assertArgument)(
              0 === O.depth,
              `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${O.depth}`,
              "path",
              T
            ),
            L.shift());
        let J = O;
        for (let O = 0; O < L.length; O++) {
          let T = L[O];
          if (T.match(/^[0-9]+'$/)) {
            let L = parseInt(T.substring(0, T.length - 1));
            (0, Z.assertArgument)(
              L < es,
              "invalid path index",
              `path[${O}]`,
              T
            ),
              (J = J.deriveChild(es + L));
          } else if (T.match(/^[0-9]+$/)) {
            let L = parseInt(T);
            (0, Z.assertArgument)(
              L < es,
              "invalid path index",
              `path[${O}]`,
              T
            ),
              (J = J.deriveChild(L));
          } else
            (0, Z.assertArgument)(
              !1,
              "invalid path component",
              `path[${O}]`,
              T
            );
        }
        return J;
      }
      class ep extends ee.BaseWallet {
        
        constructor(O, T, L, W, Y, X, ee, et, er) {
          super(T, er),
            (0, Z.assertPrivate)(O, eu, "HDNodeWallet"),
            (0, Z.defineProperties)(this, { publicKey: T.compressedPublicKey });
          let en = (0, Z.dataSlice)(
            (0, J.ripemd160)((0, J.sha256)(this.publicKey)),
            0,
            4
          );
          (0, Z.defineProperties)(this, {
            parentFingerprint: L,
            fingerprint: en,
            chainCode: W,
            path: Y,
            index: X,
            depth: ee,
          }),
            (0, Z.defineProperties)(this, { mnemonic: et });
        }
        connect(O) {
          return new ep(
            eu,
            this.signingKey,
            this.parentFingerprint,
            this.chainCode,
            this.path,
            this.index,
            this.depth,
            this.mnemonic,
            O
          );
        }
        #tO() {
          let O = { address: this.address, privateKey: this.privateKey },
            T = this.mnemonic;
          return (
            this.path &&
              T &&
              "en" === T.wordlist.locale &&
              "" === T.password &&
              (O.mnemonic = {
                path: this.path,
                locale: "en",
                entropy: T.entropy,
              }),
            O
          );
        }
        async encrypt(O, T) {
          return await (0, er.encryptKeystoreJson)(this.#tO(), O, {
            progressCallback: T,
          });
        }
        encryptSync(O) {
          return (0, er.encryptKeystoreJsonSync)(this.#tO(), O);
        }
        get extendedKey() {
          return (
            (0, Z.assert)(
              this.depth < 256,
              "Depth too deep",
              "UNSUPPORTED_OPERATION",
              { operation: "extendedKey" }
            ),
            ec(
              (0, Z.concat)([
                "0x0488ADE4",
                eo(this.depth, 1),
                this.parentFingerprint,
                eo(this.index, 4),
                this.chainCode,
                (0, Z.concat)(["0x00", this.privateKey]),
              ])
            )
          );
        }
        hasPath() {
          return null != this.path;
        }
        neuter() {
          return new eg(
            eu,
            this.address,
            this.publicKey,
            this.parentFingerprint,
            this.chainCode,
            this.path,
            this.index,
            this.depth,
            this.provider
          );
        }
        deriveChild(O) {
          let T = (0, Z.getNumber)(O, "index");
          (0, Z.assertArgument)(T <= 4294967295, "invalid index", "index", T);
          let L = this.path;
          L && ((L += "/" + (T & ~es)), T & es && (L += "'"));
          let { IR: W, IL: Y } = eh(
            T,
            this.chainCode,
            this.publicKey,
            this.privateKey
          );
          return new ep(
            eu,
            new J.SigningKey(
              (0, Z.toBeHex)(
                ((0, Z.toBigInt)(Y) + BigInt(this.privateKey)) % ei,
                32
              )
            ),
            this.fingerprint,
            (0, Z.hexlify)(W),
            L,
            T,
            this.depth + 1,
            this.mnemonic,
            this.provider
          );
        }
        derivePath(O) {
          return ed(this, O);
        }
        static #tT(O, T) {
          (0, Z.assertArgument)(
            (0, Z.isBytesLike)(O),
            "invalid seed",
            "seed",
            "[REDACTED]"
          );
          let L = (0, Z.getBytes)(O, "seed");
          (0, Z.assertArgument)(
            L.length >= 16 && L.length <= 64,
            "invalid seed",
            "seed",
            "[REDACTED]"
          );
          let W = (0, Z.getBytes)((0, J.computeHmac)("sha512", en, L));
          return new ep(
            eu,
            new J.SigningKey((0, Z.hexlify)(W.slice(0, 32))),
            "0x00000000",
            (0, Z.hexlify)(W.slice(32)),
            "m",
            0,
            0,
            T,
            null
          );
        }
        static fromExtendedKey(O) {
          let T = (0, Z.toBeArray)((0, Z.decodeBase58)(O));
          (0, Z.assertArgument)(
            82 === T.length || ec(T.slice(0, 78)) === O,
            "invalid extended key",
            "extendedKey",
            "[ REDACTED ]"
          );
          let L = T[4],
            W = (0, Z.hexlify)(T.slice(5, 9)),
            X = parseInt((0, Z.hexlify)(T.slice(9, 13)).substring(2), 16),
            ee = (0, Z.hexlify)(T.slice(13, 45)),
            et = T.slice(45, 78);
          switch ((0, Z.hexlify)(T.slice(0, 4))) {
            case "0x0488b21e":
            case "0x043587cf": {
              let O = (0, Z.hexlify)(et);
              return new eg(
                eu,
                (0, Y.computeAddress)(O),
                O,
                W,
                ee,
                null,
                X,
                L,
                null
              );
            }
            case "0x0488ade4":
            case "0x04358394 ":
              if (0 !== et[0]) break;
              return new ep(
                eu,
                new J.SigningKey(et.slice(1)),
                W,
                ee,
                null,
                X,
                L,
                null,
                null
              );
          }
          (0, Z.assertArgument)(
            !1,
            "invalid extended key prefix",
            "extendedKey",
            "[ REDACTED ]"
          );
        }
        static createRandom(O, L, W) {
          null == O && (O = ""),
            null == L && (L = T.defaultPath),
            null == W && (W = X.LangEn.wordlist());
          let Y = et.Mnemonic.fromEntropy((0, J.randomBytes)(16), O, W);
          return ep.#tT(Y.computeSeed(), Y).derivePath(L);
        }
        static fromMnemonic(O, L) {
          return (
            L || (L = T.defaultPath), ep.#tT(O.computeSeed(), O).derivePath(L)
          );
        }
        static fromPhrase(O, L, J, W) {
          null == L && (L = ""),
            null == J && (J = T.defaultPath),
            null == W && (W = X.LangEn.wordlist());
          let Y = et.Mnemonic.fromPhrase(O, L, W);
          return ep.#tT(Y.computeSeed(), Y).derivePath(J);
        }
        static fromSeed(O) {
          return ep.#tT(O, null);
        }
      }
      T.HDNodeWallet = ep;
      class eg extends W.VoidSigner {
        
        constructor(O, T, L, W, Y, X, ee, et, er) {
          super(T, er),
            (0, Z.assertPrivate)(O, eu, "HDNodeVoidWallet"),
            (0, Z.defineProperties)(this, { publicKey: L });
          let en = (0, Z.dataSlice)((0, J.ripemd160)((0, J.sha256)(L)), 0, 4);
          (0, Z.defineProperties)(this, {
            publicKey: L,
            fingerprint: en,
            parentFingerprint: W,
            chainCode: Y,
            path: X,
            index: ee,
            depth: et,
          });
        }
        connect(O) {
          return new eg(
            eu,
            this.address,
            this.publicKey,
            this.parentFingerprint,
            this.chainCode,
            this.path,
            this.index,
            this.depth,
            O
          );
        }
        get extendedKey() {
          return (
            (0, Z.assert)(
              this.depth < 256,
              "Depth too deep",
              "UNSUPPORTED_OPERATION",
              { operation: "extendedKey" }
            ),
            ec(
              (0, Z.concat)([
                "0x0488B21E",
                eo(this.depth, 1),
                this.parentFingerprint,
                eo(this.index, 4),
                this.chainCode,
                this.publicKey,
              ])
            )
          );
        }
        hasPath() {
          return null != this.path;
        }
        deriveChild(O) {
          let T = (0, Z.getNumber)(O, "index");
          (0, Z.assertArgument)(T <= 4294967295, "invalid index", "index", T);
          let L = this.path;
          L && ((L += "/" + (T & ~es)), T & es && (L += "'"));
          let { IR: W, IL: X } = eh(T, this.chainCode, this.publicKey, null),
            ee = J.SigningKey.addPoints(X, this.publicKey, !0);
          return new eg(
            eu,
            (0, Y.computeAddress)(ee),
            ee,
            this.fingerprint,
            (0, Z.hexlify)(W),
            L,
            T,
            this.depth + 1,
            this.provider
          );
        }
        derivePath(O) {
          return ed(this, O);
        }
      }
      function ey(O) {
        let T = (0, Z.getNumber)(O, "index");
        return (
          (0, Z.assertArgument)(
            T >= 0 && T < es,
            "invalid account index",
            "index",
            T
          ),
          `m/44'/60'/${T}'/0/0`
        );
      }
      function em(O) {
        let T = (0, Z.getNumber)(O, "index");
        return (
          (0, Z.assertArgument)(
            T >= 0 && T < es,
            "invalid account index",
            "index",
            T
          ),
          `m/44'/60'/0'/0/${T}`
        );
      }
      (T.HDNodeVoidWallet = eg),
        (T.getAccountPath = ey),
        (T.getIndexedAccountPath = em);
    },
    92311: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Wallet =
          T.Mnemonic =
          T.encryptKeystoreJsonSync =
          T.encryptKeystoreJson =
          T.decryptKeystoreJson =
          T.decryptKeystoreJsonSync =
          T.isKeystoreJson =
          T.decryptCrowdsaleJson =
          T.isCrowdsaleJson =
          T.HDNodeVoidWallet =
          T.HDNodeWallet =
          T.getIndexedAccountPath =
          T.getAccountPath =
          T.defaultPath =
          T.BaseWallet =
            void 0);
      var J = L(93383);
      Object.defineProperty(T, "BaseWallet", {
        enumerable: !0,
        get: function () {
          return J.BaseWallet;
        },
      });
      var W = L(11139);
      Object.defineProperty(T, "defaultPath", {
        enumerable: !0,
        get: function () {
          return W.defaultPath;
        },
      }),
        Object.defineProperty(T, "getAccountPath", {
          enumerable: !0,
          get: function () {
            return W.getAccountPath;
          },
        }),
        Object.defineProperty(T, "getIndexedAccountPath", {
          enumerable: !0,
          get: function () {
            return W.getIndexedAccountPath;
          },
        }),
        Object.defineProperty(T, "HDNodeWallet", {
          enumerable: !0,
          get: function () {
            return W.HDNodeWallet;
          },
        }),
        Object.defineProperty(T, "HDNodeVoidWallet", {
          enumerable: !0,
          get: function () {
            return W.HDNodeVoidWallet;
          },
        });
      var Y = L(52339);
      Object.defineProperty(T, "isCrowdsaleJson", {
        enumerable: !0,
        get: function () {
          return Y.isCrowdsaleJson;
        },
      }),
        Object.defineProperty(T, "decryptCrowdsaleJson", {
          enumerable: !0,
          get: function () {
            return Y.decryptCrowdsaleJson;
          },
        });
      var Z = L(14260);
      Object.defineProperty(T, "isKeystoreJson", {
        enumerable: !0,
        get: function () {
          return Z.isKeystoreJson;
        },
      }),
        Object.defineProperty(T, "decryptKeystoreJsonSync", {
          enumerable: !0,
          get: function () {
            return Z.decryptKeystoreJsonSync;
          },
        }),
        Object.defineProperty(T, "decryptKeystoreJson", {
          enumerable: !0,
          get: function () {
            return Z.decryptKeystoreJson;
          },
        }),
        Object.defineProperty(T, "encryptKeystoreJson", {
          enumerable: !0,
          get: function () {
            return Z.encryptKeystoreJson;
          },
        }),
        Object.defineProperty(T, "encryptKeystoreJsonSync", {
          enumerable: !0,
          get: function () {
            return Z.encryptKeystoreJsonSync;
          },
        });
      var X = L(28033);
      Object.defineProperty(T, "Mnemonic", {
        enumerable: !0,
        get: function () {
          return X.Mnemonic;
        },
      });
      var ee = L(42522);
      Object.defineProperty(T, "Wallet", {
        enumerable: !0,
        get: function () {
          return ee.Wallet;
        },
      });
    },
    52339: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.decryptCrowdsaleJson = T.isCrowdsaleJson = void 0);
      let J = L(63107),
        W = L(40431),
        Y = L(3382),
        Z = L(41648),
        X = L(38478),
        ee = L(99634);
      function et(O) {
        try {
          if (JSON.parse(O).encseed) return !0;
        } catch (O) {}
        return !1;
      }
      function er(O, T) {
        let L = JSON.parse(O),
          et = (0, ee.getPassword)(T),
          er = (0, W.getAddress)((0, ee.spelunk)(L, "ethaddr:string!")),
          en = (0, ee.looseArrayify)((0, ee.spelunk)(L, "encseed:string!"));
        (0, X.assertArgument)(
          en && en.length % 16 == 0,
          "invalid encseed",
          "json",
          O
        );
        let es = (0, X.getBytes)(
            (0, Y.pbkdf2)(et, et, 2e3, 32, "sha256")
          ).slice(0, 16),
          ei = en.slice(0, 16),
          ea = en.slice(16),
          eo = new J.CBC(es, ei),
          ec = (0, J.pkcs7Strip)((0, X.getBytes)(eo.decrypt(ea))),
          eu = "";
        for (let O = 0; O < ec.length; O++) eu += String.fromCharCode(ec[O]);
        return { address: er, privateKey: (0, Z.id)(eu) };
      }
      (T.isCrowdsaleJson = et), (T.decryptCrowdsaleJson = er);
    },
    14260: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.encryptKeystoreJson =
          T.encryptKeystoreJsonSync =
          T.decryptKeystoreJson =
          T.decryptKeystoreJsonSync =
          T.isKeystoreJson =
            void 0);
      let J = L(63107),
        W = L(40431),
        Y = L(3382),
        Z = L(16989),
        X = L(38478),
        ee = L(99634),
        et = L(73661),
        er = "m/44'/60'/0'/0/0";
      function en(O) {
        try {
          let T = JSON.parse(O),
            L = null != T.version ? parseInt(T.version) : 0;
          if (3 === L) return !0;
        } catch (O) {}
        return !1;
      }
      function es(O, T, L) {
        if ("aes-128-ctr" === (0, ee.spelunk)(O, "crypto.cipher:string")) {
          let W = (0, ee.spelunk)(O, "crypto.cipherparams.iv:data!"),
            Y = new J.CTR(T, W);
          return (0, X.hexlify)(Y.decrypt(L));
        }
        (0, X.assert)(!1, "unsupported cipher", "UNSUPPORTED_OPERATION", {
          operation: "decrypt",
        });
      }
      function ei(O, T) {
        let L = (0, X.getBytes)(T),
          et = (0, ee.spelunk)(O, "crypto.ciphertext:data!"),
          en = (0, X.hexlify)(
            (0, Y.keccak256)((0, X.concat)([L.slice(16, 32), et]))
          ).substring(2);
        (0, X.assertArgument)(
          en === (0, ee.spelunk)(O, "crypto.mac:string!").toLowerCase(),
          "incorrect password",
          "password",
          "[ REDACTED ]"
        );
        let ei = es(O, L.slice(0, 16), et),
          ea = (0, Z.computeAddress)(ei);
        if (O.address) {
          let T = O.address.toLowerCase();
          T.startsWith("0x") || (T = "0x" + T),
            (0, X.assertArgument)(
              (0, W.getAddress)(T) === ea,
              "keystore address/privateKey mismatch",
              "address",
              O.address
            );
        }
        let eo = { address: ea, privateKey: ei };
        if ("0.1" === (0, ee.spelunk)(O, "x-ethers.version:string")) {
          let T = L.slice(32, 64),
            W = (0, ee.spelunk)(O, "x-ethers.mnemonicCiphertext:data!"),
            Y = (0, ee.spelunk)(O, "x-ethers.mnemonicCounter:data!"),
            Z = new J.CTR(T, Y);
          eo.mnemonic = {
            path: (0, ee.spelunk)(O, "x-ethers.path:string") || er,
            locale: (0, ee.spelunk)(O, "x-ethers.locale:string") || "en",
            entropy: (0, X.hexlify)((0, X.getBytes)(Z.decrypt(W))),
          };
        }
        return eo;
      }
      function ea(O) {
        let T = (0, ee.spelunk)(O, "crypto.kdf:string");
        if (T && "string" == typeof T) {
          if ("scrypt" === T.toLowerCase()) {
            let L = (0, ee.spelunk)(O, "crypto.kdfparams.salt:data!"),
              J = (0, ee.spelunk)(O, "crypto.kdfparams.n:int!"),
              W = (0, ee.spelunk)(O, "crypto.kdfparams.r:int!"),
              Y = (0, ee.spelunk)(O, "crypto.kdfparams.p:int!");
            (0, X.assertArgument)(
              J > 0 && (J & (J - 1)) == 0,
              "invalid kdf.N",
              "kdf.N",
              J
            ),
              (0, X.assertArgument)(W > 0 && Y > 0, "invalid kdf", "kdf", T);
            let Z = (0, ee.spelunk)(O, "crypto.kdfparams.dklen:int!");
            return (
              (0, X.assertArgument)(
                32 === Z,
                "invalid kdf.dklen",
                "kdf.dflen",
                Z
              ),
              { name: "scrypt", salt: L, N: J, r: W, p: Y, dkLen: 64 }
            );
          }
          if ("pbkdf2" === T.toLowerCase()) {
            let T = (0, ee.spelunk)(O, "crypto.kdfparams.salt:data!"),
              L = (0, ee.spelunk)(O, "crypto.kdfparams.prf:string!"),
              J = L.split("-").pop();
            (0, X.assertArgument)(
              "sha256" === J || "sha512" === J,
              "invalid kdf.pdf",
              "kdf.pdf",
              L
            );
            let W = (0, ee.spelunk)(O, "crypto.kdfparams.c:int!"),
              Y = (0, ee.spelunk)(O, "crypto.kdfparams.dklen:int!");
            return (
              (0, X.assertArgument)(
                32 === Y,
                "invalid kdf.dklen",
                "kdf.dklen",
                Y
              ),
              { name: "pbkdf2", salt: T, count: W, dkLen: Y, algorithm: J }
            );
          }
        }
        (0, X.assertArgument)(
          !1,
          "unsupported key-derivation function",
          "kdf",
          T
        );
      }
      function eo(O, T) {
        let L = JSON.parse(O),
          J = (0, ee.getPassword)(T),
          W = ea(L);
        if ("pbkdf2" === W.name) {
          let { salt: O, count: T, dkLen: Z, algorithm: X } = W;
          return ei(L, (0, Y.pbkdf2)(J, O, T, Z, X));
        }
        (0, X.assert)(
          "scrypt" === W.name,
          "cannot be reached",
          "UNKNOWN_ERROR",
          { params: W }
        );
        let { salt: Z, N: et, r: er, p: en, dkLen: es } = W;
        return ei(L, (0, Y.scryptSync)(J, Z, et, er, en, es));
      }
      function ec(O) {
        return new Promise((T) => {
          setTimeout(() => {
            T();
          }, O);
        });
      }
      async function eu(O, T, L) {
        let J = JSON.parse(O),
          W = (0, ee.getPassword)(T),
          Z = ea(J);
        if ("pbkdf2" === Z.name) {
          L && (L(0), await ec(0));
          let { salt: O, count: T, dkLen: X, algorithm: ee } = Z,
            et = (0, Y.pbkdf2)(W, O, T, X, ee);
          return L && (L(1), await ec(0)), ei(J, et);
        }
        (0, X.assert)(
          "scrypt" === Z.name,
          "cannot be reached",
          "UNKNOWN_ERROR",
          { params: Z }
        );
        let { salt: et, N: er, r: en, p: es, dkLen: eo } = Z;
        return ei(J, await (0, Y.scrypt)(W, et, er, en, es, eo, L));
      }
      function eh(O) {
        let T =
            null != O.salt
              ? (0, X.getBytes)(O.salt, "options.salt")
              : (0, Y.randomBytes)(32),
          L = 131072,
          J = 8,
          W = 1;
        return (
          O.scrypt &&
            (O.scrypt.N && (L = O.scrypt.N),
            O.scrypt.r && (J = O.scrypt.r),
            O.scrypt.p && (W = O.scrypt.p)),
          (0, X.assertArgument)(
            "number" == typeof L &&
              L > 0 &&
              Number.isSafeInteger(L) &&
              (BigInt(L) & BigInt(L - 1)) === BigInt(0),
            "invalid scrypt N parameter",
            "options.N",
            L
          ),
          (0, X.assertArgument)(
            "number" == typeof J && J > 0 && Number.isSafeInteger(J),
            "invalid scrypt r parameter",
            "options.r",
            J
          ),
          (0, X.assertArgument)(
            "number" == typeof W && W > 0 && Number.isSafeInteger(W),
            "invalid scrypt p parameter",
            "options.p",
            W
          ),
          { name: "scrypt", dkLen: 32, salt: T, N: L, r: J, p: W }
        );
      }
      function ed(O, T, L, W) {
        let Z = (0, X.getBytes)(L.privateKey, "privateKey"),
          en =
            null != W.iv
              ? (0, X.getBytes)(W.iv, "options.iv")
              : (0, Y.randomBytes)(16);
        (0, X.assertArgument)(
          16 === en.length,
          "invalid options.iv length",
          "options.iv",
          W.iv
        );
        let es =
          null != W.uuid
            ? (0, X.getBytes)(W.uuid, "options.uuid")
            : (0, Y.randomBytes)(16);
        (0, X.assertArgument)(
          16 === es.length,
          "invalid options.uuid length",
          "options.uuid",
          W.iv
        );
        let ei = O.slice(0, 16),
          ea = O.slice(16, 32),
          eo = new J.CTR(ei, en),
          ec = (0, X.getBytes)(eo.encrypt(Z)),
          eu = (0, Y.keccak256)((0, X.concat)([ea, ec])),
          eh = {
            address: L.address.substring(2).toLowerCase(),
            id: (0, X.uuidV4)(es),
            version: 3,
            Crypto: {
              cipher: "aes-128-ctr",
              cipherparams: { iv: (0, X.hexlify)(en).substring(2) },
              ciphertext: (0, X.hexlify)(ec).substring(2),
              kdf: "scrypt",
              kdfparams: {
                salt: (0, X.hexlify)(T.salt).substring(2),
                n: T.N,
                dklen: 32,
                p: T.p,
                r: T.r,
              },
              mac: eu.substring(2),
            },
          };
        if (L.mnemonic) {
          let T = null != W.client ? W.client : `ethers/${et.version}`,
            Z = L.mnemonic.path || er,
            en = L.mnemonic.locale || "en",
            es = O.slice(32, 64),
            ei = (0, X.getBytes)(
              L.mnemonic.entropy,
              "account.mnemonic.entropy"
            ),
            ea = (0, Y.randomBytes)(16),
            eo = new J.CTR(es, ea),
            ec = (0, X.getBytes)(eo.encrypt(ei)),
            eu = new Date(),
            ed =
              "UTC--" +
              (eu.getUTCFullYear() +
                "-" +
                (0, ee.zpad)(eu.getUTCMonth() + 1, 2) +
                "-" +
                (0, ee.zpad)(eu.getUTCDate(), 2) +
                "T" +
                (0, ee.zpad)(eu.getUTCHours(), 2) +
                "-" +
                (0, ee.zpad)(eu.getUTCMinutes(), 2) +
                "-") +
              (0, ee.zpad)(eu.getUTCSeconds(), 2) +
              ".0Z--" +
              eh.address;
          eh["x-ethers"] = {
            client: T,
            gethFilename: ed,
            path: Z,
            locale: en,
            mnemonicCounter: (0, X.hexlify)(ea).substring(2),
            mnemonicCiphertext: (0, X.hexlify)(ec).substring(2),
            version: "0.1",
          };
        }
        return JSON.stringify(eh);
      }
      function ep(O, T, L) {
        null == L && (L = {});
        let J = (0, ee.getPassword)(T),
          W = eh(L),
          Z = (0, Y.scryptSync)(J, W.salt, W.N, W.r, W.p, 64);
        return ed((0, X.getBytes)(Z), W, O, L);
      }
      async function eg(O, T, L) {
        null == L && (L = {});
        let J = (0, ee.getPassword)(T),
          W = eh(L),
          Z = await (0, Y.scrypt)(
            J,
            W.salt,
            W.N,
            W.r,
            W.p,
            64,
            L.progressCallback
          );
        return ed((0, X.getBytes)(Z), W, O, L);
      }
      (T.isKeystoreJson = en),
        (T.decryptKeystoreJsonSync = eo),
        (T.decryptKeystoreJson = eu),
        (T.encryptKeystoreJsonSync = ep),
        (T.encryptKeystoreJson = eg);
    },
    28033: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Mnemonic = void 0);
      let J = L(3382),
        W = L(38478),
        Y = L(82689);
      function Z(O) {
        return (((1 << O) - 1) << (8 - O)) & 255;
      }
      function X(O) {
        return ((1 << O) - 1) & 255;
      }
      function ee(O, T) {
        (0, W.assertNormalize)("NFKD"), null == T && (T = Y.LangEn.wordlist());
        let L = T.split(O);
        (0, W.assertArgument)(
          L.length % 3 == 0 && L.length >= 12 && L.length <= 24,
          "invalid mnemonic length",
          "mnemonic",
          "[ REDACTED ]"
        );
        let X = new Uint8Array(Math.ceil((11 * L.length) / 8)),
          ee = 0;
        for (let O = 0; O < L.length; O++) {
          let J = T.getWordIndex(L[O].normalize("NFKD"));
          (0, W.assertArgument)(
            J >= 0,
            `invalid mnemonic word at index ${O}`,
            "mnemonic",
            "[ REDACTED ]"
          );
          for (let O = 0; O < 11; O++)
            J & (1 << (10 - O)) && (X[ee >> 3] |= 1 << (7 - (ee % 8))), ee++;
        }
        let et = (32 * L.length) / 3,
          er = Z(L.length / 3),
          en = (0, W.getBytes)((0, J.sha256)(X.slice(0, et / 8)))[0] & er;
        return (
          (0, W.assertArgument)(
            en === (X[X.length - 1] & er),
            "invalid mnemonic checksum",
            "mnemonic",
            "[ REDACTED ]"
          ),
          (0, W.hexlify)(X.slice(0, et / 8))
        );
      }
      function et(O, T) {
        (0, W.assertArgument)(
          O.length % 4 == 0 && O.length >= 16 && O.length <= 32,
          "invalid entropy size",
          "entropy",
          "[ REDACTED ]"
        ),
          null == T && (T = Y.LangEn.wordlist());
        let L = [0],
          ee = 11;
        for (let T = 0; T < O.length; T++)
          ee > 8
            ? ((L[L.length - 1] <<= 8), (L[L.length - 1] |= O[T]), (ee -= 8))
            : ((L[L.length - 1] <<= ee),
              (L[L.length - 1] |= O[T] >> (8 - ee)),
              L.push(O[T] & X(8 - ee)),
              (ee += 3));
        let et = O.length / 4,
          er = parseInt((0, J.sha256)(O).substring(2, 4), 16) & Z(et);
        return (
          (L[L.length - 1] <<= et),
          (L[L.length - 1] |= er >> (8 - et)),
          T.join(L.map((O) => T.getWord(O)))
        );
      }
      let er = {};
      class en {
        
        constructor(O, T, L, J, Z) {
          null == J && (J = ""),
            null == Z && (Z = Y.LangEn.wordlist()),
            (0, W.assertPrivate)(O, er, "Mnemonic"),
            (0, W.defineProperties)(this, {
              phrase: L,
              password: J,
              wordlist: Z,
              entropy: T,
            });
        }
        computeSeed() {
          let O = (0, W.toUtf8Bytes)("mnemonic" + this.password, "NFKD");
          return (0, J.pbkdf2)(
            (0, W.toUtf8Bytes)(this.phrase, "NFKD"),
            O,
            2048,
            64,
            "sha512"
          );
        }
        static fromPhrase(O, T, L) {
          let J = ee(O, L);
          return (O = et((0, W.getBytes)(J), L)), new en(er, J, O, T, L);
        }
        static fromEntropy(O, T, L) {
          let J = (0, W.getBytes)(O, "entropy"),
            Y = et(J, L);
          return new en(er, (0, W.hexlify)(J), Y, T, L);
        }
        static entropyToPhrase(O, T) {
          return et((0, W.getBytes)(O, "entropy"), T);
        }
        static phraseToEntropy(O, T) {
          return ee(O, T);
        }
        static isValidMnemonic(O, T) {
          try {
            return ee(O, T), !0;
          } catch (O) {}
          return !1;
        }
      }
      T.Mnemonic = en;
    },
    99634: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.spelunk = T.getPassword = T.zpad = T.looseArrayify = void 0);
      let J = L(38478);
      function W(O) {
        return (
          "string" != typeof O || O.startsWith("0x") || (O = "0x" + O),
          (0, J.getBytesCopy)(O)
        );
      }
      function Y(O, T) {
        for (O = String(O); O.length < T; ) O = "0" + O;
        return O;
      }
      function Z(O) {
        return "string" == typeof O
          ? (0, J.toUtf8Bytes)(O, "NFKC")
          : (0, J.getBytesCopy)(O);
      }
      function X(O, T) {
        let L = T.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
        (0, J.assertArgument)(null != L, "invalid path", "path", T);
        let Y = L[1],
          Z = L[3],
          X = "!" === L[4],
          ee = O;
        for (let O of Y.toLowerCase().split(".")) {
          if (Array.isArray(ee)) {
            if (!O.match(/^[0-9]+$/)) break;
            ee = ee[parseInt(O)];
          } else if ("object" == typeof ee) {
            let T = null;
            for (let L in ee)
              if (L.toLowerCase() === O) {
                T = ee[L];
                break;
              }
            ee = T;
          } else ee = null;
          if (null == ee) break;
        }
        if (
          ((0, J.assertArgument)(
            !X || null != ee,
            "missing required value",
            "path",
            Y
          ),
          Z && null != ee)
        ) {
          if ("int" === Z) {
            if ("string" == typeof ee && ee.match(/^-?[0-9]+$/))
              return parseInt(ee);
            if (Number.isSafeInteger(ee)) return ee;
          }
          if (
            "number" === Z &&
            "string" == typeof ee &&
            ee.match(/^-?[0-9.]*$/)
          )
            return parseFloat(ee);
          if ("data" === Z && "string" == typeof ee) return W(ee);
          if (("array" === Z && Array.isArray(ee)) || Z === typeof ee)
            return ee;
          (0, J.assertArgument)(!1, `wrong type found for ${Z} `, "path", Y);
        }
        return ee;
      }
      (T.looseArrayify = W), (T.zpad = Y), (T.getPassword = Z), (T.spelunk = X);
    },
    42522: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Wallet = void 0);
      let J = L(3382),
        W = L(38478),
        Y = L(93383),
        Z = L(11139),
        X = L(52339),
        ee = L(14260),
        et = L(28033);
      function er(O) {
        return new Promise((T) => {
          setTimeout(() => {
            T();
          }, O);
        });
      }
      class en extends Y.BaseWallet {
        constructor(O, T) {
          "string" != typeof O || O.startsWith("0x") || (O = "0x" + O),
            super("string" == typeof O ? new J.SigningKey(O) : O, T);
        }
        connect(O) {
          return new en(this.signingKey, O);
        }
        async encrypt(O, T) {
          let L = { address: this.address, privateKey: this.privateKey };
          return await (0, ee.encryptKeystoreJson)(L, O, {
            progressCallback: T,
          });
        }
        encryptSync(O) {
          let T = { address: this.address, privateKey: this.privateKey };
          return (0, ee.encryptKeystoreJsonSync)(T, O);
        }
        static #tN(O) {
          if (
            ((0, W.assertArgument)(
              O,
              "invalid JSON wallet",
              "json",
              "[ REDACTED ]"
            ),
            "mnemonic" in O && O.mnemonic && "en" === O.mnemonic.locale)
          ) {
            let T = et.Mnemonic.fromEntropy(O.mnemonic.entropy),
              L = Z.HDNodeWallet.fromMnemonic(T, O.mnemonic.path);
            if (L.address === O.address && L.privateKey === O.privateKey)
              return L;
            console.log(
              "WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key"
            );
          }
          let T = new en(O.privateKey);
          return (
            (0, W.assertArgument)(
              T.address === O.address,
              "address/privateKey mismatch",
              "json",
              "[ REDACTED ]"
            ),
            T
          );
        }
        static async fromEncryptedJson(O, T, L) {
          let J = null;
          return (
            (0, ee.isKeystoreJson)(O)
              ? (J = await (0, ee.decryptKeystoreJson)(O, T, L))
              : (0, X.isCrowdsaleJson)(O) &&
                (L && (L(0), await er(0)),
                (J = (0, X.decryptCrowdsaleJson)(O, T)),
                L && (L(1), await er(0))),
            en.#tN(J)
          );
        }
        static fromEncryptedJsonSync(O, T) {
          let L = null;
          return (
            (0, ee.isKeystoreJson)(O)
              ? (L = (0, ee.decryptKeystoreJsonSync)(O, T))
              : (0, X.isCrowdsaleJson)(O)
              ? (L = (0, X.decryptCrowdsaleJson)(O, T))
              : (0, W.assertArgument)(
                  !1,
                  "invalid JSON wallet",
                  "json",
                  "[ REDACTED ]"
                ),
            en.#tN(L)
          );
        }
        static createRandom(O) {
          let T = Z.HDNodeWallet.createRandom();
          return O ? T.connect(O) : T;
        }
        static fromPhrase(O, T) {
          let L = Z.HDNodeWallet.fromPhrase(O);
          return T ? L.connect(T) : L;
        }
      }
      T.Wallet = en;
    },
    24822: function (O, T) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.decodeBits = void 0);
      let L =
        ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
      function J(O, T) {
        let J = (1 << O) - 1,
          W = [],
          Y = 0,
          Z = 0,
          X = 0;
        for (let ee = 0; ee < T.length; ee++)
          for (Y = (Y << 6) | L.indexOf(T[ee]), Z += 6; Z >= O; ) {
            let T = Y >> (Z - O);
            (Y &= (1 << (Z - O)) - 1),
              (Z -= O),
              0 === T ? (X += J) : (W.push(T + X), (X = 0));
          }
        return W;
      }
      T.decodeBits = J;
    },
    7457: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.decodeOwl = T.decode = void 0);
      let J = L(38478),
        W = " !#$%&'()*+,-./<=>?@[]^_`{|}~",
        Y = /^[a-z]*$/i;
      function Z(O, T) {
        let L = 97;
        return O.reduce(
          (O, J) => (
            J === T
              ? L++
              : J.match(Y)
              ? O.push(String.fromCharCode(L) + J)
              : ((L = 97), O.push(J)),
            O
          ),
          []
        );
      }
      function X(O, T) {
        for (let L = W.length - 1; L >= 0; L--)
          O = O.split(W[L]).join(T.substring(2 * L, 2 * L + 2));
        let L = [],
          J = O.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (O, T, J, W) => {
            if (J) for (let O = parseInt(J); O >= 0; O--) L.push(";");
            else L.push(T.toLowerCase());
            return "";
          });
        if (J) throw Error(`leftovers: ${JSON.stringify(J)}`);
        return Z(Z(L, ";"), ":");
      }
      function ee(O) {
        return (
          (0, J.assertArgument)(
            "0" === O[0],
            "unsupported auwl data",
            "data",
            O
          ),
          X(O.substring(1 + 2 * W.length), O.substring(1, 1 + 2 * W.length))
        );
      }
      (T.decode = X), (T.decodeOwl = ee);
    },
    14248: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.decodeOwlA = void 0);
      let J = L(38478),
        W = L(24822),
        Y = L(7457);
      function Z(O, T) {
        let L = (0, Y.decodeOwl)(O).join(",");
        return (
          T.split(/,/g).forEach((O) => {
            let Y = O.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
            (0, J.assertArgument)(
              null !== Y,
              "internal error parsing accents",
              "accents",
              T
            );
            let Z = 0,
              X = (0, W.decodeBits)(parseInt(Y[3]), Y[4]),
              ee = parseInt(Y[2]),
              et = RegExp(`([${Y[1]}])`, "g");
            L = L.replace(
              et,
              (O, T) => (
                0 == --X[Z] &&
                  ((T = String.fromCharCode(T.charCodeAt(0), ee)), Z++),
                T
              )
            );
          }),
          L.split(",")
        );
      }
      T.decodeOwlA = Z;
    },
    63851: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.wordlists =
          T.WordlistOwlA =
          T.WordlistOwl =
          T.LangEn =
          T.Wordlist =
            void 0);
      var J = L(27399);
      Object.defineProperty(T, "Wordlist", {
        enumerable: !0,
        get: function () {
          return J.Wordlist;
        },
      });
      var W = L(82689);
      Object.defineProperty(T, "LangEn", {
        enumerable: !0,
        get: function () {
          return W.LangEn;
        },
      });
      var Y = L(98346);
      Object.defineProperty(T, "WordlistOwl", {
        enumerable: !0,
        get: function () {
          return Y.WordlistOwl;
        },
      });
      var Z = L(46102);
      Object.defineProperty(T, "WordlistOwlA", {
        enumerable: !0,
        get: function () {
          return Z.WordlistOwlA;
        },
      });
      var X = L(98085);
      Object.defineProperty(T, "wordlists", {
        enumerable: !0,
        get: function () {
          return X.wordlists;
        },
      });
    },
    82689: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.LangEn = void 0);
      let J = L(98346),
        W =
          "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%CD__0+GL<)Lcy__0~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/TtU__0^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs_Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEIL__0(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLmL__0#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO",
        Y =
          "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60",
        Z = null;
      class X extends J.WordlistOwl {
        constructor() {
          super("en", W, Y);
        }
        static wordlist() {
          return null == Z && (Z = new X()), Z;
        }
      }
      T.LangEn = X;
    },
    98346: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.WordlistOwl = void 0);
      let J = L(41648),
        W = L(38478),
        Y = L(7457),
        Z = L(27399);
      class X extends Z.Wordlist {
        constructor(O, T, L) {
          super(O), (this._r = T), (this._tR = L), (this._tI = null);
        }
        get _data() {
          return this._r;
        }
        _decodeWords() {
          return (0, Y.decodeOwl)(this._r);
        }
        _tI;
        __tM() {
          if (null == this._tI) {
            let O = this._decodeWords();
            if ((0, J.id)(O.join("\n") + "\n") !== this._tR)
              throw Error(`BIP39 Wordlist for ${this.locale} FAILED`);
            this._tI = O;
          }
          return this._tI;
        }
        getWord(O) {
          let T = this.__tM();
          return (
            (0, W.assertArgument)(
              O >= 0 && O < T.length,
              `invalid word index: ${O}`,
              "index",
              O
            ),
            T[O]
          );
        }
        getWordIndex(O) {
          return this.__tM().indexOf(O);
        }
      }
      T.WordlistOwl = X;
    },
    46102: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.WordlistOwlA = void 0);
      let J = L(98346),
        W = L(14248);
      class Y extends J.WordlistOwl {
        constructor(O, T, L, J) {
          super(O, T, J), (this._tU = L);
        }
        get _accent() {
          return this._tU;
        }
        _decodeWords() {
          return (0, W.decodeOwlA)(this._data, this._accent);
        }
      }
      T.WordlistOwlA = Y;
    },
    27399: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.Wordlist = void 0);
      let J = L(38478);
      class W {
        constructor(O) {
          (0, J.defineProperties)(this, { locale: O });
        }
        split(O) {
          return O.toLowerCase().split(/\s+/g);
        }
        join(O) {
          return O.join(" ");
        }
      }
      T.Wordlist = W;
    },
    98085: function (O, T, L) {
      // "use strict";
      Object.defineProperty(T, "__esModule", { value: !0 }),
        (T.wordlists = void 0);
      let J = L(82689);
      T.wordlists = { en: J.LangEn.wordlist() };
    },
    61436: function (O, T, L) {
      // "use strict";
      L.d(T, {
        S: function () {
          return eh;
        },
      });
      var J = L(36076),
        W = L(29360),
        Y = L(30558),
        Z = L(92472),
        X = class extends Z.F {
          constructor(O) {
            super(),
              (this._tH = !1),
              (this._tj = O.defaultOptions),
              this.setOptions(O.options),
              (this._tK = []),
              (this._t_ = O.cache),
              (this.queryKey = O.queryKey),
              (this.queryHash = O.queryHash),
              (this._tL = O.state || ee(this.options)),
              (this.state = this._tL),
              this.scheduleGc();
          }
          get meta() {
            return this.options.meta;
          }
          setOptions(O) {
            (this.options = { ...this._tj, ...O }),
              this.updateGcTime(this.options.gcTime);
          }
          optionalRemove() {
            this._tK.length ||
              "idle" !== this.state.fetchStatus ||
              this._t_.remove(this);
          }
          setData(O, T) {
            let L = (0, J.oE)(this.state.data, O, this.options);
            return (
              this.t__0$({
                data: L,
                type: "success",
                dataUpdatedAt: T?.updatedAt,
                manual: T?.manual,
              }),
              L
            );
          }
          setState(O, T) {
            this.t__0$({ type: "setState", state: O, setStateOptions: T });
          }
          cancel(O) {
            let T = this._tF?.promise;
            return (
              this._tF?.cancel(O),
              T ? T.then(J.ZT).catch(J.ZT) : Promise.resolve()
            );
          }
          destroy() {
            super.destroy(), this.cancel({ silent: !0 });
          }
          reset() {
            this.destroy(), this.setState(this._tL);
          }
          isActive() {
            return this._tK.some((O) => !1 !== O.options.enabled);
          }
          isDisabled() {
            return this.getObserversCount() > 0 && !this.isActive();
          }
          isStale() {
            return (
              !!this.state.isInvalidated ||
              (this.getObserversCount() > 0
                ? this._tK.some((O) => O.getCurrentResult().isStale)
                : void 0 === this.state.data)
            );
          }
          isStaleByTime(O = 0) {
            return (
              this.state.isInvalidated ||
              void 0 === this.state.data ||
              !(0, J.Kp)(this.state.dataUpdatedAt, O)
            );
          }
          onFocus() {
            let O = this._tK.find((O) => O.shouldFetchOnWindowFocus());
            O?.refetch({ cancelRefetch: !1 }), this._tF?.continue();
          }
          onOnline() {
            let O = this._tK.find((O) => O.shouldFetchOnReconnect());
            O?.refetch({ cancelRefetch: !1 }), this._tF?.continue();
          }
          addObserver(O) {
            this._tK.includes(O) ||
              (this._tK.push(O),
              this.clearGcTimeout(),
              this._t_.notify({
                type: "observerAdded",
                query: this,
                observer: O,
              }));
          }
          removeObserver(O) {
            this._tK.includes(O) &&
              ((this._tK = this._tK.filter((T) => T !== O)),
              this._tK.length ||
                (this._tF &&
                  (this._tH
                    ? this._tF.cancel({ revert: !0 })
                    : this._tF.cancelRetry()),
                this.scheduleGc()),
              this._t_.notify({
                type: "observerRemoved",
                query: this,
                observer: O,
              }));
          }
          getObserversCount() {
            return this._tK.length;
          }
          invalidate() {
            this.state.isInvalidated || this.t__0$({ type: "invalidate" });
          }
          fetch(O, T) {
            if ("idle" !== this.state.fetchStatus) {
              if (void 0 !== this.state.data && T?.cancelRefetch)
                this.cancel({ silent: !0 });
              else if (this._tF)
                return this._tF.continueRetry(), this._tF.promise;
            }
            if ((O && this.setOptions(O), !this.options.queryFn)) {
              let O = this._tK.find((O) => O.options.queryFn);
              O && this.setOptions(O.options);
            }
            let L = new AbortController(),
              W = { queryKey: this.queryKey, meta: this.meta },
              Z = (O) => {
                Object.defineProperty(O, "signal", {
                  enumerable: !0,
                  get: () => ((this._tH = !0), L.signal),
                });
              };
            Z(W);
            let X = () =>
                this.options.queryFn && this.options.queryFn !== J.CN
                  ? ((this._tH = !1), this.options.persister)
                    ? this.options.persister(this.options.queryFn, W, this)
                    : this.options.queryFn(W)
                  : Promise.reject(
                      Error(`Missing queryFn: '${this.options.queryHash}'`)
                    ),
              ee = {
                fetchOptions: T,
                options: this.options,
                queryKey: this.queryKey,
                state: this.state,
                fetchFn: X,
              };
            Z(ee),
              this.options.behavior?.onFetch(ee, this),
              (this._tD = this.state),
              ("idle" === this.state.fetchStatus ||
                this.state.fetchMeta !== ee.fetchOptions?.meta) &&
                this.t__0$({ type: "fetch", meta: ee.fetchOptions?.meta });
            let et = (O) => {
              ((0, Y.DV)(O) && O.silent) ||
                this.t__0$({ type: "error", error: O }),
                (0, Y.DV)(O) ||
                  (this._t_.config.onError?.(O, this),
                  this._t_.config.onSettled?.(this.state.data, O, this)),
                this.isFetchingOptimistic || this.scheduleGc(),
                (this.isFetchingOptimistic = !1);
            };
            return (
              (this._tF = (0, Y.Mz)({
                fn: ee.fetchFn,
                abort: L.abort.bind(L),
                onSuccess: (O) => {
                  if (void 0 === O) {
                    et(Error(`${this.queryHash} data is undefined`));
                    return;
                  }
                  this.setData(O),
                    this._t_.config.onSuccess?.(O, this),
                    this._t_.config.onSettled?.(O, this.state.error, this),
                    this.isFetchingOptimistic || this.scheduleGc(),
                    (this.isFetchingOptimistic = !1);
                },
                onError: et,
                onFail: (O, T) => {
                  this.t__0$({ type: "failed", failureCount: O, error: T });
                },
                onPause: () => {
                  this.t__0$({ type: "pause" });
                },
                onContinue: () => {
                  this.t__0$({ type: "continue" });
                },
                retry: ee.options.retry,
                retryDelay: ee.options.retryDelay,
                networkMode: ee.options.networkMode,
              })),
              this._tF.promise
            );
          }
          t__0$(O) {
            let T = (T) => {
              switch (O.type) {
                case "failed":
                  return {
                    ...T,
                    fetchFailureCount: O.failureCount,
                    fetchFailureReason: O.error,
                  };
                case "pause":
                  return { ...T, fetchStatus: "paused" };
                case "continue":
                  return { ...T, fetchStatus: "fetching" };
                case "fetch":
                  return {
                    ...T,
                    fetchFailureCount: 0,
                    fetchFailureReason: null,
                    fetchMeta: O.meta ?? null,
                    fetchStatus: (0, Y.Kw)(this.options.networkMode)
                      ? "fetching"
                      : "paused",
                    ...(void 0 === T.data && {
                      error: null,
                      status: "pending",
                    }),
                  };
                case "success":
                  return {
                    ...T,
                    data: O.data,
                    dataUpdateCount: T.dataUpdateCount + 1,
                    dataUpdatedAt: O.dataUpdatedAt ?? Date.now(),
                    error: null,
                    isInvalidated: !1,
                    status: "success",
                    ...(!O.manual && {
                      fetchStatus: "idle",
                      fetchFailureCount: 0,
                      fetchFailureReason: null,
                    }),
                  };
                case "error":
                  let L = O.error;
                  if ((0, Y.DV)(L) && L.revert && this._tD)
                    return { ...this._tD, fetchStatus: "idle" };
                  return {
                    ...T,
                    error: L,
                    errorUpdateCount: T.errorUpdateCount + 1,
                    errorUpdatedAt: Date.now(),
                    fetchFailureCount: T.fetchFailureCount + 1,
                    fetchFailureReason: L,
                    fetchStatus: "idle",
                    status: "error",
                  };
                case "invalidate":
                  return { ...T, isInvalidated: !0 };
                case "setState":
                  return { ...T, ...O.state };
              }
            };
            (this.state = T(this.state)),
              W.V.batch(() => {
                this._tK.forEach((O) => {
                  O.onQueryUpdate();
                }),
                  this._t_.notify({ query: this, type: "updated", action: O });
              });
          }
        };
      function ee(O) {
        let T =
            "function" == typeof O.initialData
              ? O.initialData()
              : O.initialData,
          L = void 0 !== T,
          J = L
            ? "function" == typeof O.initialDataUpdatedAt
              ? O.initialDataUpdatedAt()
              : O.initialDataUpdatedAt
            : 0;
        return {
          data: T,
          dataUpdateCount: 0,
          dataUpdatedAt: L ? J ?? Date.now() : 0,
          error: null,
          errorUpdateCount: 0,
          errorUpdatedAt: 0,
          fetchFailureCount: 0,
          fetchFailureReason: null,
          fetchMeta: null,
          isInvalidated: !1,
          status: L ? "success" : "pending",
          fetchStatus: "idle",
        };
      }
      var et = L(94699),
        er = class extends et.l {
          constructor(O = {}) {
            super(), (this.config = O), (this._tV = new Map());
          }
          _tV;
          build(O, T, L) {
            let W = T.queryKey,
              Y = T.queryHash ?? (0, J.Rm)(W, T),
              Z = this.get(Y);
            return (
              Z ||
                ((Z = new X({
                  cache: this,
                  queryKey: W,
                  queryHash: Y,
                  options: O.defaultQueryOptions(T),
                  state: L,
                  defaultOptions: O.getQueryDefaults(W),
                })),
                this.add(Z)),
              Z
            );
          }
          add(O) {
            this._tV.has(O.queryHash) ||
              (this._tV.set(O.queryHash, O),
              this.notify({ type: "added", query: O }));
          }
          remove(O) {
            let T = this._tV.get(O.queryHash);
            T &&
              (O.destroy(),
              T === O && this._tV.delete(O.queryHash),
              this.notify({ type: "removed", query: O }));
          }
          clear() {
            W.V.batch(() => {
              this.getAll().forEach((O) => {
                this.remove(O);
              });
            });
          }
          get(O) {
            return this._tV.get(O);
          }
          getAll() {
            return [...this._tV.values()];
          }
          find(O) {
            let T = { exact: !0, ...O };
            return this.getAll().find((O) => (0, J._x)(T, O));
          }
          findAll(O = {}) {
            let T = this.getAll();
            return Object.keys(O).length > 0
              ? T.filter((T) => (0, J._x)(O, T))
              : T;
          }
          notify(O) {
            W.V.batch(() => {
              this.listeners.forEach((T) => {
                T(O);
              });
            });
          }
          onFocus() {
            W.V.batch(() => {
              this.getAll().forEach((O) => {
                O.onFocus();
              });
            });
          }
          onOnline() {
            W.V.batch(() => {
              this.getAll().forEach((O) => {
                O.onOnline();
              });
            });
          }
        },
        en = L(46783),
        es = class extends et.l {
          constructor(O = {}) {
            super(), (this.config = O), (this._tG = []), (this._tJ = 0);
          }
          build(O, T, L) {
            let J = new en.m({
              mutationCache: this,
              mutationId: ++this._tJ,
              options: O.defaultMutationOptions(T),
              state: L,
            });
            return this.add(J), J;
          }
          add(O) {
            this._tG.push(O), this.notify({ type: "added", mutation: O });
          }
          remove(O) {
            (this._tG = this._tG.filter((T) => T !== O)),
              this.notify({ type: "removed", mutation: O });
          }
          clear() {
            W.V.batch(() => {
              this._tG.forEach((O) => {
                this.remove(O);
              });
            });
          }
          getAll() {
            return this._tG;
          }
          find(O) {
            let T = { exact: !0, ...O };
            return this._tG.find((O) => (0, J.X7)(T, O));
          }
          findAll(O = {}) {
            return this._tG.filter((T) => (0, J.X7)(O, T));
          }
          notify(O) {
            W.V.batch(() => {
              this.listeners.forEach((T) => {
                T(O);
              });
            });
          }
          resumePausedMutations() {
            return (
              (this._tz = (this._tz ?? Promise.resolve())
                .then(() => {
                  let O = this._tG.filter((O) => O.state.isPaused);
                  return W.V.batch(() =>
                    O.reduce(
                      (O, T) => O.then(() => T.continue().catch(J.ZT)),
                      Promise.resolve()
                    )
                  );
                })
                .then(() => {
                  this._tz = void 0;
                })),
              this._tz
            );
          }
        },
        ei = L(73198),
        ea = L(11996);
      function eo(O) {
        return {
          onFetch: (T, L) => {
            let W = async () => {
              let L;
              let W = T.options,
                Y = T.fetchOptions?.meta?.fetchMore?.direction,
                Z = T.state.data?.pages || [],
                X = T.state.data?.pageParams || [],
                ee = { pages: [], pageParams: [] },
                et = !1,
                er = (O) => {
                  Object.defineProperty(O, "signal", {
                    enumerable: !0,
                    get: () => (
                      T.signal.aborted
                        ? (et = !0)
                        : T.signal.addEventListener("abort", () => {
                            et = !0;
                          }),
                      T.signal
                    ),
                  });
                },
                en =
                  T.options.queryFn && T.options.queryFn !== J.CN
                    ? T.options.queryFn
                    : () =>
                        Promise.reject(
                          Error(`Missing queryFn: '${T.options.queryHash}'`)
                        ),
                es = async (O, L, W) => {
                  if (et) return Promise.reject();
                  if (null == L && O.pages.length) return Promise.resolve(O);
                  let Y = {
                    queryKey: T.queryKey,
                    pageParam: L,
                    direction: W ? "backward" : "forward",
                    meta: T.options.meta,
                  };
                  er(Y);
                  let Z = await en(Y),
                    { maxPages: X } = T.options,
                    ee = W ? J.Ht : J.VX;
                  return {
                    pages: ee(O.pages, Z, X),
                    pageParams: ee(O.pageParams, L, X),
                  };
                };
              if (Y && Z.length) {
                let O = "backward" === Y,
                  T = { pages: Z, pageParams: X },
                  J = (O ? eu : ec)(W, T);
                L = await es(T, J, O);
              } else {
                L = await es(ee, X[0] ?? W.initialPageParam);
                let T = O ?? Z.length;
                for (let O = 1; O < T; O++) {
                  let O = ec(W, L);
                  L = await es(L, O);
                }
              }
              return L;
            };
            T.options.persister
              ? (T.fetchFn = () =>
                  T.options.persister?.(
                    W,
                    {
                      queryKey: T.queryKey,
                      meta: T.options.meta,
                      signal: T.signal,
                    },
                    L
                  ))
              : (T.fetchFn = W);
          },
        };
      }
      function ec(O, { pages: T, pageParams: L }) {
        let J = T.length - 1;
        return O.getNextPageParam(T[J], T, L[J], L);
      }
      function eu(O, { pages: T, pageParams: L }) {
        return O.getPreviousPageParam?.(T[0], T, L[0], L);
      }
      var eh = class {
        constructor(O = {}) {
          (this._tQ = O.queryCache || new er()),
            (this._tq = O.mutationCache || new es()),
            (this._tj = O.defaultOptions || {}),
            (this._tW = new Map()),
            (this._tY = new Map()),
            (this._tZ = 0);
        }
        mount() {
          this._tZ++,
            1 === this._tZ &&
              ((this._tX = ei.j.subscribe(async (O) => {
                O && (await this.resumePausedMutations(), this._tQ.onFocus());
              })),
              (this._t0 = ea.N.subscribe(async (O) => {
                O && (await this.resumePausedMutations(), this._tQ.onOnline());
              })));
        }
        unmount() {
          this._tZ--,
            0 === this._tZ &&
              (this._tX?.(),
              (this._tX = void 0),
              this._t0?.(),
              (this._t0 = void 0));
        }
        isFetching(O) {
          return this._tQ.findAll({ ...O, fetchStatus: "fetching" }).length;
        }
        isMutating(O) {
          return this._tq.findAll({ ...O, status: "pending" }).length;
        }
        getQueryData(O) {
          let T = this.defaultQueryOptions({ queryKey: O });
          return this._tQ.get(T.queryHash)?.state.data;
        }
        ensureQueryData(O) {
          let T = this.getQueryData(O.queryKey);
          if (void 0 === T) return this.fetchQuery(O);
          {
            let L = this.defaultQueryOptions(O),
              J = this._tQ.build(this, L);
            return (
              O.revalidateIfStale &&
                J.isStaleByTime(L.staleTime) &&
                this.prefetchQuery(L),
              Promise.resolve(T)
            );
          }
        }
        getQueriesData(O) {
          return this.getQueryCache()
            .findAll(O)
            .map(({ queryKey: O, state: T }) => [O, T.data]);
        }
        setQueryData(O, T, L) {
          let W = this.defaultQueryOptions({ queryKey: O }),
            Y = this._tQ.get(W.queryHash),
            Z = Y?.state.data,
            X = (0, J.SE)(T, Z);
          if (void 0 !== X)
            return this._tQ.build(this, W).setData(X, { ...L, manual: !0 });
        }
        setQueriesData(O, T, L) {
          return W.V.batch(() =>
            this.getQueryCache()
              .findAll(O)
              .map(({ queryKey: O }) => [O, this.setQueryData(O, T, L)])
          );
        }
        getQueryState(O) {
          let T = this.defaultQueryOptions({ queryKey: O });
          return this._tQ.get(T.queryHash)?.state;
        }
        removeQueries(O) {
          let T = this._tQ;
          W.V.batch(() => {
            T.findAll(O).forEach((O) => {
              T.remove(O);
            });
          });
        }
        resetQueries(O, T) {
          let L = this._tQ,
            J = { type: "active", ...O };
          return W.V.batch(
            () => (
              L.findAll(O).forEach((O) => {
                O.reset();
              }),
              this.refetchQueries(J, T)
            )
          );
        }
        cancelQueries(O = {}, T = {}) {
          let L = { revert: !0, ...T };
          return Promise.all(
            W.V.batch(() => this._tQ.findAll(O).map((O) => O.cancel(L)))
          )
            .then(J.ZT)
            .catch(J.ZT);
        }
        invalidateQueries(O = {}, T = {}) {
          return W.V.batch(() => {
            if (
              (this._tQ.findAll(O).forEach((O) => {
                O.invalidate();
              }),
              "none" === O.refetchType)
            )
              return Promise.resolve();
            let L = { ...O, type: O.refetchType ?? O.type ?? "active" };
            return this.refetchQueries(L, T);
          });
        }
        refetchQueries(O = {}, T) {
          let L = { ...T, cancelRefetch: T?.cancelRefetch ?? !0 };
          return Promise.all(
            W.V.batch(() =>
              this._tQ
                .findAll(O)
                .filter((O) => !O.isDisabled())
                .map((O) => {
                  let T = O.fetch(void 0, L);
                  return (
                    L.throwOnError || (T = T.catch(J.ZT)),
                    "paused" === O.state.fetchStatus ? Promise.resolve() : T
                  );
                })
            )
          ).then(J.ZT);
        }
        fetchQuery(O) {
          let T = this.defaultQueryOptions(O);
          void 0 === T.retry && (T.retry = !1);
          let L = this._tQ.build(this, T);
          return L.isStaleByTime(T.staleTime)
            ? L.fetch(T)
            : Promise.resolve(L.state.data);
        }
        prefetchQuery(O) {
          return this.fetchQuery(O).then(J.ZT).catch(J.ZT);
        }
        fetchInfiniteQuery(O) {
          return (O.behavior = eo(O.pages)), this.fetchQuery(O);
        }
        prefetchInfiniteQuery(O) {
          return this.fetchInfiniteQuery(O).then(J.ZT).catch(J.ZT);
        }
        resumePausedMutations() {
          return ea.N.isOnline()
            ? this._tq.resumePausedMutations()
            : Promise.resolve();
        }
        getQueryCache() {
          return this._tQ;
        }
        getMutationCache() {
          return this._tq;
        }
        getDefaultOptions() {
          return this._tj;
        }
        setDefaultOptions(O) {
          this._tj = O;
        }
        setQueryDefaults(O, T) {
          this._tW.set((0, J.Ym)(O), { queryKey: O, defaultOptions: T });
        }
        getQueryDefaults(O) {
          let T = [...this._tW.values()],
            L = {};
          return (
            T.forEach((T) => {
              (0, J.to)(O, T.queryKey) && (L = { ...L, ...T.defaultOptions });
            }),
            L
          );
        }
        setMutationDefaults(O, T) {
          this._tY.set((0, J.Ym)(O), { mutationKey: O, defaultOptions: T });
        }
        getMutationDefaults(O) {
          let T = [...this._tY.values()],
            L = {};
          return (
            T.forEach((T) => {
              (0, J.to)(O, T.mutationKey) &&
                (L = { ...L, ...T.defaultOptions });
            }),
            L
          );
        }
        defaultQueryOptions(O) {
          if (O._defaulted) return O;
          let T = {
            ...this._tj.queries,
            ...this.getQueryDefaults(O.queryKey),
            ...O,
            _defaulted: !0,
          };
          return (
            T.queryHash || (T.queryHash = (0, J.Rm)(T.queryKey, T)),
            void 0 === T.refetchOnReconnect &&
              (T.refetchOnReconnect = "always" !== T.networkMode),
            void 0 === T.throwOnError && (T.throwOnError = !!T.suspense),
            !T.networkMode && T.persister && (T.networkMode = "offlineFirst"),
            !0 !== T.enabled && T.queryFn === J.CN && (T.enabled = !1),
            T
          );
        }
        defaultMutationOptions(O) {
          return O?._defaulted
            ? O
            : {
                ...this._tj.mutations,
                ...(O?.mutationKey && this.getMutationDefaults(O.mutationKey)),
                ...O,
                _defaulted: !0,
              };
        }
        clear() {
          this._tQ.clear(), this._tq.clear();
        }
      };
    },
    8133: function (O, T, L) {
      // "use strict";
      L.r(T),
        L.d(T, {
          ReactQueryDevtools: function () {
            return J;
          },
        });
      var J = function () {
        return null;
      };
    },
    74427: function (O, T, L) {
      // "use strict";
      L.d(T, {
        F: function () {
          return av;
        },
      });
      var J,
        W,
        Y,
        Z,
        X,
        ee,
        et,
        er,
        en,
        es,
        ei,
        ea,
        eo,
        ec,
        eu,
        eh,
        ed,
        ep,
        eg,
        ey,
        em,
        eb,
        eA,
        ew,
        ev,
        ek,
        eE,
        eS,
        eP,
        eC,
        eB,
        eO,
        eT,
        eN,
        eR,
        eI,
        eM = {};
      L.r(eM),
        L.d(eM, {
          Any: function () {
            return rT;
          },
          BaseBlock: function () {
            return tM;
          },
          BaseStringBlock: function () {
            return tL;
          },
          BitString: function () {
            return tX;
          },
          BmpString: function () {
            return ru;
          },
          Boolean: function () {
            return tq;
          },
          CharacterString: function () {
            return rk;
          },
          Choice: function () {
            return rN;
          },
          Constructed: function () {
            return tV;
          },
          DATE: function () {
            return rP;
          },
          DateTime: function () {
            return rC;
          },
          Duration: function () {
            return rB;
          },
          EndOfContent: function () {
            return tJ;
          },
          Enumerated: function () {
            return t8;
          },
          GeneralString: function () {
            return rv;
          },
          GeneralizedTime: function () {
            return rS;
          },
          GraphicString: function () {
            return rA;
          },
          HexBlock: function () {
            return tB;
          },
          IA5String: function () {
            return rm;
          },
          Integer: function () {
            return t4;
          },
          Null: function () {
            return tz;
          },
          NumericString: function () {
            return rp;
          },
          ObjectIdentifier: function () {
            return t7;
          },
          OctetString: function () {
            return tY;
          },
          Primitive: function () {
            return t_;
          },
          PrintableString: function () {
            return rf;
          },
          RawData: function () {
            return rI;
          },
          RelativeObjectIdentifier: function () {
            return rt;
          },
          Repeated: function () {
            return rR;
          },
          Sequence: function () {
            return rr;
          },
          Set: function () {
            return rn;
          },
          TIME: function () {
            return rO;
          },
          TeletexString: function () {
            return rg;
          },
          TimeOfDay: function () {
            return rx;
          },
          UTCTime: function () {
            return rE;
          },
          UniversalString: function () {
            return rd;
          },
          Utf8String: function () {
            return rl;
          },
          ValueBlock: function () {
            return tT;
          },
          VideotexString: function () {
            return ry;
          },
          ViewWriter: function () {
            return ta;
          },
          VisibleString: function () {
            return rw;
          },
          compareSchema: function () {
            return rM;
          },
          fromBER: function () {
            return tj;
          },
          verifySchema: function () {
            return rU;
          },
        });
      var eU = L(2067),
        eL = L(48902),
        eD = L(30410),
        e_ = (O) =>
          (eD.Buffer.isBuffer(O) ? O : eD.Buffer.from(O))
            .toString("base64")
            .replace(/\+/g, "-")
            .replace(/\//g, "_")
            .replace(/=/g, ""),
        eF = {
          encryption: {
            saltBits: 256,
            algorithm: "aes-256-cbc",
            iterations: 1,
            minPasswordlength: 32,
          },
          integrity: {
            saltBits: 256,
            algorithm: "sha256",
            iterations: 1,
            minPasswordlength: 32,
          },
          ttl: 0,
          timestampSkewSec: 60,
          localtimeOffsetMsec: 0,
        },
        eK = (O) => ({
          ...O,
          encryption: { ...O.encryption },
          integrity: { ...O.integrity },
        }),
        ej = {
          "aes-128-ctr": { keyBits: 128, ivBits: 128, name: "AES-CTR" },
          "aes-256-cbc": { keyBits: 256, ivBits: 128, name: "AES-CBC" },
          sha256: { keyBits: 256, name: "SHA-256" },
        },
        eH = "2",
        e$ = `Fe26.${eH}`,
        eV = (O, T) => {
          let L = eD.Buffer.allocUnsafe(T);
          return O.getRandomValues(L), L;
        },
        eG = (O, T) => {
          if (T < 1) throw Error("Invalid random bits count");
          return eV(O, Math.ceil(T / 8));
        },
        eJ = async (O, T, L, J, W, Y) => {
          let Z = new TextEncoder(),
            X = Z.encode(T),
            ee = await O.subtle.importKey("raw", X, "PBKDF2", !1, [
              "deriveBits",
            ]),
            et = { name: "PBKDF2", hash: Y, salt: Z.encode(L), iterations: J },
            er = await O.subtle.deriveBits(et, ee, 8 * W);
          return eD.Buffer.from(er);
        },
        ez = async (O, T, L) => {
          var J;
          if (null == T || !T.length) throw Error("Empty password");
          if (null == L || "object" != typeof L) throw Error("Bad options");
          if (!(L.algorithm in ej))
            throw Error(`Unknown algorithm: ${L.algorithm}`);
          let W = ej[L.algorithm],
            Y = {},
            Z = null != (J = L.hmac) && J,
            X = Z ? { name: "HMAC", hash: W.name } : { name: W.name },
            ee = Z ? ["sign", "verify"] : ["encrypt", "decrypt"];
          if ("string" == typeof T) {
            if (T.length < L.minPasswordlength)
              throw Error(
                `Password string too short (min ${L.minPasswordlength} characters required)`
              );
            let { salt: J = "" } = L;
            if (!J) {
              let { saltBits: T = 0 } = L;
              if (!T) throw Error("Missing salt and saltBits options");
              J = eG(O, T).toString("hex");
            }
            let Z = await eJ(O, T, J, L.iterations, W.keyBits / 8, "SHA-1"),
              et = await O.subtle.importKey("raw", Z, X, !1, ee);
            (Y.key = et), (Y.salt = J);
          } else {
            if (T.length < W.keyBits / 8)
              throw Error("Key buffer (password) too small");
            (Y.key = await O.subtle.importKey("raw", T, X, !1, ee)),
              (Y.salt = "");
          }
          return (
            L.iv ? (Y.iv = L.iv) : "ivBits" in W && (Y.iv = eG(O, W.ivBits)), Y
          );
        },
        eQ = async (O, T, L, J) => {
          let W = await ez(O, T, L),
            Y = new TextEncoder().encode(J),
            Z = await O.subtle.encrypt(
              { name: ej[L.algorithm].name, iv: W.iv },
              W.key,
              Y
            );
          return { encrypted: eD.Buffer.from(Z), key: W };
        },
        eq = async (O, T, L, J) => {
          let W = await ez(O, T, L),
            Y = await O.subtle.decrypt(
              { name: ej[L.algorithm].name, iv: W.iv },
              W.key,
              eD.Buffer.isBuffer(J) ? J : eD.Buffer.from(J)
            );
          return new TextDecoder().decode(Y);
        },
        eW = async (O, T, L, J) => {
          let W = await ez(O, T, { ...L, hmac: !0 }),
            Y = new TextEncoder().encode(J),
            Z = await O.subtle.sign({ name: "HMAC" }, W.key, Y);
          return { digest: e_(eD.Buffer.from(Z)), salt: W.salt };
        },
        eY = (O) =>
          "object" != typeof O || eD.Buffer.isBuffer(O)
            ? { encryption: O, integrity: O }
            : "secret" in O
            ? { id: O.id, encryption: O.secret, integrity: O.secret }
            : { id: O.id, encryption: O.encryption, integrity: O.integrity },
        eZ = async (O, T, L, J) => {
          if (!L) throw Error("Empty password");
          let W = eK(J),
            Y = Date.now() + (W.localtimeOffsetMsec || 0),
            Z = JSON.stringify(T),
            X = eY(L),
            { id: ee = "" } = X;
          if (ee && !/^\w+$/.test(ee)) throw Error("Invalid password id");
          let { encrypted: et, key: er } = await eQ(
              O,
              X.encryption,
              W.encryption,
              Z
            ),
            en = e_(et),
            es = e_(er.iv),
            ei = W.ttl ? Y + W.ttl : "",
            ea = `${e$}*${ee}*${er.salt}*${es}*${en}*${ei}`,
            eo = await eW(O, X.integrity, W.integrity, ea);
          return `${ea}*${eo.salt}*${eo.digest}`;
        },
        eX = (O, T) => {
          let L = O.length === T.length ? 0 : 1;
          L && (T = O);
          for (let J = 0; J < O.length; J += 1)
            L |= O.charCodeAt(J) ^ T.charCodeAt(J);
          return 0 === L;
        },
        e0 = async (O, T, L, J) => {
          let W;
          if (!L) throw Error("Empty password");
          let Y = eK(J),
            Z = Date.now() + (Y.localtimeOffsetMsec || 0),
            X = T.split("*");
          if (8 !== X.length)
            throw Error("Incorrect number of sealed components");
          let ee = X[0],
            et = X[1],
            er = X[2],
            en = X[3],
            es = X[4],
            ei = X[5],
            ea = X[6],
            eo = X[7],
            ec = `${ee}*${et}*${er}*${en}*${es}*${ei}`;
          if (e$ !== ee) throw Error("Wrong mac prefix");
          if (ei) {
            if (!/^\d+$/.exec(ei)) throw Error("Invalid expiration");
            if (parseInt(ei, 10) <= Z - 1e3 * Y.timestampSkewSec)
              throw Error("Expired seal");
          }
          if (void 0 === L || ("string" == typeof L && 0 === L.length))
            throw Error("Empty password");
          if ("object" != typeof L || eD.Buffer.isBuffer(L)) W = L;
          else {
            if (!((et || "default") in L))
              throw Error(`Cannot find password: ${et}`);
            W = L[et || "default"];
          }
          W = eY(W);
          let eu = Y.integrity;
          if (
            ((eu.salt = ea), !eX((await eW(O, W.integrity, eu, ec)).digest, eo))
          )
            throw Error("Bad hmac value");
          let eh = eD.Buffer.from(es, "base64"),
            ed = Y.encryption;
          (ed.salt = er), (ed.iv = eD.Buffer.from(en, "base64"));
          let ep = await eq(O, W.encryption, ed, eh);
          return ep ? JSON.parse(ep) : null;
        },
        e1 = L(78305),
        e2 = L(89594);
      function e3(O, T) {
        let L = 0;
        if (1 === O.length) return O[0];
        for (let J = O.length - 1; J >= 0; J--)
          L += O[O.length - 1 - J] * Math.pow(2, T * J);
        return L;
      }
      function e4(O, T, L = -1) {
        let J = L,
          W = O,
          Y = 0,
          Z = Math.pow(2, T);
        for (let L = 1; L < 8; L++) {
          if (O < Z) {
            let O;
            if (J < 0) (O = new ArrayBuffer(L)), (Y = L);
            else {
              if (J < L) return new ArrayBuffer(0);
              (O = new ArrayBuffer(J)), (Y = J);
            }
            let Z = new Uint8Array(O);
            for (let O = L - 1; O >= 0; O--) {
              let L = Math.pow(2, O * T);
              (Z[Y - O - 1] = Math.floor(W / L)), (W -= Z[Y - O - 1] * L);
            }
            return O;
          }
          Z *= Math.pow(2, T);
        }
        return new ArrayBuffer(0);
      }
      function e8(...O) {
        let T = 0,
          L = 0;
        for (let L of O) T += L.length;
        let J = new ArrayBuffer(T),
          W = new Uint8Array(J);
        for (let T of O) W.set(T, L), (L += T.length);
        return W;
      }
      function e6() {
        let O = new Uint8Array(this.valueHex);
        if (this.valueHex.byteLength >= 2) {
          let T = 255 === O[0] && 128 & O[1],
            L = 0 === O[0] && (128 & O[1]) == 0;
          (T || L) && this.warnings.push("Needlessly long format");
        }
        let T = new ArrayBuffer(this.valueHex.byteLength),
          L = new Uint8Array(T);
        for (let O = 0; O < this.valueHex.byteLength; O++) L[O] = 0;
        L[0] = 128 & O[0];
        let J = e3(L, 8),
          W = new ArrayBuffer(this.valueHex.byteLength),
          Y = new Uint8Array(W);
        for (let T = 0; T < this.valueHex.byteLength; T++) Y[T] = O[T];
        return (Y[0] &= 127), e3(Y, 8) - J;
      }
      function e5(O) {
        let T = O < 0 ? -1 * O : O,
          L = 128;
        for (let J = 1; J < 8; J++) {
          if (T <= L) {
            if (O < 0) {
              let O = e4(L - T, 8, J),
                W = new Uint8Array(O);
              return (W[0] |= 128), O;
            }
            let W = e4(T, 8, J),
              Y = new Uint8Array(W);
            if (128 & Y[0]) {
              let O = W.slice(0),
                T = new Uint8Array(O);
              (W = new ArrayBuffer(W.byteLength + 1)), (Y = new Uint8Array(W));
              for (let L = 0; L < O.byteLength; L++) Y[L + 1] = T[L];
              Y[0] = 0;
            }
            return W;
          }
          L *= 256;
        }
        return new ArrayBuffer(0);
      }
      function e7(O, T) {
        if (O.byteLength !== T.byteLength) return !1;
        let L = new Uint8Array(O),
          J = new Uint8Array(T);
        for (let O = 0; O < L.length; O++) if (L[O] !== J[O]) return !1;
        return !0;
      }
      function e9(O, T) {
        let L = O.toString(10);
        if (T < L.length) return "";
        let J = T - L.length,
          W = Array(J);
        for (let O = 0; O < J; O++) W[O] = "0";
        return W.join("").concat(L);
      }
      /*!
       * Copyright (c) 2014, GMO GlobalSign
       * Copyright (c) 2015-2022, Peculiar Ventures
       * All rights reserved.
       *
       * Author 2014-2019, Yury Strozhevsky
       *
       * Redistribution and use in source and binary forms, with or without modification,
       * are permitted provided that the following conditions are met:
       *
       * * Redistributions of source code must retain the above copyright notice, this
       *   list of conditions and the following disclaimer.
       *
       * * Redistributions in binary form must reproduce the above copyright notice, this
       *   list of conditions and the following disclaimer in the documentation and/or
       *   other materials provided with the distribution.
       *
       * * Neither the name of the copyright holder nor the names of its
       *   contributors may be used to endorse or promote products derived from
       *   this software without specific prior written permission.
       *
       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
       * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
       * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
       * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
       * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
       * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
       * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
       * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
       * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
       * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
       *
       */ function te() {
        if ("undefined" == typeof BigInt)
          throw Error(
            "BigInt is not defined. Your environment doesn't implement BigInt."
          );
      }
      function tr(O) {
        let T = 0,
          L = 0;
        for (let L = 0; L < O.length; L++) T += O[L].byteLength;
        let J = new Uint8Array(T);
        for (let T = 0; T < O.length; T++) {
          let W = O[T];
          J.set(new Uint8Array(W), L), (L += W.byteLength);
        }
        return J.buffer;
      }
      function tn(O, T, L, J) {
        return T instanceof Uint8Array
          ? T.byteLength
            ? L < 0
              ? ((O.error = "Wrong parameter: inputOffset less than zero"), !1)
              : J < 0
              ? ((O.error = "Wrong parameter: inputLength less than zero"), !1)
              : !(T.byteLength - L - J < 0) ||
                ((O.error =
                  "End of input reached before message was fully decoded (inconsistent offset and length values)"),
                !1)
            : ((O.error = "Wrong parameter: inputBuffer has zero length"), !1)
          : ((O.error = "Wrong parameter: inputBuffer must be 'Uint8Array'"),
            !1);
      }
      class ta {
        constructor() {
          this.items = [];
        }
        write(O) {
          this.items.push(O);
        }
        final() {
          return tr(this.items);
        }
      }
      let tl = [new Uint8Array([1])],
        tc = "0123456789",
        tu = "name",
        th = "valueHexView",
        td = "isHexOnly",
        tp = "idBlock",
        tf = "tagClass",
        tg = "tagNumber",
        ty = "isConstructed",
        tm = "fromBER",
        tb = "toBER",
        tA = "local",
        tw = "",
        tv = new ArrayBuffer(0),
        tE = new Uint8Array(0),
        tS = "EndOfContent",
        tP = "OCTET STRING",
        tC = "BIT STRING";
      function tB(O) {
        var T;
        return (
          ((T = class extends O {
            constructor(...O) {
              var T;
              super(...O);
              let L = O[0] || {};
              (this.isHexOnly =
                null !== (T = L.isHexOnly) && void 0 !== T && T),
                (this.valueHexView = L.valueHex
                  ? e2.vJ.toUint8Array(L.valueHex)
                  : tE);
            }
            get valueHex() {
              return this.valueHexView.slice().buffer;
            }
            set valueHex(O) {
              this.valueHexView = new Uint8Array(O);
            }
            fromBER(O, T, L) {
              let J = O instanceof ArrayBuffer ? new Uint8Array(O) : O;
              if (!tn(this, J, T, L)) return -1;
              let W = T + L;
              return ((this.valueHexView = J.subarray(T, W)),
              this.valueHexView.length)
                ? ((this.blockLength = L), W)
                : (this.warnings.push("Zero buffer length"), T);
            }
            toBER(O = !1) {
              return this.isHexOnly
                ? O
                  ? new ArrayBuffer(this.valueHexView.byteLength)
                  : this.valueHexView.byteLength ===
                    this.valueHexView.buffer.byteLength
                  ? this.valueHexView.buffer
                  : this.valueHexView.slice().buffer
                : ((this.error = "Flag 'isHexOnly' is not set, abort"), tv);
            }
            toJSON() {
              return {
                ...super.toJSON(),
                isHexOnly: this.isHexOnly,
                valueHex: e2.ep.ToHex(this.valueHexView),
              };
            }
          }).NAME = "hexBlock"),
          T
        );
      }
      class tO {
        constructor({
          blockLength: O = 0,
          error: T = tw,
          warnings: L = [],
          valueBeforeDecode: J = tE,
        } = {}) {
          (this.blockLength = O),
            (this.error = T),
            (this.warnings = L),
            (this.valueBeforeDecodeView = e2.vJ.toUint8Array(J));
        }
        static blockName() {
          return this.NAME;
        }
        get valueBeforeDecode() {
          return this.valueBeforeDecodeView.slice().buffer;
        }
        set valueBeforeDecode(O) {
          this.valueBeforeDecodeView = new Uint8Array(O);
        }
        toJSON() {
          return {
            blockName: this.constructor.NAME,
            blockLength: this.blockLength,
            error: this.error,
            warnings: this.warnings,
            valueBeforeDecode: e2.ep.ToHex(this.valueBeforeDecodeView),
          };
        }
      }
      tO.NAME = "baseBlock";
      class tT extends tO {
        fromBER(O, T, L) {
          throw TypeError(
            "User need to make a specific function in a class which extends 'ValueBlock'"
          );
        }
        toBER(O, T) {
          throw TypeError(
            "User need to make a specific function in a class which extends 'ValueBlock'"
          );
        }
      }
      tT.NAME = "valueBlock";
      class tN extends tB(tO) {
        constructor({ idBlock: O = {} } = {}) {
          var T, L, J, W;
          super(),
            O
              ? ((this.isHexOnly =
                  null !== (T = O.isHexOnly) && void 0 !== T && T),
                (this.valueHexView = O.valueHex
                  ? e2.vJ.toUint8Array(O.valueHex)
                  : tE),
                (this.tagClass =
                  null !== (L = O.tagClass) && void 0 !== L ? L : -1),
                (this.tagNumber =
                  null !== (J = O.tagNumber) && void 0 !== J ? J : -1),
                (this.isConstructed =
                  null !== (W = O.isConstructed) && void 0 !== W && W))
              : ((this.tagClass = -1),
                (this.tagNumber = -1),
                (this.isConstructed = !1));
        }
        toBER(O = !1) {
          let T = 0;
          switch (this.tagClass) {
            case 1:
              T |= 0;
              break;
            case 2:
              T |= 64;
              break;
            case 3:
              T |= 128;
              break;
            case 4:
              T |= 192;
              break;
            default:
              return (this.error = "Unknown tag class"), tv;
          }
          if (
            (this.isConstructed && (T |= 32),
            this.tagNumber < 31 && !this.isHexOnly)
          ) {
            let L = new Uint8Array(1);
            if (!O) {
              let O = this.tagNumber;
              (O &= 31), (T |= O), (L[0] = T);
            }
            return L.buffer;
          }
          if (!this.isHexOnly) {
            let L = e4(this.tagNumber, 7),
              J = new Uint8Array(L),
              W = L.byteLength,
              Y = new Uint8Array(W + 1);
            if (((Y[0] = 31 | T), !O)) {
              for (let O = 0; O < W - 1; O++) Y[O + 1] = 128 | J[O];
              Y[W] = J[W - 1];
            }
            return Y.buffer;
          }
          let L = new Uint8Array(this.valueHexView.byteLength + 1);
          if (((L[0] = 31 | T), !O)) {
            let O = this.valueHexView;
            for (let T = 0; T < O.length - 1; T++) L[T + 1] = 128 | O[T];
            L[this.valueHexView.byteLength] = O[O.length - 1];
          }
          return L.buffer;
        }
        fromBER(O, T, L) {
          let J = e2.vJ.toUint8Array(O);
          if (!tn(this, J, T, L)) return -1;
          let W = J.subarray(T, T + L);
          if (0 === W.length) return (this.error = "Zero buffer length"), -1;
          switch (192 & W[0]) {
            case 0:
              this.tagClass = 1;
              break;
            case 64:
              this.tagClass = 2;
              break;
            case 128:
              this.tagClass = 3;
              break;
            case 192:
              this.tagClass = 4;
              break;
            default:
              return (this.error = "Unknown tag class"), -1;
          }
          (this.isConstructed = (32 & W[0]) == 32), (this.isHexOnly = !1);
          let Y = 31 & W[0];
          if (31 !== Y) (this.tagNumber = Y), (this.blockLength = 1);
          else {
            let O = 1,
              T = (this.valueHexView = new Uint8Array(255)),
              L = 255;
            for (; 128 & W[O]; ) {
              if (((T[O - 1] = 127 & W[O]), ++O >= W.length))
                return (
                  (this.error =
                    "End of input reached before message was fully decoded"),
                  -1
                );
              if (O === L) {
                L += 255;
                let O = new Uint8Array(L);
                for (let L = 0; L < T.length; L++) O[L] = T[L];
                T = this.valueHexView = new Uint8Array(L);
              }
            }
            (this.blockLength = O + 1), (T[O - 1] = 127 & W[O]);
            let J = new Uint8Array(O);
            for (let L = 0; L < O; L++) J[L] = T[L];
            (T = this.valueHexView = new Uint8Array(O)).set(J),
              this.blockLength <= 9
                ? (this.tagNumber = e3(T, 7))
                : ((this.isHexOnly = !0),
                  this.warnings.push("Tag too long, represented as hex-coded"));
          }
          if (1 === this.tagClass && this.isConstructed)
            switch (this.tagNumber) {
              case 1:
              case 2:
              case 5:
              case 6:
              case 9:
              case 13:
              case 14:
              case 23:
              case 24:
              case 31:
              case 32:
              case 33:
              case 34:
                return (
                  (this.error = "Constructed encoding used for primitive type"),
                  -1
                );
            }
          return T + this.blockLength;
        }
        toJSON() {
          return {
            ...super.toJSON(),
            tagClass: this.tagClass,
            tagNumber: this.tagNumber,
            isConstructed: this.isConstructed,
          };
        }
      }
      tN.NAME = "identificationBlock";
      class tR extends tO {
        constructor({ lenBlock: O = {} } = {}) {
          var T, L, J;
          super(),
            (this.isIndefiniteForm =
              null !== (T = O.isIndefiniteForm) && void 0 !== T && T),
            (this.longFormUsed =
              null !== (L = O.longFormUsed) && void 0 !== L && L),
            (this.length = null !== (J = O.length) && void 0 !== J ? J : 0);
        }
        fromBER(O, T, L) {
          let J = e2.vJ.toUint8Array(O);
          if (!tn(this, J, T, L)) return -1;
          let W = J.subarray(T, T + L);
          if (0 === W.length) return (this.error = "Zero buffer length"), -1;
          if (255 === W[0])
            return (
              (this.error = "Length block 0xFF is reserved by standard"), -1
            );
          if (((this.isIndefiniteForm = 128 === W[0]), this.isIndefiniteForm))
            return (this.blockLength = 1), T + this.blockLength;
          if (((this.longFormUsed = !!(128 & W[0])), !1 === this.longFormUsed))
            return (
              (this.length = W[0]), (this.blockLength = 1), T + this.blockLength
            );
          let Y = 127 & W[0];
          if (Y > 8) return (this.error = "Too big integer"), -1;
          if (Y + 1 > W.length)
            return (
              (this.error =
                "End of input reached before message was fully decoded"),
              -1
            );
          let Z = T + 1,
            X = J.subarray(Z, Z + Y);
          return (
            0 === X[Y - 1] &&
              this.warnings.push("Needlessly long encoded length"),
            (this.length = e3(X, 8)),
            this.longFormUsed &&
              this.length <= 127 &&
              this.warnings.push("Unnecessary usage of long length form"),
            (this.blockLength = Y + 1),
            T + this.blockLength
          );
        }
        toBER(O = !1) {
          let T, L;
          if (
            (this.length > 127 && (this.longFormUsed = !0),
            this.isIndefiniteForm)
          )
            return (
              (T = new ArrayBuffer(1)),
              !1 === O && ((L = new Uint8Array(T))[0] = 128),
              T
            );
          if (this.longFormUsed) {
            let J = e4(this.length, 8);
            if (J.byteLength > 127) return (this.error = "Too big length"), tv;
            if (((T = new ArrayBuffer(J.byteLength + 1)), O)) return T;
            let W = new Uint8Array(J);
            (L = new Uint8Array(T))[0] = 128 | J.byteLength;
            for (let O = 0; O < J.byteLength; O++) L[O + 1] = W[O];
            return T;
          }
          return (
            (T = new ArrayBuffer(1)),
            !1 === O && ((L = new Uint8Array(T))[0] = this.length),
            T
          );
        }
        toJSON() {
          return {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            longFormUsed: this.longFormUsed,
            length: this.length,
          };
        }
      }
      tR.NAME = "lengthBlock";
      let tI = {};
      class tM extends tO {
        constructor(
          { name: O = tw, optional: T = !1, primitiveSchema: L, ...J } = {},
          W
        ) {
          super(J),
            (this.name = O),
            (this.optional = T),
            L && (this.primitiveSchema = L),
            (this.idBlock = new tN(J)),
            (this.lenBlock = new tR(J)),
            (this.valueBlock = W ? new W(J) : new tT(J));
        }
        fromBER(O, T, L) {
          let J = this.valueBlock.fromBER(
            O,
            T,
            this.lenBlock.isIndefiniteForm ? L : this.lenBlock.length
          );
          return (
            -1 === J
              ? (this.error = this.valueBlock.error)
              : (this.idBlock.error.length ||
                  (this.blockLength += this.idBlock.blockLength),
                this.lenBlock.error.length ||
                  (this.blockLength += this.lenBlock.blockLength),
                this.valueBlock.error.length ||
                  (this.blockLength += this.valueBlock.blockLength)),
            J
          );
        }
        toBER(O, T) {
          let L = T || new ta();
          T || tU(this);
          let J = this.idBlock.toBER(O);
          if ((L.write(J), this.lenBlock.isIndefiniteForm))
            L.write(new Uint8Array([128]).buffer),
              this.valueBlock.toBER(O, L),
              L.write(new ArrayBuffer(2));
          else {
            let T = this.valueBlock.toBER(O);
            this.lenBlock.length = T.byteLength;
            let J = this.lenBlock.toBER(O);
            L.write(J), L.write(T);
          }
          return T ? tv : L.final();
        }
        toJSON() {
          let O = {
            ...super.toJSON(),
            idBlock: this.idBlock.toJSON(),
            lenBlock: this.lenBlock.toJSON(),
            valueBlock: this.valueBlock.toJSON(),
            name: this.name,
            optional: this.optional,
          };
          return (
            this.primitiveSchema &&
              (O.primitiveSchema = this.primitiveSchema.toJSON()),
            O
          );
        }
        toString(O = "ascii") {
          return "ascii" === O
            ? this.onAsciiEncoding()
            : e2.ep.ToHex(this.toBER());
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${e2.ep.ToHex(
            this.valueBlock.valueBeforeDecodeView
          )}`;
        }
        isEqual(O) {
          return (
            this === O ||
            (O instanceof this.constructor && e7(this.toBER(), O.toBER()))
          );
        }
      }
      function tU(O) {
        if (O instanceof tI.Constructed)
          for (let T of O.valueBlock.value)
            tU(T) && (O.lenBlock.isIndefiniteForm = !0);
        return !!O.lenBlock.isIndefiniteForm;
      }
      tM.NAME = "BaseBlock";
      class tL extends tM {
        constructor({ value: O = tw, ...T } = {}, L) {
          super(T, L), O && this.fromString(O);
        }
        getValue() {
          return this.valueBlock.value;
        }
        setValue(O) {
          this.valueBlock.value = O;
        }
        fromBER(O, T, L) {
          let J = this.valueBlock.fromBER(
            O,
            T,
            this.lenBlock.isIndefiniteForm ? L : this.lenBlock.length
          );
          return (
            -1 === J
              ? (this.error = this.valueBlock.error)
              : (this.fromBuffer(this.valueBlock.valueHexView),
                this.idBlock.error.length ||
                  (this.blockLength += this.idBlock.blockLength),
                this.lenBlock.error.length ||
                  (this.blockLength += this.lenBlock.blockLength),
                this.valueBlock.error.length ||
                  (this.blockLength += this.valueBlock.blockLength)),
            J
          );
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
        }
      }
      tL.NAME = "BaseStringBlock";
      class tD extends tB(tT) {
        constructor({ isHexOnly: O = !0, ...T } = {}) {
          super(T), (this.isHexOnly = O);
        }
      }
      tD.NAME = "PrimitiveValueBlock";
      class t_ extends tM {
        constructor(O = {}) {
          super(O, tD), (this.idBlock.isConstructed = !1);
        }
      }
      function tF(O, T) {
        if (O instanceof T) return O;
        let L = new T();
        return (
          (L.idBlock = O.idBlock),
          (L.lenBlock = O.lenBlock),
          (L.warnings = O.warnings),
          (L.valueBeforeDecodeView = O.valueBeforeDecodeView),
          L
        );
      }
      function tK(O, T = 0, L = O.length) {
        let J = T,
          W = new tM({}, tT),
          Y = new tO();
        if (!tn(Y, O, T, L))
          return (W.error = Y.error), { offset: -1, result: W };
        if (!O.subarray(T, T + L).length)
          return (W.error = "Zero buffer length"), { offset: -1, result: W };
        let Z = W.idBlock.fromBER(O, T, L);
        if (
          (W.idBlock.warnings.length && W.warnings.concat(W.idBlock.warnings),
          -1 === Z)
        )
          return (W.error = W.idBlock.error), { offset: -1, result: W };
        if (
          ((T = Z),
          (L -= W.idBlock.blockLength),
          (Z = W.lenBlock.fromBER(O, T, L)),
          W.lenBlock.warnings.length && W.warnings.concat(W.lenBlock.warnings),
          -1 === Z)
        )
          return (W.error = W.lenBlock.error), { offset: -1, result: W };
        if (
          ((T = Z),
          (L -= W.lenBlock.blockLength),
          !W.idBlock.isConstructed && W.lenBlock.isIndefiniteForm)
        )
          return (
            (W.error =
              "Indefinite length form used for primitive encoding form"),
            { offset: -1, result: W }
          );
        let X = tM;
        if (1 === W.idBlock.tagClass) {
          if (W.idBlock.tagNumber >= 37 && !1 === W.idBlock.isHexOnly)
            return (
              (W.error =
                "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard"),
              { offset: -1, result: W }
            );
          switch (W.idBlock.tagNumber) {
            case 0:
              if (W.idBlock.isConstructed && W.lenBlock.length > 0)
                return (
                  (W.error = "Type [UNIVERSAL 0] is reserved"),
                  { offset: -1, result: W }
                );
              X = tI.EndOfContent;
              break;
            case 1:
              X = tI.Boolean;
              break;
            case 2:
              X = tI.Integer;
              break;
            case 3:
              X = tI.BitString;
              break;
            case 4:
              X = tI.OctetString;
              break;
            case 5:
              X = tI.Null;
              break;
            case 6:
              X = tI.ObjectIdentifier;
              break;
            case 10:
              X = tI.Enumerated;
              break;
            case 12:
              X = tI.Utf8String;
              break;
            case 13:
              X = tI.RelativeObjectIdentifier;
              break;
            case 14:
              X = tI.TIME;
              break;
            case 15:
              return (
                (W.error = "[UNIVERSAL 15] is reserved by ASN.1 standard"),
                { offset: -1, result: W }
              );
            case 16:
              X = tI.Sequence;
              break;
            case 17:
              X = tI.Set;
              break;
            case 18:
              X = tI.NumericString;
              break;
            case 19:
              X = tI.PrintableString;
              break;
            case 20:
              X = tI.TeletexString;
              break;
            case 21:
              X = tI.VideotexString;
              break;
            case 22:
              X = tI.IA5String;
              break;
            case 23:
              X = tI.UTCTime;
              break;
            case 24:
              X = tI.GeneralizedTime;
              break;
            case 25:
              X = tI.GraphicString;
              break;
            case 26:
              X = tI.VisibleString;
              break;
            case 27:
              X = tI.GeneralString;
              break;
            case 28:
              X = tI.UniversalString;
              break;
            case 29:
              X = tI.CharacterString;
              break;
            case 30:
              X = tI.BmpString;
              break;
            case 31:
              X = tI.DATE;
              break;
            case 32:
              X = tI.TimeOfDay;
              break;
            case 33:
              X = tI.DateTime;
              break;
            case 34:
              X = tI.Duration;
              break;
            default: {
              let O = W.idBlock.isConstructed
                ? new tI.Constructed()
                : new tI.Primitive();
              (O.idBlock = W.idBlock),
                (O.lenBlock = W.lenBlock),
                (O.warnings = W.warnings),
                (W = O);
            }
          }
        } else X = W.idBlock.isConstructed ? tI.Constructed : tI.Primitive;
        return (
          (Z = (W = tF(W, X)).fromBER(
            O,
            T,
            W.lenBlock.isIndefiniteForm ? L : W.lenBlock.length
          )),
          (W.valueBeforeDecodeView = O.subarray(J, J + W.blockLength)),
          { offset: Z, result: W }
        );
      }
      function tj(O) {
        if (!O.byteLength) {
          let O = new tM({}, tT);
          return (
            (O.error = "Input buffer has zero length"),
            { offset: -1, result: O }
          );
        }
        return tK(e2.vJ.toUint8Array(O).slice(), 0, O.byteLength);
      }
      function tH(O, T) {
        return O ? 1 : T;
      }
      (J = t_),
        (() => {
          tI.Primitive = J;
        })(),
        (t_.NAME = "PRIMITIVE");
      class t$ extends tT {
        constructor({ value: O = [], isIndefiniteForm: T = !1, ...L } = {}) {
          super(L), (this.value = O), (this.isIndefiniteForm = T);
        }
        fromBER(O, T, L) {
          let J = e2.vJ.toUint8Array(O);
          if (!tn(this, J, T, L)) return -1;
          if (
            ((this.valueBeforeDecodeView = J.subarray(T, T + L)),
            0 === this.valueBeforeDecodeView.length)
          )
            return this.warnings.push("Zero buffer length"), T;
          let W = T;
          for (; tH(this.isIndefiniteForm, L) > 0; ) {
            let O = tK(J, W, L);
            if (-1 === O.offset)
              return (
                (this.error = O.result.error),
                this.warnings.concat(O.result.warnings),
                -1
              );
            if (
              ((W = O.offset),
              (this.blockLength += O.result.blockLength),
              (L -= O.result.blockLength),
              this.value.push(O.result),
              this.isIndefiniteForm && O.result.constructor.NAME === tS)
            )
              break;
          }
          return (
            this.isIndefiniteForm &&
              (this.value[this.value.length - 1].constructor.NAME === tS
                ? this.value.pop()
                : this.warnings.push("No EndOfContent block encoded")),
            W
          );
        }
        toBER(O, T) {
          let L = T || new ta();
          for (let T = 0; T < this.value.length; T++) this.value[T].toBER(O, L);
          return T ? tv : L.final();
        }
        toJSON() {
          let O = {
            ...super.toJSON(),
            isIndefiniteForm: this.isIndefiniteForm,
            value: [],
          };
          for (let T of this.value) O.value.push(T.toJSON());
          return O;
        }
      }
      t$.NAME = "ConstructedValueBlock";
      class tV extends tM {
        constructor(O = {}) {
          super(O, t$), (this.idBlock.isConstructed = !0);
        }
        fromBER(O, T, L) {
          this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
          let J = this.valueBlock.fromBER(
            O,
            T,
            this.lenBlock.isIndefiniteForm ? L : this.lenBlock.length
          );
          return (
            -1 === J
              ? (this.error = this.valueBlock.error)
              : (this.idBlock.error.length ||
                  (this.blockLength += this.idBlock.blockLength),
                this.lenBlock.error.length ||
                  (this.blockLength += this.lenBlock.blockLength),
                this.valueBlock.error.length ||
                  (this.blockLength += this.valueBlock.blockLength)),
            J
          );
        }
        onAsciiEncoding() {
          let O = [];
          for (let T of this.valueBlock.value)
            O.push(
              T.toString("ascii")
                .split("\n")
                .map((O) => `  ${O}`)
                .join("\n")
            );
          let T =
            3 === this.idBlock.tagClass
              ? `[${this.idBlock.tagNumber}]`
              : this.constructor.NAME;
          return O.length
            ? `${T} :
${O.join("\n")}`
            : `${T} :`;
        }
      }
      (W = tV),
        (() => {
          tI.Constructed = W;
        })(),
        (tV.NAME = "CONSTRUCTED");
      class tG extends tT {
        fromBER(O, T, L) {
          return T;
        }
        toBER(O) {
          return tv;
        }
      }
      tG.override = "EndOfContentValueBlock";
      class tJ extends tM {
        constructor(O = {}) {
          super(O, tG),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 0);
        }
      }
      (Y = tJ),
        (() => {
          tI.EndOfContent = Y;
        })(),
        (tJ.NAME = tS);
      class tz extends tM {
        constructor(O = {}) {
          super(O, tT),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 5);
        }
        fromBER(O, T, L) {
          return (this.lenBlock.length > 0 &&
            this.warnings.push("Non-zero length of value block for Null type"),
          this.idBlock.error.length ||
            (this.blockLength += this.idBlock.blockLength),
          this.lenBlock.error.length ||
            (this.blockLength += this.lenBlock.blockLength),
          (this.blockLength += L),
          T + L > O.byteLength)
            ? ((this.error =
                "End of input reached before message was fully decoded (inconsistent offset and length values)"),
              -1)
            : T + L;
        }
        toBER(O, T) {
          let L = new ArrayBuffer(2);
          if (!O) {
            let O = new Uint8Array(L);
            (O[0] = 5), (O[1] = 0);
          }
          return T && T.write(L), L;
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME}`;
        }
      }
      (Z = tz),
        (() => {
          tI.Null = Z;
        })(),
        (tz.NAME = "NULL");
      class tQ extends tB(tT) {
        constructor({ value: O, ...T } = {}) {
          super(T),
            T.valueHex
              ? (this.valueHexView = e2.vJ.toUint8Array(T.valueHex))
              : (this.valueHexView = new Uint8Array(1)),
            O && (this.value = O);
        }
        get value() {
          for (let O of this.valueHexView) if (O > 0) return !0;
          return !1;
        }
        set value(O) {
          this.valueHexView[0] = O ? 255 : 0;
        }
        fromBER(O, T, L) {
          let J = e2.vJ.toUint8Array(O);
          return tn(this, J, T, L)
            ? ((this.valueHexView = J.subarray(T, T + L)),
              L > 1 &&
                this.warnings.push(
                  "Boolean value encoded in more then 1 octet"
                ),
              (this.isHexOnly = !0),
              e6.call(this),
              (this.blockLength = L),
              T + L)
            : -1;
        }
        toBER() {
          return this.valueHexView.slice();
        }
        toJSON() {
          return { ...super.toJSON(), value: this.value };
        }
      }
      tQ.NAME = "BooleanValueBlock";
      class tq extends tM {
        constructor(O = {}) {
          super(O, tQ),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 1);
        }
        getValue() {
          return this.valueBlock.value;
        }
        setValue(O) {
          this.valueBlock.value = O;
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.getValue}`;
        }
      }
      (X = tq),
        (() => {
          tI.Boolean = X;
        })(),
        (tq.NAME = "BOOLEAN");
      class tW extends tB(t$) {
        constructor({ isConstructed: O = !1, ...T } = {}) {
          super(T), (this.isConstructed = O);
        }
        fromBER(O, T, L) {
          let J = 0;
          if (this.isConstructed) {
            if (
              ((this.isHexOnly = !1),
              -1 === (J = t$.prototype.fromBER.call(this, O, T, L)))
            )
              return J;
            for (let O = 0; O < this.value.length; O++) {
              let T = this.value[O].constructor.NAME;
              if (T === tS) {
                if (!this.isIndefiniteForm)
                  return (
                    (this.error =
                      "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only"),
                    -1
                  );
                break;
              }
              if (T !== tP)
                return (
                  (this.error =
                    "OCTET STRING may consists of OCTET STRINGs only"),
                  -1
                );
            }
          } else
            (this.isHexOnly = !0),
              (J = super.fromBER(O, T, L)),
              (this.blockLength = L);
          return J;
        }
        toBER(O, T) {
          return this.isConstructed
            ? t$.prototype.toBER.call(this, O, T)
            : O
            ? new ArrayBuffer(this.valueHexView.byteLength)
            : this.valueHexView.slice().buffer;
        }
        toJSON() {
          return { ...super.toJSON(), isConstructed: this.isConstructed };
        }
      }
      tW.NAME = "OctetStringValueBlock";
      class tY extends tM {
        constructor({ idBlock: O = {}, lenBlock: T = {}, ...L } = {}) {
          var J, W;
          (null !== (J = L.isConstructed) && void 0 !== J) ||
            (L.isConstructed = !!(null === (W = L.value) || void 0 === W
              ? void 0
              : W.length)),
            super(
              {
                idBlock: { isConstructed: L.isConstructed, ...O },
                lenBlock: { ...T, isIndefiniteForm: !!L.isIndefiniteForm },
                ...L,
              },
              tW
            ),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 4);
        }
        fromBER(O, T, L) {
          if (
            ((this.valueBlock.isConstructed = this.idBlock.isConstructed),
            (this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm),
            0 === L)
          )
            return (
              0 === this.idBlock.error.length &&
                (this.blockLength += this.idBlock.blockLength),
              0 === this.lenBlock.error.length &&
                (this.blockLength += this.lenBlock.blockLength),
              T
            );
          if (!this.valueBlock.isConstructed) {
            let J = (O instanceof ArrayBuffer ? new Uint8Array(O) : O).subarray(
              T,
              T + L
            );
            try {
              if (J.byteLength) {
                let O = tK(J, 0, J.byteLength);
                -1 !== O.offset &&
                  O.offset === L &&
                  (this.valueBlock.value = [O.result]);
              }
            } catch (O) {}
          }
          return super.fromBER(O, T, L);
        }
        onAsciiEncoding() {
          return this.valueBlock.isConstructed ||
            (this.valueBlock.value && this.valueBlock.value.length)
            ? tV.prototype.onAsciiEncoding.call(this)
            : `${this.constructor.NAME} : ${e2.ep.ToHex(
                this.valueBlock.valueHexView
              )}`;
        }
        getValue() {
          if (!this.idBlock.isConstructed)
            return this.valueBlock.valueHexView.slice().buffer;
          let O = [];
          for (let T of this.valueBlock.value)
            T instanceof tY && O.push(T.valueBlock.valueHexView);
          return e2.vJ.concat(O);
        }
      }
      (ee = tY),
        (() => {
          tI.OctetString = ee;
        })(),
        (tY.NAME = tP);
      class tZ extends tB(t$) {
        constructor({ unusedBits: O = 0, isConstructed: T = !1, ...L } = {}) {
          super(L),
            (this.unusedBits = O),
            (this.isConstructed = T),
            (this.blockLength = this.valueHexView.byteLength);
        }
        fromBER(O, T, L) {
          if (!L) return T;
          let J = -1;
          if (this.isConstructed) {
            if (-1 === (J = t$.prototype.fromBER.call(this, O, T, L))) return J;
            for (let O of this.value) {
              let T = O.constructor.NAME;
              if (T === tS) {
                if (!this.isIndefiniteForm)
                  return (
                    (this.error =
                      "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only"),
                    -1
                  );
                break;
              }
              if (T !== tC)
                return (
                  (this.error = "BIT STRING may consists of BIT STRINGs only"),
                  -1
                );
              let L = O.valueBlock;
              if (this.unusedBits > 0 && L.unusedBits > 0)
                return (
                  (this.error =
                    'Using of "unused bits" inside constructive BIT STRING allowed for least one only'),
                  -1
                );
              this.unusedBits = L.unusedBits;
            }
            return J;
          }
          let W = e2.vJ.toUint8Array(O);
          if (!tn(this, W, T, L)) return -1;
          let Y = W.subarray(T, T + L);
          if (((this.unusedBits = Y[0]), this.unusedBits > 7))
            return (
              (this.error = "Unused bits for BitString must be in range 0-7"),
              -1
            );
          if (!this.unusedBits) {
            let O = Y.subarray(1);
            try {
              if (O.byteLength) {
                let T = tK(O, 0, O.byteLength);
                -1 !== T.offset &&
                  T.offset === L - 1 &&
                  (this.value = [T.result]);
              }
            } catch (O) {}
          }
          return (
            (this.valueHexView = Y.subarray(1)),
            (this.blockLength = Y.length),
            T + L
          );
        }
        toBER(O, T) {
          if (this.isConstructed) return t$.prototype.toBER.call(this, O, T);
          if (O) return new ArrayBuffer(this.valueHexView.byteLength + 1);
          if (!this.valueHexView.byteLength) return tv;
          let L = new Uint8Array(this.valueHexView.length + 1);
          return (
            (L[0] = this.unusedBits), L.set(this.valueHexView, 1), L.buffer
          );
        }
        toJSON() {
          return {
            ...super.toJSON(),
            unusedBits: this.unusedBits,
            isConstructed: this.isConstructed,
          };
        }
      }
      tZ.NAME = "BitStringValueBlock";
      class tX extends tM {
        constructor({ idBlock: O = {}, lenBlock: T = {}, ...L } = {}) {
          var J, W;
          (null !== (J = L.isConstructed) && void 0 !== J) ||
            (L.isConstructed = !!(null === (W = L.value) || void 0 === W
              ? void 0
              : W.length)),
            super(
              {
                idBlock: { isConstructed: L.isConstructed, ...O },
                lenBlock: { ...T, isIndefiniteForm: !!L.isIndefiniteForm },
                ...L,
              },
              tZ
            ),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 3);
        }
        fromBER(O, T, L) {
          return (
            (this.valueBlock.isConstructed = this.idBlock.isConstructed),
            (this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm),
            super.fromBER(O, T, L)
          );
        }
        onAsciiEncoding() {
          if (
            this.valueBlock.isConstructed ||
            (this.valueBlock.value && this.valueBlock.value.length)
          )
            return tV.prototype.onAsciiEncoding.call(this);
          {
            let O = [];
            for (let T of this.valueBlock.valueHexView)
              O.push(T.toString(2).padStart(8, "0"));
            let T = O.join("");
            return `${this.constructor.NAME} : ${T.substring(
              0,
              T.length - this.valueBlock.unusedBits
            )}`;
          }
        }
      }
      function t0(O, T) {
        let L = new Uint8Array([0]),
          J = new Uint8Array(O),
          W = new Uint8Array(T),
          Y = J.slice(0),
          Z = Y.length - 1,
          X = W.slice(0),
          ee = X.length - 1,
          et = 0,
          er = ee < Z ? Z : ee,
          en = 0;
        for (let O = er; O >= 0; O--, en++)
          (et =
            !0 == en < X.length
              ? Y[Z - en] + X[ee - en] + L[0]
              : Y[Z - en] + L[0]),
            ((L[0] = et / 10), !0 == en >= Y.length)
              ? (Y = e8(new Uint8Array([et % 10]), Y))
              : (Y[Z - en] = et % 10);
        return L[0] > 0 && (Y = e8(L, Y)), Y;
      }
      function t1(O) {
        if (O >= tl.length)
          for (let T = tl.length; T <= O; T++) {
            let O = new Uint8Array([0]),
              L = tl[T - 1].slice(0);
            for (let T = L.length - 1; T >= 0; T--) {
              let J = new Uint8Array([(L[T] << 1) + O[0]]);
              (O[0] = J[0] / 10), (L[T] = J[0] % 10);
            }
            O[0] > 0 && (L = e8(O, L)), tl.push(L);
          }
        return tl[O];
      }
      function t2(O, T) {
        let L,
          J = 0,
          W = new Uint8Array(O),
          Y = new Uint8Array(T),
          Z = W.slice(0),
          X = Z.length - 1,
          ee = Y.slice(0),
          et = ee.length - 1,
          er = 0;
        for (let O = et; O >= 0; O--, er++)
          !0 == (L = Z[X - er] - ee[et - er] - J) < 0
            ? ((J = 1), (Z[X - er] = L + 10))
            : ((J = 0), (Z[X - er] = L));
        if (J > 0)
          for (let O = X - et + 1; O >= 0; O--, er++)
            if ((L = Z[X - er] - J) < 0) (J = 1), (Z[X - er] = L + 10);
            else {
              (J = 0), (Z[X - er] = L);
              break;
            }
        return Z.slice();
      }
      (et = tX),
        (() => {
          tI.BitString = et;
        })(),
        (tX.NAME = tC);
      class t3 extends tB(tT) {
        constructor({ value: O, ...T } = {}) {
          super(T),
            (this._valueDec = 0),
            T.valueHex && this.setValueHex(),
            void 0 !== O && (this.valueDec = O);
        }
        setValueHex() {
          this.valueHexView.length >= 4
            ? (this.warnings.push("Too big Integer for decoding, hex only"),
              (this.isHexOnly = !0),
              (this._valueDec = 0))
            : ((this.isHexOnly = !1),
              this.valueHexView.length > 0 && (this._valueDec = e6.call(this)));
        }
        set valueDec(O) {
          (this._valueDec = O),
            (this.isHexOnly = !1),
            (this.valueHexView = new Uint8Array(e5(O)));
        }
        get valueDec() {
          return this._valueDec;
        }
        fromDER(O, T, L, J = 0) {
          let W = this.fromBER(O, T, L);
          if (-1 === W) return W;
          let Y = this.valueHexView;
          return (
            0 === Y[0] && (128 & Y[1]) != 0
              ? (this.valueHexView = Y.subarray(1))
              : 0 !== J &&
                Y.length < J &&
                (J - Y.length > 1 && (J = Y.length + 1),
                (this.valueHexView = Y.subarray(J - Y.length))),
            W
          );
        }
        toDER(O = !1) {
          let T = this.valueHexView;
          switch (!0) {
            case (128 & T[0]) != 0:
              {
                let O = new Uint8Array(this.valueHexView.length + 1);
                (O[0] = 0), O.set(T, 1), (this.valueHexView = O);
              }
              break;
            case 0 === T[0] && (128 & T[1]) == 0:
              this.valueHexView = this.valueHexView.subarray(1);
          }
          return this.toBER(O);
        }
        fromBER(O, T, L) {
          let J = super.fromBER(O, T, L);
          return -1 === J || this.setValueHex(), J;
        }
        toBER(O) {
          return O
            ? new ArrayBuffer(this.valueHexView.length)
            : this.valueHexView.slice().buffer;
        }
        toJSON() {
          return { ...super.toJSON(), valueDec: this.valueDec };
        }
        toString() {
          let O;
          let T = 8 * this.valueHexView.length - 1,
            L = new Uint8Array((8 * this.valueHexView.length) / 3),
            J = 0,
            W = this.valueHexView,
            Y = "",
            Z = !1;
          for (let Z = W.byteLength - 1; Z >= 0; Z--) {
            O = W[Z];
            for (let W = 0; W < 8; W++)
              (1 & O) == 1 &&
                (J === T
                  ? ((L = t2(t1(J), L)), (Y = "-"))
                  : (L = t0(L, t1(J)))),
                J++,
                (O >>= 1);
          }
          for (let O = 0; O < L.length; O++)
            L[O] && (Z = !0), Z && (Y += tc.charAt(L[O]));
          return !1 === Z && (Y += tc.charAt(0)), Y;
        }
      }
      (er = t3),
        (t3.NAME = "IntegerValueBlock"),
        (() => {
          Object.defineProperty(er.prototype, "valueHex", {
            set: function (O) {
              (this.valueHexView = new Uint8Array(O)), this.setValueHex();
            },
            get: function () {
              return this.valueHexView.slice().buffer;
            },
          });
        })();
      class t4 extends tM {
        constructor(O = {}) {
          super(O, t3),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 2);
        }
        toBigInt() {
          return te(), BigInt(this.valueBlock.toString());
        }
        static fromBigInt(O) {
          te();
          let T = BigInt(O),
            L = new ta(),
            J = T.toString(16).replace(/^-/, ""),
            W = new Uint8Array(e2.ep.FromHex(J));
          if (T < 0) {
            let O = new Uint8Array(W.length + (128 & W[0] ? 1 : 0));
            O[0] |= 128;
            let J = BigInt(`0x${e2.ep.ToHex(O)}`) + T,
              Y = e2.vJ.toUint8Array(e2.ep.FromHex(J.toString(16)));
            (Y[0] |= 128), L.write(Y);
          } else 128 & W[0] && L.write(new Uint8Array([0])), L.write(W);
          return new t4({ valueHex: L.final() });
        }
        convertToDER() {
          let O = new t4({ valueHex: this.valueBlock.valueHexView });
          return O.valueBlock.toDER(), O;
        }
        convertFromDER() {
          return new t4({
            valueHex:
              0 === this.valueBlock.valueHexView[0]
                ? this.valueBlock.valueHexView.subarray(1)
                : this.valueBlock.valueHexView,
          });
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
        }
      }
      (en = t4),
        (() => {
          tI.Integer = en;
        })(),
        (t4.NAME = "INTEGER");
      class t8 extends t4 {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 10);
        }
      }
      (es = t8),
        (() => {
          tI.Enumerated = es;
        })(),
        (t8.NAME = "ENUMERATED");
      class t6 extends tB(tT) {
        constructor({ valueDec: O = -1, isFirstSid: T = !1, ...L } = {}) {
          super(L), (this.valueDec = O), (this.isFirstSid = T);
        }
        fromBER(O, T, L) {
          if (!L) return T;
          let J = e2.vJ.toUint8Array(O);
          if (!tn(this, J, T, L)) return -1;
          let W = J.subarray(T, T + L);
          this.valueHexView = new Uint8Array(L);
          for (
            let O = 0;
            O < L &&
            ((this.valueHexView[O] = 127 & W[O]),
            this.blockLength++,
            (128 & W[O]) != 0);
            O++
          );
          let Y = new Uint8Array(this.blockLength);
          for (let O = 0; O < this.blockLength; O++)
            Y[O] = this.valueHexView[O];
          return ((this.valueHexView = Y), (128 & W[this.blockLength - 1]) != 0)
            ? ((this.error =
                "End of input reached before message was fully decoded"),
              -1)
            : (0 === this.valueHexView[0] &&
                this.warnings.push("Needlessly long format of SID encoding"),
              this.blockLength <= 8
                ? (this.valueDec = e3(this.valueHexView, 7))
                : ((this.isHexOnly = !0),
                  this.warnings.push("Too big SID for decoding, hex only")),
              T + this.blockLength);
        }
        set valueBigInt(O) {
          te();
          let T = BigInt(O).toString(2);
          for (; T.length % 7; ) T = "0" + T;
          let L = new Uint8Array(T.length / 7);
          for (let O = 0; O < L.length; O++)
            L[O] =
              parseInt(T.slice(7 * O, 7 * O + 7), 2) +
              (O + 1 < L.length ? 128 : 0);
          this.fromBER(L.buffer, 0, L.length);
        }
        toBER(O) {
          if (this.isHexOnly) {
            if (O) return new ArrayBuffer(this.valueHexView.byteLength);
            let T = this.valueHexView,
              L = new Uint8Array(this.blockLength);
            for (let O = 0; O < this.blockLength - 1; O++) L[O] = 128 | T[O];
            return (
              (L[this.blockLength - 1] = T[this.blockLength - 1]), L.buffer
            );
          }
          let T = e4(this.valueDec, 7);
          if (0 === T.byteLength)
            return (this.error = "Error during encoding SID value"), tv;
          let L = new Uint8Array(T.byteLength);
          if (!O) {
            let O = new Uint8Array(T),
              J = T.byteLength - 1;
            for (let T = 0; T < J; T++) L[T] = 128 | O[T];
            L[J] = O[J];
          }
          return L;
        }
        toString() {
          let O = "";
          if (this.isHexOnly) O = e2.ep.ToHex(this.valueHexView);
          else if (this.isFirstSid) {
            let T = this.valueDec;
            this.valueDec <= 39
              ? (O = "0.")
              : this.valueDec <= 79
              ? ((O = "1."), (T -= 40))
              : ((O = "2."), (T -= 80)),
              (O += T.toString());
          } else O = this.valueDec.toString();
          return O;
        }
        toJSON() {
          return {
            ...super.toJSON(),
            valueDec: this.valueDec,
            isFirstSid: this.isFirstSid,
          };
        }
      }
      t6.NAME = "sidBlock";
      class t5 extends tT {
        constructor({ value: O = tw, ...T } = {}) {
          super(T), (this.value = []), O && this.fromString(O);
        }
        fromBER(O, T, L) {
          let J = T;
          for (; L > 0; ) {
            let T = new t6();
            if (-1 === (J = T.fromBER(O, J, L))) {
              (this.blockLength = 0), (this.error = T.error);
              break;
            }
            0 === this.value.length && (T.isFirstSid = !0),
              (this.blockLength += T.blockLength),
              (L -= T.blockLength),
              this.value.push(T);
          }
          return J;
        }
        toBER(O) {
          let T = [];
          for (let L = 0; L < this.value.length; L++) {
            let J = this.value[L].toBER(O);
            if (0 === J.byteLength)
              return (this.error = this.value[L].error), tv;
            T.push(J);
          }
          return tr(T);
        }
        fromString(O) {
          this.value = [];
          let T = 0,
            L = 0,
            J = "",
            W = !1;
          do
            if (
              ((J =
                -1 === (L = O.indexOf(".", T))
                  ? O.substring(T)
                  : O.substring(T, L)),
              (T = L + 1),
              W)
            ) {
              let O = this.value[0],
                T = 0;
              switch (O.valueDec) {
                case 0:
                  break;
                case 1:
                  T = 40;
                  break;
                case 2:
                  T = 80;
                  break;
                default:
                  this.value = [];
                  return;
              }
              let L = parseInt(J, 10);
              if (isNaN(L)) return;
              (O.valueDec = L + T), (W = !1);
            } else {
              let O = new t6();
              if (J > Number.MAX_SAFE_INTEGER) {
                te();
                let T = BigInt(J);
                O.valueBigInt = T;
              } else if (((O.valueDec = parseInt(J, 10)), isNaN(O.valueDec)))
                return;
              this.value.length || ((O.isFirstSid = !0), (W = !0)),
                this.value.push(O);
            }
          while (-1 !== L);
        }
        toString() {
          let O = "",
            T = !1;
          for (let L = 0; L < this.value.length; L++) {
            T = this.value[L].isHexOnly;
            let J = this.value[L].toString();
            0 !== L && (O = `${O}.`),
              T
                ? ((J = `{${J}}`),
                  this.value[L].isFirstSid ? (O = `2.{${J} - 80}`) : (O += J))
                : (O += J);
          }
          return O;
        }
        toJSON() {
          let O = { ...super.toJSON(), value: this.toString(), sidArray: [] };
          for (let T = 0; T < this.value.length; T++)
            O.sidArray.push(this.value[T].toJSON());
          return O;
        }
      }
      t5.NAME = "ObjectIdentifierValueBlock";
      class t7 extends tM {
        constructor(O = {}) {
          super(O, t5),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 6);
        }
        getValue() {
          return this.valueBlock.toString();
        }
        setValue(O) {
          this.valueBlock.fromString(O);
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${
            this.valueBlock.toString() || "empty"
          }`;
        }
        toJSON() {
          return { ...super.toJSON(), value: this.getValue() };
        }
      }
      (ei = t7),
        (() => {
          tI.ObjectIdentifier = ei;
        })(),
        (t7.NAME = "OBJECT IDENTIFIER");
      class t9 extends tB(tO) {
        constructor({ valueDec: O = 0, ...T } = {}) {
          super(T), (this.valueDec = O);
        }
        fromBER(O, T, L) {
          if (0 === L) return T;
          let J = e2.vJ.toUint8Array(O);
          if (!tn(this, J, T, L)) return -1;
          let W = J.subarray(T, T + L);
          this.valueHexView = new Uint8Array(L);
          for (
            let O = 0;
            O < L &&
            ((this.valueHexView[O] = 127 & W[O]),
            this.blockLength++,
            (128 & W[O]) != 0);
            O++
          );
          let Y = new Uint8Array(this.blockLength);
          for (let O = 0; O < this.blockLength; O++)
            Y[O] = this.valueHexView[O];
          return ((this.valueHexView = Y), (128 & W[this.blockLength - 1]) != 0)
            ? ((this.error =
                "End of input reached before message was fully decoded"),
              -1)
            : (0 === this.valueHexView[0] &&
                this.warnings.push("Needlessly long format of SID encoding"),
              this.blockLength <= 8
                ? (this.valueDec = e3(this.valueHexView, 7))
                : ((this.isHexOnly = !0),
                  this.warnings.push("Too big SID for decoding, hex only")),
              T + this.blockLength);
        }
        toBER(O) {
          if (this.isHexOnly) {
            if (O) return new ArrayBuffer(this.valueHexView.byteLength);
            let T = this.valueHexView,
              L = new Uint8Array(this.blockLength);
            for (let O = 0; O < this.blockLength - 1; O++) L[O] = 128 | T[O];
            return (
              (L[this.blockLength - 1] = T[this.blockLength - 1]), L.buffer
            );
          }
          let T = e4(this.valueDec, 7);
          if (0 === T.byteLength)
            return (this.error = "Error during encoding SID value"), tv;
          let L = new Uint8Array(T.byteLength);
          if (!O) {
            let O = new Uint8Array(T),
              J = T.byteLength - 1;
            for (let T = 0; T < J; T++) L[T] = 128 | O[T];
            L[J] = O[J];
          }
          return L.buffer;
        }
        toString() {
          return this.isHexOnly
            ? e2.ep.ToHex(this.valueHexView)
            : this.valueDec.toString();
        }
        toJSON() {
          return { ...super.toJSON(), valueDec: this.valueDec };
        }
      }
      t9.NAME = "relativeSidBlock";
      class re extends tT {
        constructor({ value: O = tw, ...T } = {}) {
          super(T), (this.value = []), O && this.fromString(O);
        }
        fromBER(O, T, L) {
          let J = T;
          for (; L > 0; ) {
            let T = new t9();
            if (-1 === (J = T.fromBER(O, J, L))) {
              (this.blockLength = 0), (this.error = T.error);
              break;
            }
            (this.blockLength += T.blockLength),
              (L -= T.blockLength),
              this.value.push(T);
          }
          return J;
        }
        toBER(O, T) {
          let L = [];
          for (let T = 0; T < this.value.length; T++) {
            let J = this.value[T].toBER(O);
            if (0 === J.byteLength)
              return (this.error = this.value[T].error), tv;
            L.push(J);
          }
          return tr(L);
        }
        fromString(O) {
          this.value = [];
          let T = 0,
            L = 0,
            J = "";
          do {
            (J =
              -1 === (L = O.indexOf(".", T))
                ? O.substring(T)
                : O.substring(T, L)),
              (T = L + 1);
            let W = new t9();
            if (((W.valueDec = parseInt(J, 10)), isNaN(W.valueDec))) break;
            this.value.push(W);
          } while (-1 !== L);
          return !0;
        }
        toString() {
          let O = "",
            T = !1;
          for (let L = 0; L < this.value.length; L++) {
            T = this.value[L].isHexOnly;
            let J = this.value[L].toString();
            0 !== L && (O = `${O}.`), T ? (O += J = `{${J}}`) : (O += J);
          }
          return O;
        }
        toJSON() {
          let O = { ...super.toJSON(), value: this.toString(), sidArray: [] };
          for (let T = 0; T < this.value.length; T++)
            O.sidArray.push(this.value[T].toJSON());
          return O;
        }
      }
      re.NAME = "RelativeObjectIdentifierValueBlock";
      class rt extends tM {
        constructor(O = {}) {
          super(O, re),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 13);
        }
        getValue() {
          return this.valueBlock.toString();
        }
        setValue(O) {
          this.valueBlock.fromString(O);
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${
            this.valueBlock.toString() || "empty"
          }`;
        }
        toJSON() {
          return { ...super.toJSON(), value: this.getValue() };
        }
      }
      (ea = rt),
        (() => {
          tI.RelativeObjectIdentifier = ea;
        })(),
        (rt.NAME = "RelativeObjectIdentifier");
      class rr extends tV {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 16);
        }
      }
      (eo = rr),
        (() => {
          tI.Sequence = eo;
        })(),
        (rr.NAME = "SEQUENCE");
      class rn extends tV {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 17);
        }
      }
      (ec = rn),
        (() => {
          tI.Set = ec;
        })(),
        (rn.NAME = "SET");
      class rs extends tB(tT) {
        constructor({ ...O } = {}) {
          super(O), (this.isHexOnly = !0), (this.value = tw);
        }
        toJSON() {
          return { ...super.toJSON(), value: this.value };
        }
      }
      rs.NAME = "StringValueBlock";
      class ri extends rs {}
      ri.NAME = "SimpleStringValueBlock";
      class ra extends tL {
        constructor({ ...O } = {}) {
          super(O, ri);
        }
        fromBuffer(O) {
          this.valueBlock.value = String.fromCharCode.apply(
            null,
            e2.vJ.toUint8Array(O)
          );
        }
        fromString(O) {
          let T = O.length,
            L = (this.valueBlock.valueHexView = new Uint8Array(T));
          for (let J = 0; J < T; J++) L[J] = O.charCodeAt(J);
          this.valueBlock.value = O;
        }
      }
      ra.NAME = "SIMPLE STRING";
      class ro extends ra {
        fromBuffer(O) {
          this.valueBlock.valueHexView = e2.vJ.toUint8Array(O);
          try {
            this.valueBlock.value = e2.ep.ToUtf8String(O);
          } catch (T) {
            this.warnings.push(
              `Error during "decodeURIComponent": ${T}, using raw string`
            ),
              (this.valueBlock.value = e2.ep.ToBinary(O));
          }
        }
        fromString(O) {
          (this.valueBlock.valueHexView = new Uint8Array(
            e2.ep.FromUtf8String(O)
          )),
            (this.valueBlock.value = O);
        }
      }
      ro.NAME = "Utf8StringValueBlock";
      class rl extends ro {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 12);
        }
      }
      (eu = rl),
        (() => {
          tI.Utf8String = eu;
        })(),
        (rl.NAME = "UTF8String");
      class rc extends ra {
        fromBuffer(O) {
          (this.valueBlock.value = e2.ep.ToUtf16String(O)),
            (this.valueBlock.valueHexView = e2.vJ.toUint8Array(O));
        }
        fromString(O) {
          (this.valueBlock.value = O),
            (this.valueBlock.valueHexView = new Uint8Array(
              e2.ep.FromUtf16String(O)
            ));
        }
      }
      rc.NAME = "BmpStringValueBlock";
      class ru extends rc {
        constructor({ ...O } = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 30);
        }
      }
      (eh = ru),
        (() => {
          tI.BmpString = eh;
        })(),
        (ru.NAME = "BMPString");
      class rh extends ra {
        fromBuffer(O) {
          let T = ArrayBuffer.isView(O) ? O.slice().buffer : O.slice(0),
            L = new Uint8Array(T);
          for (let O = 0; O < L.length; O += 4)
            (L[O] = L[O + 3]),
              (L[O + 1] = L[O + 2]),
              (L[O + 2] = 0),
              (L[O + 3] = 0);
          this.valueBlock.value = String.fromCharCode.apply(
            null,
            new Uint32Array(T)
          );
        }
        fromString(O) {
          let T = O.length,
            L = (this.valueBlock.valueHexView = new Uint8Array(4 * T));
          for (let J = 0; J < T; J++) {
            let T = e4(O.charCodeAt(J), 8),
              W = new Uint8Array(T);
            if (W.length > 4) continue;
            let Y = 4 - W.length;
            for (let O = W.length - 1; O >= 0; O--) L[4 * J + O + Y] = W[O];
          }
          this.valueBlock.value = O;
        }
      }
      rh.NAME = "UniversalStringValueBlock";
      class rd extends rh {
        constructor({ ...O } = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 28);
        }
      }
      (ed = rd),
        (() => {
          tI.UniversalString = ed;
        })(),
        (rd.NAME = "UniversalString");
      class rp extends ra {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 18);
        }
      }
      (ep = rp),
        (() => {
          tI.NumericString = ep;
        })(),
        (rp.NAME = "NumericString");
      class rf extends ra {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 19);
        }
      }
      (eg = rf),
        (() => {
          tI.PrintableString = eg;
        })(),
        (rf.NAME = "PrintableString");
      class rg extends ra {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 20);
        }
      }
      (ey = rg),
        (() => {
          tI.TeletexString = ey;
        })(),
        (rg.NAME = "TeletexString");
      class ry extends ra {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 21);
        }
      }
      (em = ry),
        (() => {
          tI.VideotexString = em;
        })(),
        (ry.NAME = "VideotexString");
      class rm extends ra {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 22);
        }
      }
      (eb = rm),
        (() => {
          tI.IA5String = eb;
        })(),
        (rm.NAME = "IA5String");
      class rA extends ra {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 25);
        }
      }
      (eA = rA),
        (() => {
          tI.GraphicString = eA;
        })(),
        (rA.NAME = "GraphicString");
      class rw extends ra {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 26);
        }
      }
      (ew = rw),
        (() => {
          tI.VisibleString = ew;
        })(),
        (rw.NAME = "VisibleString");
      class rv extends ra {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 27);
        }
      }
      (ev = rv),
        (() => {
          tI.GeneralString = ev;
        })(),
        (rv.NAME = "GeneralString");
      class rk extends ra {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 29);
        }
      }
      (ek = rk),
        (() => {
          tI.CharacterString = ek;
        })(),
        (rk.NAME = "CharacterString");
      class rE extends rw {
        constructor({ value: O, valueDate: T, ...L } = {}) {
          if (
            (super(L),
            (this.year = 0),
            (this.month = 0),
            (this.day = 0),
            (this.hour = 0),
            (this.minute = 0),
            (this.second = 0),
            O)
          ) {
            this.fromString(O),
              (this.valueBlock.valueHexView = new Uint8Array(O.length));
            for (let T = 0; T < O.length; T++)
              this.valueBlock.valueHexView[T] = O.charCodeAt(T);
          }
          T &&
            (this.fromDate(T),
            (this.valueBlock.valueHexView = new Uint8Array(this.toBuffer()))),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 23);
        }
        fromBuffer(O) {
          this.fromString(
            String.fromCharCode.apply(null, e2.vJ.toUint8Array(O))
          );
        }
        toBuffer() {
          let O = this.toString(),
            T = new ArrayBuffer(O.length),
            L = new Uint8Array(T);
          for (let T = 0; T < O.length; T++) L[T] = O.charCodeAt(T);
          return T;
        }
        fromDate(O) {
          (this.year = O.getUTCFullYear()),
            (this.month = O.getUTCMonth() + 1),
            (this.day = O.getUTCDate()),
            (this.hour = O.getUTCHours()),
            (this.minute = O.getUTCMinutes()),
            (this.second = O.getUTCSeconds());
        }
        toDate() {
          return new Date(
            Date.UTC(
              this.year,
              this.month - 1,
              this.day,
              this.hour,
              this.minute,
              this.second
            )
          );
        }
        fromString(O) {
          let T = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(O);
          if (null === T) {
            this.error = "Wrong input string for conversion";
            return;
          }
          let L = parseInt(T[1], 10);
          L >= 50 ? (this.year = 1900 + L) : (this.year = 2e3 + L),
            (this.month = parseInt(T[2], 10)),
            (this.day = parseInt(T[3], 10)),
            (this.hour = parseInt(T[4], 10)),
            (this.minute = parseInt(T[5], 10)),
            (this.second = parseInt(T[6], 10));
        }
        toString(O = "iso") {
          if ("iso" === O) {
            let O = Array(7);
            return (
              (O[0] = e9(
                this.year < 2e3 ? this.year - 1900 : this.year - 2e3,
                2
              )),
              (O[1] = e9(this.month, 2)),
              (O[2] = e9(this.day, 2)),
              (O[3] = e9(this.hour, 2)),
              (O[4] = e9(this.minute, 2)),
              (O[5] = e9(this.second, 2)),
              (O[6] = "Z"),
              O.join("")
            );
          }
          return super.toString(O);
        }
        onAsciiEncoding() {
          return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
        }
        toJSON() {
          return {
            ...super.toJSON(),
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second,
          };
        }
      }
      (eE = rE),
        (() => {
          tI.UTCTime = eE;
        })(),
        (rE.NAME = "UTCTime");
      class rS extends rE {
        constructor(O = {}) {
          var T;
          super(O),
            (null !== (T = this.millisecond) && void 0 !== T) ||
              (this.millisecond = 0),
            (this.idBlock.tagClass = 1),
            (this.idBlock.tagNumber = 24);
        }
        fromDate(O) {
          super.fromDate(O), (this.millisecond = O.getUTCMilliseconds());
        }
        toDate() {
          return new Date(
            Date.UTC(
              this.year,
              this.month - 1,
              this.day,
              this.hour,
              this.minute,
              this.second,
              this.millisecond
            )
          );
        }
        fromString(O) {
          let T,
            L = !1,
            J = "",
            W = "",
            Y = 0,
            Z = 0,
            X = 0;
          if ("Z" === O[O.length - 1])
            (J = O.substring(0, O.length - 1)), (L = !0);
          else {
            if (isNaN(new Number(O[O.length - 1]).valueOf()))
              throw Error("Wrong input string for conversion");
            J = O;
          }
          if (L) {
            if (-1 !== J.indexOf("+") || -1 !== J.indexOf("-"))
              throw Error("Wrong input string for conversion");
          } else {
            let O = 1,
              T = J.indexOf("+"),
              L = "";
            if ((-1 === T && ((T = J.indexOf("-")), (O = -1)), -1 !== T)) {
              if (
                ((L = J.substring(T + 1)),
                (J = J.substring(0, T)),
                2 !== L.length && 4 !== L.length)
              )
                throw Error("Wrong input string for conversion");
              let W = parseInt(L.substring(0, 2), 10);
              if (isNaN(W.valueOf()))
                throw Error("Wrong input string for conversion");
              if (((Z = O * W), 4 === L.length)) {
                if (isNaN((W = parseInt(L.substring(2, 4), 10)).valueOf()))
                  throw Error("Wrong input string for conversion");
                X = O * W;
              }
            }
          }
          let ee = J.indexOf(".");
          if ((-1 === ee && (ee = J.indexOf(",")), -1 !== ee)) {
            let O = new Number(`0${J.substring(ee)}`);
            if (isNaN(O.valueOf()))
              throw Error("Wrong input string for conversion");
            (Y = O.valueOf()), (W = J.substring(0, ee));
          } else W = J;
          switch (!0) {
            case 8 === W.length:
              if (((T = /(\d{4})(\d{2})(\d{2})/gi), -1 !== ee))
                throw Error("Wrong input string for conversion");
              break;
            case 10 === W.length:
              if (((T = /(\d{4})(\d{2})(\d{2})(\d{2})/gi), -1 !== ee)) {
                let O = 60 * Y;
                (this.minute = Math.floor(O)),
                  (O = 60 * (O - this.minute)),
                  (this.second = Math.floor(O)),
                  (O = 1e3 * (O - this.second)),
                  (this.millisecond = Math.floor(O));
              }
              break;
            case 12 === W.length:
              if (((T = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi), -1 !== ee)) {
                let O = 60 * Y;
                (this.second = Math.floor(O)),
                  (O = 1e3 * (O - this.second)),
                  (this.millisecond = Math.floor(O));
              }
              break;
            case 14 === W.length:
              if (
                ((T = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi),
                -1 !== ee)
              ) {
                let O = 1e3 * Y;
                this.millisecond = Math.floor(O);
              }
              break;
            default:
              throw Error("Wrong input string for conversion");
          }
          let et = T.exec(W);
          if (null === et) throw Error("Wrong input string for conversion");
          for (let O = 1; O < et.length; O++)
            switch (O) {
              case 1:
                this.year = parseInt(et[O], 10);
                break;
              case 2:
                this.month = parseInt(et[O], 10);
                break;
              case 3:
                this.day = parseInt(et[O], 10);
                break;
              case 4:
                this.hour = parseInt(et[O], 10) + Z;
                break;
              case 5:
                this.minute = parseInt(et[O], 10) + X;
                break;
              case 6:
                this.second = parseInt(et[O], 10);
                break;
              default:
                throw Error("Wrong input string for conversion");
            }
          if (!1 === L) {
            let O = new Date(
              this.year,
              this.month,
              this.day,
              this.hour,
              this.minute,
              this.second,
              this.millisecond
            );
            (this.year = O.getUTCFullYear()),
              (this.month = O.getUTCMonth()),
              (this.day = O.getUTCDay()),
              (this.hour = O.getUTCHours()),
              (this.minute = O.getUTCMinutes()),
              (this.second = O.getUTCSeconds()),
              (this.millisecond = O.getUTCMilliseconds());
          }
        }
        toString(O = "iso") {
          if ("iso" === O) {
            let O = [];
            return (
              O.push(e9(this.year, 4)),
              O.push(e9(this.month, 2)),
              O.push(e9(this.day, 2)),
              O.push(e9(this.hour, 2)),
              O.push(e9(this.minute, 2)),
              O.push(e9(this.second, 2)),
              0 !== this.millisecond &&
                (O.push("."), O.push(e9(this.millisecond, 3))),
              O.push("Z"),
              O.join("")
            );
          }
          return super.toString(O);
        }
        toJSON() {
          return { ...super.toJSON(), millisecond: this.millisecond };
        }
      }
      (eS = rS),
        (() => {
          tI.GeneralizedTime = eS;
        })(),
        (rS.NAME = "GeneralizedTime");
      class rP extends rl {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 31);
        }
      }
      (eP = rP),
        (() => {
          tI.DATE = eP;
        })(),
        (rP.NAME = "DATE");
      class rx extends rl {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 32);
        }
      }
      (eC = rx),
        (() => {
          tI.TimeOfDay = eC;
        })(),
        (rx.NAME = "TimeOfDay");
      class rC extends rl {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 33);
        }
      }
      (eB = rC),
        (() => {
          tI.DateTime = eB;
        })(),
        (rC.NAME = "DateTime");
      class rB extends rl {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 34);
        }
      }
      (eO = rB),
        (() => {
          tI.Duration = eO;
        })(),
        (rB.NAME = "Duration");
      class rO extends rl {
        constructor(O = {}) {
          super(O), (this.idBlock.tagClass = 1), (this.idBlock.tagNumber = 14);
        }
      }
      (eT = rO),
        (() => {
          tI.TIME = eT;
        })(),
        (rO.NAME = "TIME");
      class rT {
        constructor({ name: O = tw, optional: T = !1 } = {}) {
          (this.name = O), (this.optional = T);
        }
      }
      class rN extends rT {
        constructor({ value: O = [], ...T } = {}) {
          super(T), (this.value = O);
        }
      }
      class rR extends rT {
        constructor({ value: O = new rT(), local: T = !1, ...L } = {}) {
          super(L), (this.value = O), (this.local = T);
        }
      }
      class rI {
        constructor({ data: O = tE } = {}) {
          this.dataView = e2.vJ.toUint8Array(O);
        }
        get data() {
          return this.dataView.slice().buffer;
        }
        set data(O) {
          this.dataView = e2.vJ.toUint8Array(O);
        }
        fromBER(O, T, L) {
          let J = T + L;
          return (this.dataView = e2.vJ.toUint8Array(O).subarray(T, J)), J;
        }
        toBER(O) {
          return this.dataView.slice().buffer;
        }
      }
      function rM(O, T, L) {
        if (L instanceof rN) {
          for (let J = 0; J < L.value.length; J++)
            if (rM(O, T, L.value[J]).verified)
              return { verified: !0, result: O };
          {
            let O = {
              verified: !1,
              result: { error: "Wrong values for Choice type" },
            };
            return L.hasOwnProperty(tu) && (O.name = L.name), O;
          }
        }
        if (L instanceof rT)
          return (
            L.hasOwnProperty(tu) && (O[L.name] = T), { verified: !0, result: O }
          );
        if (O instanceof Object == !1)
          return { verified: !1, result: { error: "Wrong root object" } };
        if (T instanceof Object == !1)
          return { verified: !1, result: { error: "Wrong ASN.1 data" } };
        if (
          L instanceof Object == !1 ||
          tp in L == !1 ||
          tm in L.idBlock == !1 ||
          tb in L.idBlock == !1
        )
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        let J = L.idBlock.toBER(!1);
        if (0 === J.byteLength)
          return {
            verified: !1,
            result: { error: "Error encoding idBlock for ASN.1 schema" },
          };
        if (-1 === L.idBlock.fromBER(J, 0, J.byteLength))
          return {
            verified: !1,
            result: { error: "Error decoding idBlock for ASN.1 schema" },
          };
        if (!1 === L.idBlock.hasOwnProperty(tf))
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (L.idBlock.tagClass !== T.idBlock.tagClass)
          return { verified: !1, result: O };
        if (!1 === L.idBlock.hasOwnProperty(tg))
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (L.idBlock.tagNumber !== T.idBlock.tagNumber)
          return { verified: !1, result: O };
        if (!1 === L.idBlock.hasOwnProperty(ty))
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (L.idBlock.isConstructed !== T.idBlock.isConstructed)
          return { verified: !1, result: O };
        if (!(td in L.idBlock))
          return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
        if (L.idBlock.isHexOnly !== T.idBlock.isHexOnly)
          return { verified: !1, result: O };
        if (L.idBlock.isHexOnly) {
          if (th in L.idBlock == !1)
            return { verified: !1, result: { error: "Wrong ASN.1 schema" } };
          let J = L.idBlock.valueHexView,
            W = T.idBlock.valueHexView;
          if (J.length !== W.length) return { verified: !1, result: O };
          for (let T = 0; T < J.length; T++)
            if (J[T] !== W[1]) return { verified: !1, result: O };
        }
        if (
          (L.name &&
            ((L.name = L.name.replace(/^\s+|\s+$/g, tw)),
            L.name && (O[L.name] = T)),
          L instanceof tI.Constructed)
        ) {
          let J = 0,
            W = { verified: !1, result: { error: "Unknown error" } },
            Y = L.valueBlock.value.length;
          if (
            (Y > 0 &&
              L.valueBlock.value[0] instanceof rR &&
              (Y = T.valueBlock.value.length),
            0 === Y)
          )
            return { verified: !0, result: O };
          if (
            0 === T.valueBlock.value.length &&
            0 !== L.valueBlock.value.length
          ) {
            let T = !0;
            for (let O = 0; O < L.valueBlock.value.length; O++)
              T = T && (L.valueBlock.value[O].optional || !1);
            return T
              ? { verified: !0, result: O }
              : (L.name &&
                  ((L.name = L.name.replace(/^\s+|\s+$/g, tw)),
                  L.name && delete O[L.name]),
                (O.error = "Inconsistent object length"),
                { verified: !1, result: O });
          }
          for (let Z = 0; Z < Y; Z++)
            if (Z - J >= T.valueBlock.value.length) {
              if (!1 === L.valueBlock.value[Z].optional) {
                let T = { verified: !1, result: O };
                return (
                  (O.error =
                    "Inconsistent length between ASN.1 data and schema"),
                  L.name &&
                    ((L.name = L.name.replace(/^\s+|\s+$/g, tw)),
                    L.name && (delete O[L.name], (T.name = L.name))),
                  T
                );
              }
            } else if (L.valueBlock.value[0] instanceof rR) {
              if (
                !1 ===
                (W = rM(O, T.valueBlock.value[Z], L.valueBlock.value[0].value))
                  .verified
              ) {
                if (!L.valueBlock.value[0].optional)
                  return (
                    L.name &&
                      ((L.name = L.name.replace(/^\s+|\s+$/g, tw)),
                      L.name && delete O[L.name]),
                    W
                  );
                J++;
              }
              if (
                tu in L.valueBlock.value[0] &&
                L.valueBlock.value[0].name.length > 0
              ) {
                let J = {};
                void 0 ===
                  (J =
                    tA in L.valueBlock.value[0] && L.valueBlock.value[0].local
                      ? T
                      : O)[L.valueBlock.value[0].name] &&
                  (J[L.valueBlock.value[0].name] = []),
                  J[L.valueBlock.value[0].name].push(T.valueBlock.value[Z]);
              }
            } else if (
              !1 ===
              (W = rM(O, T.valueBlock.value[Z - J], L.valueBlock.value[Z]))
                .verified
            ) {
              if (!L.valueBlock.value[Z].optional)
                return (
                  L.name &&
                    ((L.name = L.name.replace(/^\s+|\s+$/g, tw)),
                    L.name && delete O[L.name]),
                  W
                );
              J++;
            }
          if (!1 === W.verified) {
            let T = { verified: !1, result: O };
            return (
              L.name &&
                ((L.name = L.name.replace(/^\s+|\s+$/g, tw)),
                L.name && (delete O[L.name], (T.name = L.name))),
              T
            );
          }
          return { verified: !0, result: O };
        }
        if (L.primitiveSchema && th in T.valueBlock) {
          let J = tK(T.valueBlock.valueHexView);
          if (-1 === J.offset) {
            let T = { verified: !1, result: J.result };
            return (
              L.name &&
                ((L.name = L.name.replace(/^\s+|\s+$/g, tw)),
                L.name && (delete O[L.name], (T.name = L.name))),
              T
            );
          }
          return rM(O, J.result, L.primitiveSchema);
        }
        return { verified: !0, result: O };
      }
      function rU(O, T) {
        if (T instanceof Object == !1)
          return { verified: !1, result: { error: "Wrong ASN.1 schema type" } };
        let L = tK(e2.vJ.toUint8Array(O));
        return -1 === L.offset
          ? { verified: !1, result: L.result }
          : rM(L.result, L.result, T);
      }
      !(function (O) {
        (O[(O.Sequence = 0)] = "Sequence"),
          (O[(O.Set = 1)] = "Set"),
          (O[(O.Choice = 2)] = "Choice");
      })(eN || (eN = {})),
        (function (O) {
          (O[(O.Any = 1)] = "Any"),
            (O[(O.Boolean = 2)] = "Boolean"),
            (O[(O.OctetString = 3)] = "OctetString"),
            (O[(O.BitString = 4)] = "BitString"),
            (O[(O.Integer = 5)] = "Integer"),
            (O[(O.Enumerated = 6)] = "Enumerated"),
            (O[(O.ObjectIdentifier = 7)] = "ObjectIdentifier"),
            (O[(O.Utf8String = 8)] = "Utf8String"),
            (O[(O.BmpString = 9)] = "BmpString"),
            (O[(O.UniversalString = 10)] = "UniversalString"),
            (O[(O.NumericString = 11)] = "NumericString"),
            (O[(O.PrintableString = 12)] = "PrintableString"),
            (O[(O.TeletexString = 13)] = "TeletexString"),
            (O[(O.VideotexString = 14)] = "VideotexString"),
            (O[(O.IA5String = 15)] = "IA5String"),
            (O[(O.GraphicString = 16)] = "GraphicString"),
            (O[(O.VisibleString = 17)] = "VisibleString"),
            (O[(O.GeneralString = 18)] = "GeneralString"),
            (O[(O.CharacterString = 19)] = "CharacterString"),
            (O[(O.UTCTime = 20)] = "UTCTime"),
            (O[(O.GeneralizedTime = 21)] = "GeneralizedTime"),
            (O[(O.DATE = 22)] = "DATE"),
            (O[(O.TimeOfDay = 23)] = "TimeOfDay"),
            (O[(O.DateTime = 24)] = "DateTime"),
            (O[(O.Duration = 25)] = "Duration"),
            (O[(O.TIME = 26)] = "TIME"),
            (O[(O.Null = 27)] = "Null");
        })(eR || (eR = {}));
      let rL = {
          fromASN: (O) => (O instanceof tz ? null : O.valueBeforeDecodeView),
          toASN: (O) => {
            if (null === O) return new tz();
            let T = tj(O);
            if (T.result.error) throw Error(T.result.error);
            return T.result;
          },
        },
        rD = {
          fromASN: (O) =>
            O.valueBlock.valueHexView.byteLength >= 4
              ? O.valueBlock.toString()
              : O.valueBlock.valueDec,
          toASN: (O) => new t4({ value: +O }),
        },
        r_ = {
          fromASN: (O) => O.valueBlock.valueDec,
          toASN: (O) => new t8({ value: O }),
        },
        rF = {
          fromASN: (O) => O.valueBlock.valueHexView,
          toASN: (O) => new tX({ valueHex: O }),
        },
        rK = {
          fromASN: (O) => O.valueBlock.toString(),
          toASN: (O) => new t7({ value: O }),
        },
        rj = {
          fromASN: (O) => O.valueBlock.value,
          toASN: (O) => new tq({ value: O }),
        },
        rH = {
          fromASN: (O) => O.valueBlock.valueHexView,
          toASN: (O) => new tY({ valueHex: O }),
        };
      function r$(O) {
        return {
          fromASN: (O) => O.valueBlock.value,
          toASN: (T) => new O({ value: T }),
        };
      }
      let rV = r$(rl),
        rG = r$(ru),
        rJ = r$(rd),
        rz = r$(rp),
        rQ = r$(rf),
        rq = r$(rg),
        rW = r$(ry),
        rY = r$(rm),
        rZ = r$(rA),
        rX = r$(rw),
        r0 = r$(rv),
        r1 = r$(rk),
        r2 = {
          fromASN: (O) => O.toDate(),
          toASN: (O) => new rE({ valueDate: O }),
        },
        r3 = {
          fromASN: (O) => O.toDate(),
          toASN: (O) => new rS({ valueDate: O }),
        },
        r4 = { fromASN: () => null, toASN: () => new tz() };
      function r8(O) {
        switch (O) {
          case eR.Any:
            return rL;
          case eR.BitString:
            return rF;
          case eR.BmpString:
            return rG;
          case eR.Boolean:
            return rj;
          case eR.CharacterString:
            return r1;
          case eR.Enumerated:
            return r_;
          case eR.GeneralString:
            return r0;
          case eR.GeneralizedTime:
            return r3;
          case eR.GraphicString:
            return rZ;
          case eR.IA5String:
            return rY;
          case eR.Integer:
            return rD;
          case eR.Null:
            return r4;
          case eR.NumericString:
            return rz;
          case eR.ObjectIdentifier:
            return rK;
          case eR.OctetString:
            return rH;
          case eR.PrintableString:
            return rQ;
          case eR.TeletexString:
            return rq;
          case eR.UTCTime:
            return r2;
          case eR.UniversalString:
            return rJ;
          case eR.Utf8String:
            return rV;
          case eR.VideotexString:
            return rW;
          case eR.VisibleString:
            return rX;
          default:
            return null;
        }
      }
      function r6(O) {
        return "function" == typeof O && O.prototype
          ? (!!O.prototype.toASN && !!O.prototype.fromASN) || r6(O.prototype)
          : !!(O && "object" == typeof O && "toASN" in O && "fromASN" in O);
      }
      function r5(O) {
        var T;
        if (O) {
          let L = Object.getPrototypeOf(O);
          return (
            (null === (T = null == L ? void 0 : L.prototype) || void 0 === T
              ? void 0
              : T.constructor) === Array || r5(L)
          );
        }
        return !1;
      }
      function r7(O, T) {
        if (!(O && T) || O.byteLength !== T.byteLength) return !1;
        let L = new Uint8Array(O),
          J = new Uint8Array(T);
        for (let T = 0; T < O.byteLength; T++) if (L[T] !== J[T]) return !1;
        return !0;
      }
      class r9 {
        constructor() {
          this.items = new WeakMap();
        }
        has(O) {
          return this.items.has(O);
        }
        get(O, T = !1) {
          let L = this.items.get(O);
          if (!L)
            throw Error(
              `Cannot get schema for '${O.prototype.constructor.name}' target`
            );
          if (T && !L.schema)
            throw Error(
              `Schema '${O.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`
            );
          return L;
        }
        cache(O) {
          let T = this.get(O);
          T.schema || (T.schema = this.create(O, !0));
        }
        createDefault(O) {
          let T = { type: eN.Sequence, items: {} },
            L = this.findParentSchema(O);
          return (
            L &&
              (Object.assign(T, L),
              (T.items = Object.assign({}, T.items, L.items))),
            T
          );
        }
        create(O, T) {
          let L = this.items.get(O) || this.createDefault(O),
            J = [];
          for (let O in L.items) {
            let W;
            let Y = L.items[O],
              Z = T ? O : "";
            if ("number" == typeof Y.type) {
              let O = eR[Y.type],
                T = eM[O];
              if (!T) throw Error(`Cannot get ASN1 class by name '${O}'`);
              W = new T({ name: Z });
            } else
              r6(Y.type)
                ? (W = new Y.type().toSchema(Z))
                : Y.optional
                ? this.get(Y.type).type === eN.Choice
                  ? (W = new rT({ name: Z }))
                  : ((W = this.create(Y.type, !1)).name = Z)
                : (W = new rT({ name: Z }));
            let X = !!Y.optional || void 0 !== Y.defaultValue;
            if (
              (Y.repeated &&
                ((W.name = ""),
                (W = new ("set" === Y.repeated ? rn : rr)({
                  name: "",
                  value: [new rR({ name: Z, value: W })],
                }))),
              null !== Y.context && void 0 !== Y.context)
            ) {
              if (Y.implicit) {
                if ("number" == typeof Y.type || r6(Y.type)) {
                  let O = Y.repeated ? tV : t_;
                  J.push(
                    new O({
                      name: Z,
                      optional: X,
                      idBlock: { tagClass: 3, tagNumber: Y.context },
                    })
                  );
                } else {
                  this.cache(Y.type);
                  let O = !!Y.repeated,
                    T = O ? W : this.get(Y.type, !0).schema;
                  (T = "valueBlock" in T ? T.valueBlock.value : T.value),
                    J.push(
                      new tV({
                        name: O ? "" : Z,
                        optional: X,
                        idBlock: { tagClass: 3, tagNumber: Y.context },
                        value: T,
                      })
                    );
                }
              } else
                J.push(
                  new tV({
                    optional: X,
                    idBlock: { tagClass: 3, tagNumber: Y.context },
                    value: [W],
                  })
                );
            } else (W.optional = X), J.push(W);
          }
          switch (L.type) {
            case eN.Sequence:
              return new rr({ value: J, name: "" });
            case eN.Set:
              return new rn({ value: J, name: "" });
            case eN.Choice:
              return new rN({ value: J, name: "" });
            default:
              throw Error("Unsupported ASN1 type in use");
          }
        }
        set(O, T) {
          return this.items.set(O, T), this;
        }
        findParentSchema(O) {
          let T = Object.getPrototypeOf(O);
          return T ? this.items.get(T) || this.findParentSchema(T) : null;
        }
      }
      let ne = new r9(),
        nt = (O) => (T) => {
          let L;
          ne.has(T)
            ? (L = ne.get(T))
            : ((L = ne.createDefault(T)), ne.set(T, L)),
            Object.assign(L, O);
        },
        nr = (O) => (T, L) => {
          let J;
          ne.has(T.constructor)
            ? (J = ne.get(T.constructor))
            : ((J = ne.createDefault(T.constructor)), ne.set(T.constructor, J));
          let W = Object.assign({}, O);
          if ("number" == typeof W.type && !W.converter) {
            let J = r8(O.type);
            if (!J)
              throw Error(
                `Cannot get default converter for property '${L}' of ${T.constructor.name}`
              );
            W.converter = J;
          }
          J.items[L] = W;
        };
      class nn extends Error {
        constructor() {
          super(...arguments), (this.schemas = []);
        }
      }
      class ns {
        static parse(O, T) {
          let L = tj(O);
          if (L.result.error) throw Error(L.result.error);
          return this.fromASN(L.result, T);
        }
        static fromASN(O, T) {
          var L;
          try {
            if (r6(T)) return new T().fromASN(O);
            let J = ne.get(T);
            ne.cache(T);
            let W = J.schema;
            if (O.constructor === tV && J.type !== eN.Choice)
              for (let T in ((W = new tV({
                idBlock: { tagClass: 3, tagNumber: O.idBlock.tagNumber },
                value: J.schema.valueBlock.value,
              })),
              J.items))
                delete O[T];
            let Y = rM({}, O, W);
            if (!Y.verified)
              throw new nn(
                `Data does not match to ${T.name} ASN1 schema. ${Y.result.error}`
              );
            let Z = new T();
            if (r5(T)) {
              if (
                !("value" in O.valueBlock && Array.isArray(O.valueBlock.value))
              )
                throw Error(
                  "Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed."
                );
              let L = J.itemType;
              if ("number" != typeof L)
                return T.from(O.valueBlock.value, (O) => this.fromASN(O, L));
              {
                let J = r8(L);
                if (!J)
                  throw Error(
                    `Cannot get default converter for array item of ${T.name} ASN1 schema`
                  );
                return T.from(O.valueBlock.value, (O) => J.fromASN(O));
              }
            }
            for (let O in J.items) {
              let T = Y.result[O];
              if (!T) continue;
              let W = J.items[O],
                X = W.type;
              if ("number" == typeof X || r6(X)) {
                let J =
                  null !== (L = W.converter) && void 0 !== L
                    ? L
                    : r6(X)
                    ? new X()
                    : null;
                if (!J) throw Error("Converter is empty");
                if (W.repeated) {
                  if (W.implicit) {
                    let L = new ("sequence" === W.repeated ? rr : rn)();
                    L.valueBlock = T.valueBlock;
                    let Y = tj(L.toBER(!1));
                    if (-1 === Y.offset)
                      throw Error(
                        `Cannot parse the child item. ${Y.result.error}`
                      );
                    if (
                      !(
                        "value" in Y.result.valueBlock &&
                        Array.isArray(Y.result.valueBlock.value)
                      )
                    )
                      throw Error(
                        "Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed."
                      );
                    let X = Y.result.valueBlock.value;
                    Z[O] = Array.from(X, (O) => J.fromASN(O));
                  } else Z[O] = Array.from(T, (O) => J.fromASN(O));
                } else {
                  let L = T;
                  if (W.implicit) {
                    let O;
                    if (r6(X)) O = new X().toSchema("");
                    else {
                      let T = eR[X],
                        L = eM[T];
                      if (!L)
                        throw Error(
                          `Cannot get '${T}' class from asn1js module`
                        );
                      O = new L();
                    }
                    (O.valueBlock = L.valueBlock), (L = tj(O.toBER(!1)).result);
                  }
                  Z[O] = J.fromASN(L);
                }
              } else if (W.repeated) {
                if (!Array.isArray(T))
                  throw Error(
                    "Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable."
                  );
                Z[O] = Array.from(T, (O) => this.fromASN(O, X));
              } else Z[O] = this.fromASN(T, X);
            }
            return Z;
          } catch (O) {
            throw (O instanceof nn && O.schemas.push(T.name), O);
          }
        }
      }
      class ni {
        static serialize(O) {
          return O instanceof tM ? O.toBER(!1) : this.toASN(O).toBER(!1);
        }
        static toASN(O) {
          let T;
          if (O && "object" == typeof O && r6(O)) return O.toASN();
          if (!(O && "object" == typeof O))
            throw TypeError("Parameter 1 should be type of Object.");
          let L = O.constructor,
            J = ne.get(L);
          ne.cache(L);
          let W = [];
          if (J.itemType) {
            if (!Array.isArray(O))
              throw TypeError("Parameter 1 should be type of Array.");
            if ("number" == typeof J.itemType) {
              let T = r8(J.itemType);
              if (!T)
                throw Error(
                  `Cannot get default converter for array item of ${L.name} ASN1 schema`
                );
              W = O.map((O) => T.toASN(O));
            } else
              W = O.map((O) =>
                this.toAsnItem({ type: J.itemType }, "[]", L, O)
              );
          } else
            for (let T in J.items) {
              let Y = J.items[T],
                Z = O[T];
              if (
                void 0 === Z ||
                Y.defaultValue === Z ||
                ("object" == typeof Y.defaultValue &&
                  "object" == typeof Z &&
                  r7(this.serialize(Y.defaultValue), this.serialize(Z)))
              )
                continue;
              let X = ni.toAsnItem(Y, T, L, Z);
              if ("number" == typeof Y.context) {
                if (Y.implicit) {
                  if (
                    !Y.repeated &&
                    ("number" == typeof Y.type || r6(Y.type))
                  ) {
                    let O = {};
                    (O.valueHex =
                      X instanceof tz
                        ? X.valueBeforeDecodeView
                        : X.valueBlock.toBER()),
                      W.push(
                        new t_({
                          optional: Y.optional,
                          idBlock: { tagClass: 3, tagNumber: Y.context },
                          ...O,
                        })
                      );
                  } else
                    W.push(
                      new tV({
                        optional: Y.optional,
                        idBlock: { tagClass: 3, tagNumber: Y.context },
                        value: X.valueBlock.value,
                      })
                    );
                } else
                  W.push(
                    new tV({
                      optional: Y.optional,
                      idBlock: { tagClass: 3, tagNumber: Y.context },
                      value: [X],
                    })
                  );
              } else Y.repeated ? (W = W.concat(X)) : W.push(X);
            }
          switch (J.type) {
            case eN.Sequence:
              T = new rr({ value: W });
              break;
            case eN.Set:
              T = new rn({ value: W });
              break;
            case eN.Choice:
              if (!W[0])
                throw Error(
                  `Schema '${L.name}' has wrong data. Choice cannot be empty.`
                );
              T = W[0];
          }
          return T;
        }
        static toAsnItem(O, T, L, J) {
          let W;
          if ("number" == typeof O.type) {
            let Y = O.converter;
            if (!Y)
              throw Error(
                `Property '${T}' doesn't have converter for type ${
                  eR[O.type]
                } in schema '${L.name}'`
              );
            if (O.repeated) {
              if (!Array.isArray(J))
                throw TypeError("Parameter 'objProp' should be type of Array.");
              let T = Array.from(J, (O) => Y.toASN(O));
              W = new ("sequence" === O.repeated ? rr : rn)({ value: T });
            } else W = Y.toASN(J);
          } else if (O.repeated) {
            if (!Array.isArray(J))
              throw TypeError("Parameter 'objProp' should be type of Array.");
            let T = Array.from(J, (O) => this.toASN(O));
            W = new ("sequence" === O.repeated ? rr : rn)({ value: T });
          } else W = this.toASN(J);
          return W;
        }
      }
      class na {
        static serialize(O) {
          return ni.serialize(O);
        }
        static parse(O, T) {
          return ns.parse(O, T);
        }
        static toString(O) {
          let T = tj(
            e2.vJ.isBufferSource(O) ? e2.vJ.toArrayBuffer(O) : na.serialize(O)
          );
          if (-1 === T.offset)
            throw Error(`Cannot decode ASN.1 data. ${T.result.error}`);
          return T.result.toString();
        }
      }
      var no = L(26211);
      class nl extends Error {
        constructor(O, T) {
          super(T ? `${O}. See the inner exception for more details.` : O),
            (this.message = O),
            (this.innerError = T);
        }
      }
      class nc extends nl {
        constructor(O, T, L) {
          super(T, L), (this.schema = O);
        }
      }
      class nu extends nc {
        constructor(O, T, L) {
          super(O, `JSON doesn't match to '${O.target.name}' schema. ${T}`, L);
        }
      }
      class nh extends nl {}
      class nd extends nl {
        constructor(O, T, L) {
          super(`Cannot serialize by '${O}' schema. ${T}`, L),
            (this.schemaName = O);
        }
      }
      class np extends nu {
        constructor(O, T, L = {}) {
          super(O, "Some keys doesn't match to schema"),
            (this.keys = T),
            (this.errors = L);
        }
      }
      function ng(O, T) {
        switch (T) {
          case eI.Boolean:
            return "boolean" == typeof O;
          case eI.Number:
            return "number" == typeof O;
          case eI.String:
            return "string" == typeof O;
        }
        return !0;
      }
      function ny(O, T) {
        if (!ng(O, T)) throw TypeError(`Value must be ${eI[T]}`);
      }
      function nm(O) {
        return O && O.prototype
          ? (!!O.prototype.toJSON && !!O.prototype.fromJSON) || nm(O.prototype)
          : !!(O && O.toJSON && O.fromJSON);
      }
      !(function (O) {
        (O[(O.Any = 0)] = "Any"),
          (O[(O.Boolean = 1)] = "Boolean"),
          (O[(O.Number = 2)] = "Number"),
          (O[(O.String = 3)] = "String");
      })(eI || (eI = {}));
      class nA {
        constructor() {
          this.items = new Map();
        }
        has(O) {
          return this.items.has(O) || !!this.findParentSchema(O);
        }
        get(O) {
          let T = this.items.get(O) || this.findParentSchema(O);
          if (!T) throw Error("Cannot get schema for current target");
          return T;
        }
        create(O) {
          let T = { names: {} },
            L = this.findParentSchema(O);
          if (L)
            for (let O in (Object.assign(T, L), (T.names = {}), L.names))
              T.names[O] = Object.assign({}, L.names[O]);
          return (T.target = O), T;
        }
        set(O, T) {
          return this.items.set(O, T), this;
        }
        findParentSchema(O) {
          let T = O.__proto__;
          return T ? this.items.get(T) || this.findParentSchema(T) : null;
        }
      }
      let nw = "default",
        nk = new nA();
      class nE {
        constructor(O) {
          this.pattern = new RegExp(O);
        }
        validate(O) {
          let T = new RegExp(this.pattern.source, this.pattern.flags);
          if ("string" != typeof O)
            throw new nh("Incoming value must be string");
          if (!T.exec(O))
            throw new nh(`Value doesn't match to pattern '${T.toString()}'`);
        }
      }
      class nS {
        constructor(O = Number.MIN_VALUE, T = Number.MAX_VALUE) {
          (this.min = O), (this.max = T);
        }
        validate(O) {
          if ((ny(O, eI.Number), !(this.min <= O && O <= this.max))) {
            let O = this.min === Number.MIN_VALUE ? "MIN" : this.min,
              T = this.max === Number.MAX_VALUE ? "MAX" : this.max;
            throw new nh(`Value doesn't match to diapason [${O},${T}]`);
          }
        }
      }
      class nP {
        constructor(O = Number.MIN_VALUE, T = Number.MAX_VALUE) {
          (this.min = O), (this.max = T);
        }
        validate(O) {
          if ((ny(O, eI.Number), !(this.min < O && O < this.max))) {
            let O = this.min === Number.MIN_VALUE ? "MIN" : this.min,
              T = this.max === Number.MAX_VALUE ? "MAX" : this.max;
            throw new nh(`Value doesn't match to diapason (${O},${T})`);
          }
        }
      }
      class nx {
        constructor(O, T, L) {
          (this.length = O), (this.minLength = T), (this.maxLength = L);
        }
        validate(O) {
          if (void 0 !== this.length) {
            if (O.length !== this.length)
              throw new nh(`Value length must be exactly ${this.length}.`);
            return;
          }
          if (void 0 !== this.minLength && O.length < this.minLength)
            throw new nh(`Value length must be more than ${this.minLength}.`);
          if (void 0 !== this.maxLength && O.length > this.maxLength)
            throw new nh(`Value length must be less than ${this.maxLength}.`);
        }
      }
      class nC {
        constructor(O) {
          this.enumeration = O;
        }
        validate(O) {
          if ((ny(O, eI.String), !this.enumeration.includes(O)))
            throw new nh(
              `Value must be one of ${this.enumeration
                .map((O) => `'${O}'`)
                .join(", ")}`
            );
        }
      }
      class nB {
        static checkValues(O, T) {
          for (let L of Array.isArray(O) ? O : [O])
            for (let J of T.validations)
              J instanceof nx && T.repeated ? J.validate(O) : J.validate(L);
        }
        static checkTypes(O, T) {
          if (T.repeated && !Array.isArray(O))
            throw TypeError("Value must be Array");
          if ("number" == typeof T.type)
            for (let L of Array.isArray(O) ? O : [O]) ny(L, T.type);
        }
        static getSchemaByName(O, T = nw) {
          return { ...O.names[nw], ...O.names[T] };
        }
      }
      class nO extends nB {
        static serialize(O, T, L, J) {
          return JSON.stringify(this.toJSON(O, T), L, J);
        }
        static toJSON(O, T = {}) {
          let L;
          let J = T.targetSchema,
            W = T.schemaName || nw;
          if (nm(O)) return O.toJSON();
          if (Array.isArray(O))
            for (let J of ((L = []), O)) L.push(this.toJSON(J, T));
          else if ("object" == typeof O) {
            if (J && !nk.has(J))
              throw new nl("Cannot get schema for `targetSchema` param");
            if (((J = J || O.constructor), nk.has(J))) {
              let T = nk.get(J);
              L = {};
              let Y = this.getSchemaByName(T, W);
              for (let Z in Y)
                try {
                  let T;
                  let X = Y[Z],
                    ee = O[Z];
                  if (
                    (X.optional && void 0 === ee) ||
                    (void 0 !== X.defaultValue && ee === X.defaultValue)
                  )
                    continue;
                  if (!X.optional && void 0 === ee)
                    throw new nd(J.name, `Property '${Z}' is required.`);
                  (T =
                    "number" == typeof X.type
                      ? X.converter
                        ? X.repeated
                          ? ee.map((T) => X.converter.toJSON(T, O))
                          : X.converter.toJSON(ee, O)
                        : ee
                      : X.repeated
                      ? ee.map((O) => this.toJSON(O, { schemaName: W }))
                      : this.toJSON(ee, { schemaName: W })),
                    this.checkTypes(T, X),
                    this.checkValues(T, X),
                    (L[X.name || Z] = T);
                } catch (O) {
                  if (O instanceof nd) throw O;
                  throw new nd(
                    T.target.name,
                    `Property '${Z}' is wrong. ${O.message}`,
                    O
                  );
                }
            } else
              for (let T in ((L = {}), O))
                L[T] = this.toJSON(O[T], { schemaName: W });
          } else L = O;
          return L;
        }
      }
      class nT extends nB {
        static parse(O, T) {
          let L = JSON.parse(O);
          return this.fromJSON(L, T);
        }
        static fromJSON(O, T) {
          let L = T.targetSchema,
            J = T.schemaName || nw,
            W = new L();
          if (nm(W)) return W.fromJSON(O);
          let Y = nk.get(L),
            Z = this.getSchemaByName(Y, J),
            X = {};
          for (let L in (T.strictProperty &&
            !Array.isArray(O) &&
            nT.checkStrictProperty(O, Z, Y),
          Z))
            try {
              let X = Z[L],
                ee = X.name || L,
                et = O[ee];
              if (void 0 === et && (X.optional || void 0 !== X.defaultValue))
                continue;
              if (!X.optional && void 0 === et)
                throw new nu(Y, `Property '${ee}' is required.`);
              if (
                (this.checkTypes(et, X),
                this.checkValues(et, X),
                "number" == typeof X.type)
              )
                X.converter
                  ? X.repeated
                    ? (W[L] = et.map((O) => X.converter.fromJSON(O, W)))
                    : (W[L] = X.converter.fromJSON(et, W))
                  : (W[L] = et);
              else {
                let O = { ...T, targetSchema: X.type, schemaName: J };
                X.repeated
                  ? (W[L] = et.map((T) => this.fromJSON(T, O)))
                  : (W[L] = this.fromJSON(et, O));
              }
            } catch (O) {
              if (
                (O instanceof nu ||
                  (O = new nu(Y, `Property '${L}' is wrong. ${O.message}`, O)),
                T.strictAllKeys)
              )
                X[L] = O;
              else throw O;
            }
          let ee = Object.keys(X);
          if (ee.length) throw new np(Y, ee, X);
          return W;
        }
        static checkStrictProperty(O, T, L) {
          let J = Object.keys(O),
            W = Object.keys(T),
            Y = [];
          for (let O of J) -1 === W.indexOf(O) && Y.push(O);
          if (Y.length) throw new np(L, Y);
        }
      }
      function nN(O) {
        let T = [];
        return (
          O.pattern && T.push(new nE(O.pattern)),
          (O.type === eI.Number || O.type === eI.Any) &&
            ((void 0 !== O.minInclusive || void 0 !== O.maxInclusive) &&
              T.push(new nS(O.minInclusive, O.maxInclusive)),
            (void 0 !== O.minExclusive || void 0 !== O.maxExclusive) &&
              T.push(new nP(O.minExclusive, O.maxExclusive)),
            void 0 !== O.enumeration && T.push(new nC(O.enumeration))),
          (O.type === eI.String || O.repeated || O.type === eI.Any) &&
            (void 0 !== O.length ||
              void 0 !== O.minLength ||
              void 0 !== O.maxLength) &&
            T.push(new nx(O.length, O.minLength, O.maxLength)),
          T
        );
      }
      let nR =
        (O = {}) =>
        (T, L) => {
          let J, W;
          let Y = `Cannot set type for ${L} property of ${T.constructor.name} schema`;
          nk.has(T.constructor)
            ? (J = nk.get(T.constructor)).target !== T.constructor &&
              ((J = nk.create(T.constructor)), nk.set(T.constructor, J))
            : ((J = nk.create(T.constructor)), nk.set(T.constructor, J));
          let Z = Object.assign({ type: eI.Any, validations: [] }, O);
          if (
            ((Z.validations = nN(Z)),
            "number" != typeof Z.type && !nk.has(Z.type) && !nm(Z.type))
          )
            throw Error(`${Y}. Assigning type doesn't have schema.`);
          for (let T of (W = Array.isArray(O.schema)
            ? O.schema
            : [O.schema || nw]))
            J.names[T] || (J.names[T] = {}), (J.names[T][L] = Z);
        };
      /*!
 Copyright (c) Peculiar Ventures, LLC
*/ class nI extends Error {}
      class nM extends nI {}
      class nU extends nI {
        constructor(O) {
          super(`Unsupported operation: ${O ? `${O}` : ""}`);
        }
      }
      class nL extends nI {}
      class nD extends nI {
        constructor(O) {
          super(`${O}: Missing required property`);
        }
      }
      function n_(O) {
        return "object" == typeof O && "kty" in O;
      }
      class nF {
        async digest(...O) {
          return this.checkDigest.apply(this, O), this.onDigest.apply(this, O);
        }
        checkDigest(O, T) {
          this.checkAlgorithmName(O);
        }
        async onDigest(O, T) {
          throw new nU("digest");
        }
        async generateKey(...O) {
          return (
            this.checkGenerateKey.apply(this, O),
            this.onGenerateKey.apply(this, O)
          );
        }
        checkGenerateKey(O, T, L, ...J) {
          let W;
          if (
            (this.checkAlgorithmName(O),
            this.checkGenerateKeyParams(O),
            !(L && L.length))
          )
            throw TypeError("Usages cannot be empty when creating a key.");
          (W = Array.isArray(this.usages)
            ? this.usages
            : this.usages.privateKey.concat(this.usages.publicKey)),
            this.checkKeyUsages(L, W);
        }
        checkGenerateKeyParams(O) {}
        async onGenerateKey(O, T, L, ...J) {
          throw new nU("generateKey");
        }
        async sign(...O) {
          return this.checkSign.apply(this, O), this.onSign.apply(this, O);
        }
        checkSign(O, T, L, ...J) {
          this.checkAlgorithmName(O),
            this.checkAlgorithmParams(O),
            this.checkCryptoKey(T, "sign");
        }
        async onSign(O, T, L, ...J) {
          throw new nU("sign");
        }
        async verify(...O) {
          return this.checkVerify.apply(this, O), this.onVerify.apply(this, O);
        }
        checkVerify(O, T, L, J, ...W) {
          this.checkAlgorithmName(O),
            this.checkAlgorithmParams(O),
            this.checkCryptoKey(T, "verify");
        }
        async onVerify(O, T, L, J, ...W) {
          throw new nU("verify");
        }
        async encrypt(...O) {
          return (
            this.checkEncrypt.apply(this, O), this.onEncrypt.apply(this, O)
          );
        }
        checkEncrypt(O, T, L, J = {}, ...W) {
          this.checkAlgorithmName(O),
            this.checkAlgorithmParams(O),
            this.checkCryptoKey(T, J.keyUsage ? "encrypt" : void 0);
        }
        async onEncrypt(O, T, L, ...J) {
          throw new nU("encrypt");
        }
        async decrypt(...O) {
          return (
            this.checkDecrypt.apply(this, O), this.onDecrypt.apply(this, O)
          );
        }
        checkDecrypt(O, T, L, J = {}, ...W) {
          this.checkAlgorithmName(O),
            this.checkAlgorithmParams(O),
            this.checkCryptoKey(T, J.keyUsage ? "decrypt" : void 0);
        }
        async onDecrypt(O, T, L, ...J) {
          throw new nU("decrypt");
        }
        async deriveBits(...O) {
          return (
            this.checkDeriveBits.apply(this, O),
            this.onDeriveBits.apply(this, O)
          );
        }
        checkDeriveBits(O, T, L, J = {}, ...W) {
          if (
            (this.checkAlgorithmName(O),
            this.checkAlgorithmParams(O),
            this.checkCryptoKey(T, J.keyUsage ? "deriveBits" : void 0),
            L % 8 != 0)
          )
            throw new nL("length: Is not multiple of 8");
        }
        async onDeriveBits(O, T, L, ...J) {
          throw new nU("deriveBits");
        }
        async exportKey(...O) {
          return (
            this.checkExportKey.apply(this, O), this.onExportKey.apply(this, O)
          );
        }
        checkExportKey(O, T, ...L) {
          if ((this.checkKeyFormat(O), this.checkCryptoKey(T), !T.extractable))
            throw new nI("key: Is not extractable");
        }
        async onExportKey(O, T, ...L) {
          throw new nU("exportKey");
        }
        async importKey(...O) {
          return (
            this.checkImportKey.apply(this, O), this.onImportKey.apply(this, O)
          );
        }
        checkImportKey(O, T, L, J, W, ...Y) {
          this.checkKeyFormat(O),
            this.checkKeyData(O, T),
            this.checkAlgorithmName(L),
            this.checkImportParams(L),
            Array.isArray(this.usages) && this.checkKeyUsages(W, this.usages);
        }
        async onImportKey(O, T, L, J, W, ...Y) {
          throw new nU("importKey");
        }
        checkAlgorithmName(O) {
          if (O.name.toLowerCase() !== this.name.toLowerCase())
            throw new nM("Unrecognized name");
        }
        checkAlgorithmParams(O) {}
        checkDerivedKeyParams(O) {}
        checkKeyUsages(O, T) {
          for (let L of O)
            if (-1 === T.indexOf(L))
              throw TypeError(
                "Cannot create a key using the specified key usages"
              );
        }
        checkCryptoKey(O, T) {
          if (
            (this.checkAlgorithmName(O.algorithm),
            T && -1 === O.usages.indexOf(T))
          )
            throw new nI("key does not match that of operation");
        }
        checkRequiredProperty(O, T) {
          if (!(T in O)) throw new nD(T);
        }
        checkHashAlgorithm(O, T) {
          for (let L of T) if (L.toLowerCase() === O.name.toLowerCase()) return;
          throw new nL(`hash: Must be one of ${T.join(", ")}`);
        }
        checkImportParams(O) {}
        checkKeyFormat(O) {
          switch (O) {
            case "raw":
            case "pkcs8":
            case "spki":
            case "jwk":
              break;
            default:
              throw TypeError(
                "format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'"
              );
          }
        }
        checkKeyData(O, T) {
          if (!T)
            throw TypeError(
              "keyData: Cannot be empty on empty on key importing"
            );
          if ("jwk" === O) {
            if (!n_(T)) throw TypeError("keyData: Is not JsonWebToken");
          } else if (!e2.vJ.isBufferSource(T))
            throw TypeError("keyData: Is not ArrayBufferView or ArrayBuffer");
        }
        prepareData(O) {
          return e2.vJ.toArrayBuffer(O);
        }
      }
      class nK extends nF {
        checkGenerateKeyParams(O) {
          if (
            (this.checkRequiredProperty(O, "length"),
            "number" != typeof O.length)
          )
            throw TypeError("length: Is not of type Number");
          switch (O.length) {
            case 128:
            case 192:
            case 256:
              break;
            default:
              throw TypeError("length: Must be 128, 192, or 256");
          }
        }
        checkDerivedKeyParams(O) {
          this.checkGenerateKeyParams(O);
        }
      }
      class nj extends nK {
        constructor() {
          super(...arguments),
            (this.name = "AES-CBC"),
            (this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"]);
        }
        checkAlgorithmParams(O) {
          if (
            (this.checkRequiredProperty(O, "iv"),
            !(O.iv instanceof ArrayBuffer || ArrayBuffer.isView(O.iv)))
          )
            throw TypeError(
              "iv: Is not of type '(ArrayBuffer or ArrayBufferView)'"
            );
          if (16 !== O.iv.byteLength)
            throw TypeError("iv: Must have length 16 bytes");
        }
      }
      class nH extends nK {
        constructor() {
          super(...arguments),
            (this.name = "AES-CMAC"),
            (this.usages = ["sign", "verify"]);
        }
        checkAlgorithmParams(O) {
          if (
            (this.checkRequiredProperty(O, "length"),
            "number" != typeof O.length)
          )
            throw TypeError("length: Is not a Number");
          if (O.length < 1) throw new nL("length: Must be more than 0");
        }
      }
      class n$ extends nK {
        constructor() {
          super(...arguments),
            (this.name = "AES-CTR"),
            (this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"]);
        }
        checkAlgorithmParams(O) {
          if (
            (this.checkRequiredProperty(O, "counter"),
            !(
              O.counter instanceof ArrayBuffer || ArrayBuffer.isView(O.counter)
            ))
          )
            throw TypeError(
              "counter: Is not of type '(ArrayBuffer or ArrayBufferView)'"
            );
          if (16 !== O.counter.byteLength)
            throw TypeError("iv: Must have length 16 bytes");
          if (
            (this.checkRequiredProperty(O, "length"),
            "number" != typeof O.length)
          )
            throw TypeError("length: Is not a Number");
          if (O.length < 1) throw new nL("length: Must be more than 0");
        }
      }
      class nV extends nK {
        constructor() {
          super(...arguments),
            (this.name = "AES-ECB"),
            (this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"]);
        }
      }
      class nG extends nK {
        constructor() {
          super(...arguments),
            (this.name = "AES-GCM"),
            (this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"]);
        }
        checkAlgorithmParams(O) {
          var T;
          if (
            (this.checkRequiredProperty(O, "iv"),
            !(O.iv instanceof ArrayBuffer || ArrayBuffer.isView(O.iv)))
          )
            throw TypeError(
              "iv: Is not of type '(ArrayBuffer or ArrayBufferView)'"
            );
          if (O.iv.byteLength < 1)
            throw new nL(
              "iv: Must have length more than 0 and less than 2^64 - 1"
            );
          switch (
            ((null !== (T = O.tagLength) && void 0 !== T) ||
              (O.tagLength = 128),
            O.tagLength)
          ) {
            case 32:
            case 64:
            case 96:
            case 104:
            case 112:
            case 120:
            case 128:
              break;
            default:
              throw new nL(
                "tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128"
              );
          }
        }
      }
      class nJ extends nK {
        constructor() {
          super(...arguments),
            (this.name = "AES-KW"),
            (this.usages = ["wrapKey", "unwrapKey"]);
        }
      }
      class nz extends nF {
        constructor() {
          super(...arguments),
            (this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"]);
        }
        checkAlgorithmParams(O) {
          if (this.ivSize) {
            if (
              (this.checkRequiredProperty(O, "iv"),
              !(O.iv instanceof ArrayBuffer || ArrayBuffer.isView(O.iv)))
            )
              throw TypeError(
                "iv: Is not of type '(ArrayBuffer or ArrayBufferView)'"
              );
            if (O.iv.byteLength !== this.ivSize)
              throw TypeError(`iv: Must have length ${this.ivSize} bytes`);
          }
        }
        checkGenerateKeyParams(O) {
          if (
            (this.checkRequiredProperty(O, "length"),
            "number" != typeof O.length)
          )
            throw TypeError("length: Is not of type Number");
          if (O.length !== this.keySizeBits)
            throw new nL(`algorithm.length: Must be ${this.keySizeBits}`);
        }
        checkDerivedKeyParams(O) {
          this.checkGenerateKeyParams(O);
        }
      }
      class nQ extends nF {
        constructor() {
          super(...arguments),
            (this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"]);
        }
        checkGenerateKeyParams(O) {
          if (
            (this.checkRequiredProperty(O, "hash"),
            this.checkHashAlgorithm(O.hash, this.hashAlgorithms),
            this.checkRequiredProperty(O, "publicExponent"),
            !(O.publicExponent && O.publicExponent instanceof Uint8Array))
          )
            throw TypeError("publicExponent: Missing or not a Uint8Array");
          let T = e2.ep.ToBase64(O.publicExponent);
          if (!("Aw==" === T || "AQAB" === T))
            throw TypeError("publicExponent: Must be [3] or [1,0,1]");
          if (
            (this.checkRequiredProperty(O, "modulusLength"),
            O.modulusLength % 8 ||
              O.modulusLength < 256 ||
              O.modulusLength > 16384)
          )
            throw TypeError(
              "The modulus length must be a multiple of 8 bits and >= 256 and <= 16384"
            );
        }
        checkImportParams(O) {
          this.checkRequiredProperty(O, "hash"),
            this.checkHashAlgorithm(O.hash, this.hashAlgorithms);
        }
      }
      class nq extends nQ {
        constructor() {
          super(...arguments),
            (this.name = "RSASSA-PKCS1-v1_5"),
            (this.usages = { privateKey: ["sign"], publicKey: ["verify"] });
        }
      }
      class nW extends nQ {
        constructor() {
          super(...arguments),
            (this.name = "RSA-PSS"),
            (this.usages = { privateKey: ["sign"], publicKey: ["verify"] });
        }
        checkAlgorithmParams(O) {
          if (
            (this.checkRequiredProperty(O, "saltLength"),
            "number" != typeof O.saltLength)
          )
            throw TypeError("saltLength: Is not a Number");
          if (O.saltLength < 0)
            throw RangeError("saltLength: Must be positive number");
        }
      }
      class nY extends nQ {
        constructor() {
          super(...arguments),
            (this.name = "RSA-OAEP"),
            (this.usages = {
              privateKey: ["decrypt", "unwrapKey"],
              publicKey: ["encrypt", "wrapKey"],
            });
        }
        checkAlgorithmParams(O) {
          if (
            O.label &&
            !(O.label instanceof ArrayBuffer || ArrayBuffer.isView(O.label))
          )
            throw TypeError(
              "label: Is not of type '(ArrayBuffer or ArrayBufferView)'"
            );
        }
      }
      class nZ extends nF {
        checkGenerateKeyParams(O) {
          this.checkRequiredProperty(O, "namedCurve"),
            this.checkNamedCurve(O.namedCurve);
        }
        checkNamedCurve(O) {
          for (let T of this.namedCurves)
            if (T.toLowerCase() === O.toLowerCase()) return;
          throw new nL(
            `namedCurve: Must be one of ${this.namedCurves.join(", ")}`
          );
        }
      }
      class nX extends nZ {
        constructor() {
          super(...arguments),
            (this.name = "ECDSA"),
            (this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"]),
            (this.usages = { privateKey: ["sign"], publicKey: ["verify"] }),
            (this.namedCurves = ["P-256", "P-384", "P-521", "K-256"]);
        }
        checkAlgorithmParams(O) {
          this.checkRequiredProperty(O, "hash"),
            this.checkHashAlgorithm(O.hash, this.hashAlgorithms);
        }
      }
      let n0 = ["secret", "private", "public"];
      class n3 {
        static create(O, T, L, J) {
          let W = new this();
          return (
            (W.algorithm = O),
            (W.type = T),
            (W.extractable = L),
            (W.usages = J),
            W
          );
        }
        static isKeyType(O) {
          return -1 !== n0.indexOf(O);
        }
        get [Symbol.toStringTag]() {
          return "CryptoKey";
        }
      }
      class n4 extends nZ {
        constructor() {
          super(...arguments),
            (this.name = "ECDH"),
            (this.usages = {
              privateKey: ["deriveBits", "deriveKey"],
              publicKey: [],
            }),
            (this.namedCurves = ["P-256", "P-384", "P-521", "K-256"]);
        }
        checkAlgorithmParams(O) {
          if (
            (this.checkRequiredProperty(O, "public"), !(O.public instanceof n3))
          )
            throw TypeError("public: Is not a CryptoKey");
          if ("public" !== O.public.type)
            throw new nL("public: Is not a public key");
          if (O.public.algorithm.name !== this.name)
            throw new nL(`public: Is not ${this.name} key`);
        }
      }
      class n8 extends n4 {
        constructor() {
          super(...arguments),
            (this.name = "ECDH-ES"),
            (this.namedCurves = ["X25519", "X448"]);
        }
      }
      class n6 extends nZ {
        constructor() {
          super(...arguments),
            (this.name = "EdDSA"),
            (this.usages = { privateKey: ["sign"], publicKey: ["verify"] }),
            (this.namedCurves = ["Ed25519", "Ed448"]);
        }
      }
      let n5 = class {
        constructor(O) {
          O && (this.value = O);
        }
      };
      (0, no.__decorate)(
        [nr({ type: eR.ObjectIdentifier })],
        n5.prototype,
        "value",
        void 0
      ),
        (n5 = (0, no.__decorate)([nt({ type: eN.Choice })], n5));
      class n7 {
        constructor(O) {
          Object.assign(this, O);
        }
      }
      (0, no.__decorate)(
        [nr({ type: eR.ObjectIdentifier })],
        n7.prototype,
        "algorithm",
        void 0
      ),
        (0, no.__decorate)(
          [nr({ type: eR.Any, optional: !0 })],
          n7.prototype,
          "parameters",
          void 0
        );
      class n9 {
        constructor() {
          (this.version = 0),
            (this.privateKeyAlgorithm = new n7()),
            (this.privateKey = new ArrayBuffer(0));
        }
      }
      (0, no.__decorate)(
        [nr({ type: eR.Integer })],
        n9.prototype,
        "version",
        void 0
      ),
        (0, no.__decorate)(
          [nr({ type: n7 })],
          n9.prototype,
          "privateKeyAlgorithm",
          void 0
        ),
        (0, no.__decorate)(
          [nr({ type: eR.OctetString })],
          n9.prototype,
          "privateKey",
          void 0
        ),
        (0, no.__decorate)(
          [nr({ type: eR.Any, optional: !0 })],
          n9.prototype,
          "attributes",
          void 0
        );
      class se {
        constructor() {
          (this.publicKeyAlgorithm = new n7()),
            (this.publicKey = new ArrayBuffer(0));
        }
      }
      (0, no.__decorate)(
        [nr({ type: n7 })],
        se.prototype,
        "publicKeyAlgorithm",
        void 0
      ),
        (0, no.__decorate)(
          [nr({ type: eR.BitString })],
          se.prototype,
          "publicKey",
          void 0
        );
      let sr = {
          fromJSON: (O) => e2.ep.FromBase64Url(O),
          toJSON: (O) => e2.ep.ToBase64Url(new Uint8Array(O)),
        },
        sn = {
          fromASN: (O) => {
            let T = O.valueBlock.valueHex;
            return new Uint8Array(T)[0]
              ? O.valueBlock.valueHex
              : O.valueBlock.valueHex.slice(1);
          },
          toASN: (O) =>
            new t4({
              valueHex:
                new Uint8Array(O)[0] > 127
                  ? (0, e2.$e)(new Uint8Array([0]).buffer, O)
                  : O,
            }),
        };
      class ss {
        constructor() {
          (this.version = 0),
            (this.modulus = new ArrayBuffer(0)),
            (this.publicExponent = new ArrayBuffer(0)),
            (this.privateExponent = new ArrayBuffer(0)),
            (this.prime1 = new ArrayBuffer(0)),
            (this.prime2 = new ArrayBuffer(0)),
            (this.exponent1 = new ArrayBuffer(0)),
            (this.exponent2 = new ArrayBuffer(0)),
            (this.coefficient = new ArrayBuffer(0));
        }
      }
      (0, no.__decorate)(
        [nr({ type: eR.Integer, converter: rD })],
        ss.prototype,
        "version",
        void 0
      ),
        (0, no.__decorate)(
          [
            nr({ type: eR.Integer, converter: sn }),
            nR({ name: "n", converter: sr }),
          ],
          ss.prototype,
          "modulus",
          void 0
        ),
        (0, no.__decorate)(
          [
            nr({ type: eR.Integer, converter: sn }),
            nR({ name: "e", converter: sr }),
          ],
          ss.prototype,
          "publicExponent",
          void 0
        ),
        (0, no.__decorate)(
          [
            nr({ type: eR.Integer, converter: sn }),
            nR({ name: "d", converter: sr }),
          ],
          ss.prototype,
          "privateExponent",
          void 0
        ),
        (0, no.__decorate)(
          [
            nr({ type: eR.Integer, converter: sn }),
            nR({ name: "p", converter: sr }),
          ],
          ss.prototype,
          "prime1",
          void 0
        ),
        (0, no.__decorate)(
          [
            nr({ type: eR.Integer, converter: sn }),
            nR({ name: "q", converter: sr }),
          ],
          ss.prototype,
          "prime2",
          void 0
        ),
        (0, no.__decorate)(
          [
            nr({ type: eR.Integer, converter: sn }),
            nR({ name: "dp", converter: sr }),
          ],
          ss.prototype,
          "exponent1",
          void 0
        ),
        (0, no.__decorate)(
          [
            nr({ type: eR.Integer, converter: sn }),
            nR({ name: "dq", converter: sr }),
          ],
          ss.prototype,
          "exponent2",
          void 0
        ),
        (0, no.__decorate)(
          [
            nr({ type: eR.Integer, converter: sn }),
            nR({ name: "qi", converter: sr }),
          ],
          ss.prototype,
          "coefficient",
          void 0
        ),
        (0, no.__decorate)(
          [nr({ type: eR.Any, optional: !0 })],
          ss.prototype,
          "otherPrimeInfos",
          void 0
        );
      class si {
        constructor() {
          (this.modulus = new ArrayBuffer(0)),
            (this.publicExponent = new ArrayBuffer(0));
        }
      }
      (0, no.__decorate)(
        [
          nr({ type: eR.Integer, converter: sn }),
          nR({ name: "n", converter: sr }),
        ],
        si.prototype,
        "modulus",
        void 0
      ),
        (0, no.__decorate)(
          [
            nr({ type: eR.Integer, converter: sn }),
            nR({ name: "e", converter: sr }),
          ],
          si.prototype,
          "publicExponent",
          void 0
        );
      let sa = class {
        constructor(O) {
          (this.value = new ArrayBuffer(0)), O && (this.value = O);
        }
        toJSON() {
          let O = new Uint8Array(this.value);
          if (4 !== O[0])
            throw new nI(
              "Wrong ECPoint. Current version supports only Uncompressed (0x04) point"
            );
          let T = (O = new Uint8Array(this.value.slice(1))).length / 2,
            L = 0;
          return {
            x: e2.ep.ToBase64Url(O.buffer.slice(L, L + T)),
            y: e2.ep.ToBase64Url(O.buffer.slice(L + T, L + T + T)),
          };
        }
        fromJSON(O) {
          if (!("x" in O)) throw Error("x: Missing required property");
          if (!("y" in O)) throw Error("y: Missing required property");
          let T = e2.ep.FromBase64Url(O.x),
            L = e2.ep.FromBase64Url(O.y),
            J = (0, e2.$e)(new Uint8Array([4]).buffer, T, L);
          return (this.value = new Uint8Array(J).buffer), this;
        }
      };
      (0, no.__decorate)(
        [nr({ type: eR.OctetString })],
        sa.prototype,
        "value",
        void 0
      ),
        (sa = (0, no.__decorate)([nt({ type: eN.Choice })], sa));
      class so {
        constructor() {
          (this.version = 1), (this.privateKey = new ArrayBuffer(0));
        }
        fromJSON(O) {
          if (!("d" in O)) throw Error("d: Missing required property");
          if (((this.privateKey = e2.ep.FromBase64Url(O.d)), "x" in O)) {
            let T = new sa();
            T.fromJSON(O);
            let L = ni.toASN(T);
            "valueHex" in L.valueBlock &&
              (this.publicKey = L.valueBlock.valueHex);
          }
          return this;
        }
        toJSON() {
          let O = {};
          return (
            (O.d = e2.ep.ToBase64Url(this.privateKey)),
            this.publicKey && Object.assign(O, new sa(this.publicKey).toJSON()),
            O
          );
        }
      }
      (0, no.__decorate)(
        [nr({ type: eR.Integer, converter: rD })],
        so.prototype,
        "version",
        void 0
      ),
        (0, no.__decorate)(
          [nr({ type: eR.OctetString })],
          so.prototype,
          "privateKey",
          void 0
        ),
        (0, no.__decorate)(
          [nr({ context: 0, type: eR.Any, optional: !0 })],
          so.prototype,
          "parameters",
          void 0
        ),
        (0, no.__decorate)(
          [nr({ context: 1, type: eR.BitString, optional: !0 })],
          so.prototype,
          "publicKey",
          void 0
        );
      let sl = {
        fromASN: (O) => {
          let T = new Uint8Array(O.valueBlock.valueHex);
          return 0 === T[0] ? T.buffer.slice(1) : T.buffer;
        },
        toASN: (O) => {
          let T = new Uint8Array(O);
          if (T[0] > 127) {
            let O = new Uint8Array(T.length + 1);
            return O.set(T, 1), new t4({ valueHex: O.buffer });
          }
          return new t4({ valueHex: O });
        },
      };
      var sc = Object.freeze({
        __proto__: null,
        AsnIntegerWithoutPaddingConverter: sl,
      });
      class su {
        static decodePoint(O, T) {
          let L = e2.vJ.toUint8Array(O);
          if (0 === L.length || 4 !== L[0])
            throw Error("Only uncompressed point format supported");
          let J = (L.length - 1) / 2;
          if (J !== Math.ceil(T / 8))
            throw Error("Point does not match field size");
          return { x: L.slice(1, J + 1), y: L.slice(J + 1, J + 1 + J) };
        }
        static encodePoint(O, T) {
          let L = Math.ceil(T / 8);
          if (O.x.byteLength !== L || O.y.byteLength !== L)
            throw Error("X,Y coordinates don't match point size criteria");
          let J = e2.vJ.toUint8Array(O.x),
            W = e2.vJ.toUint8Array(O.y),
            Y = new Uint8Array(2 * L + 1);
          return (Y[0] = 4), Y.set(J, 1), Y.set(W, L + 1), Y;
        }
        static getSize(O) {
          return Math.ceil(O / 8);
        }
        static encodeSignature(O, T) {
          let L = this.getSize(T),
            J = e2.vJ.toUint8Array(O.r),
            W = e2.vJ.toUint8Array(O.s),
            Y = new Uint8Array(2 * L);
          return Y.set(this.padStart(J, L)), Y.set(this.padStart(W, L), L), Y;
        }
        static decodeSignature(O, T) {
          let L = this.getSize(T),
            J = e2.vJ.toUint8Array(O);
          if (J.length !== 2 * L)
            throw Error("Incorrect size of the signature");
          let W = J.slice(0, L),
            Y = J.slice(L);
          return { r: this.trimStart(W), s: this.trimStart(Y) };
        }
        static trimStart(O) {
          let T = 0;
          for (; T < O.length - 1 && 0 === O[T]; ) T++;
          return 0 === T ? O : O.slice(T, O.length);
        }
        static padStart(O, T) {
          if (T === O.length) return O;
          let L = new Uint8Array(T);
          return L.set(O, T - O.length), L;
        }
      }
      class sh {
        constructor() {
          (this.r = new ArrayBuffer(0)), (this.s = new ArrayBuffer(0));
        }
        static fromWebCryptoSignature(O) {
          let T = O.byteLength / 2,
            L = su.decodeSignature(O, 8 * T),
            J = new sh();
          return (
            (J.r = e2.vJ.toArrayBuffer(L.r)),
            (J.s = e2.vJ.toArrayBuffer(L.s)),
            J
          );
        }
        toWebCryptoSignature(O) {
          return (
            null != O ||
              (O = 8 * Math.max(this.r.byteLength, this.s.byteLength)),
            su.encodeSignature(this, O).buffer
          );
        }
      }
      (0, no.__decorate)(
        [nr({ type: eR.Integer, converter: sl })],
        sh.prototype,
        "r",
        void 0
      ),
        (0, no.__decorate)(
          [nr({ type: eR.Integer, converter: sl })],
          sh.prototype,
          "s",
          void 0
        );
      class sd extends n9 {}
      (0, no.__decorate)(
        [nr({ context: 1, implicit: !0, type: eR.BitString, optional: !0 })],
        sd.prototype,
        "publicKey",
        void 0
      );
      let sp = class {
        constructor() {
          this.value = new ArrayBuffer(0);
        }
        fromJSON(O) {
          if (!O.d) throw Error("d: Missing required property");
          return (this.value = e2.ep.FromBase64Url(O.d)), this;
        }
        toJSON() {
          return { d: e2.ep.ToBase64Url(this.value) };
        }
      };
      (0, no.__decorate)(
        [nr({ type: eR.OctetString })],
        sp.prototype,
        "value",
        void 0
      ),
        (sp = (0, no.__decorate)([nt({ type: eN.Choice })], sp));
      let sf = class {
        constructor(O) {
          (this.value = new ArrayBuffer(0)), O && (this.value = O);
        }
        toJSON() {
          return { x: e2.ep.ToBase64Url(this.value) };
        }
        fromJSON(O) {
          if (!("x" in O)) throw Error("x: Missing required property");
          return (this.value = e2.ep.FromBase64Url(O.x)), this;
        }
      };
      (0, no.__decorate)(
        [nr({ type: eR.BitString })],
        sf.prototype,
        "value",
        void 0
      ),
        (sf = (0, no.__decorate)([nt({ type: eN.Choice })], sf));
      let sg = class {};
      (0, no.__decorate)(
        [nr({ type: eR.OctetString }), nR({ type: eI.String, converter: sr })],
        sg.prototype,
        "d",
        void 0
      ),
        (sg = (0, no.__decorate)([nt({ type: eN.Choice })], sg));
      let sy = "1.2.840.10045.3.1.7",
        sm = "1.3.132.0",
        sb = `${sm}.34`,
        sA = `${sm}.35`,
        sw = `${sm}.10`,
        sv = "1.3.36.3.3.2.8.1.1",
        sk = `${sv}.1`,
        sE = `${sv}.2`,
        sS = `${sv}.3`,
        sP = `${sv}.4`,
        sx = `${sv}.5`,
        sC = `${sv}.6`,
        sB = `${sv}.7`,
        sO = `${sv}.8`,
        sT = `${sv}.9`,
        sN = `${sv}.10`,
        sR = `${sv}.11`,
        sI = `${sv}.12`,
        sM = `${sv}.13`,
        sU = `${sv}.14`;
      var sL = Object.freeze({
        __proto__: null,
        AlgorithmIdentifier: n7,
        get CurvePrivateKey() {
          return sg;
        },
        EcDsaSignature: sh,
        EcPrivateKey: so,
        get EcPublicKey() {
          return sa;
        },
        get EdPrivateKey() {
          return sp;
        },
        get EdPublicKey() {
          return sf;
        },
        get ObjectIdentifier() {
          return n5;
        },
        OneAsymmetricKey: sd,
        PrivateKeyInfo: n9,
        PublicKeyInfo: se,
        RsaPrivateKey: ss,
        RsaPublicKey: si,
        converters: sc,
        idBrainpoolP160r1: sk,
        idBrainpoolP160t1: sE,
        idBrainpoolP192r1: sS,
        idBrainpoolP192t1: sP,
        idBrainpoolP224r1: sx,
        idBrainpoolP224t1: sC,
        idBrainpoolP256r1: sB,
        idBrainpoolP256t1: sO,
        idBrainpoolP320r1: sT,
        idBrainpoolP320t1: sN,
        idBrainpoolP384r1: sR,
        idBrainpoolP384t1: sI,
        idBrainpoolP512r1: sM,
        idBrainpoolP512t1: sU,
        idEd25519: "1.3.101.112",
        idEd448: "1.3.101.113",
        idEllipticCurve: sm,
        idSecp256k1: sw,
        idSecp256r1: sy,
        idSecp384r1: sb,
        idSecp521r1: sA,
        idVersionOne: sv,
        idX25519: "1.3.101.110",
        idX448: "1.3.101.111",
      });
      class sD {
        constructor() {}
        static register(O) {
          let T = new n5();
          T.value = O.id;
          let L = na.serialize(T);
          this.items.push({ ...O, raw: L }), this.names.push(O.name);
        }
        static find(O) {
          for (let T of ((O = O.toUpperCase()), this.items))
            if (T.name.toUpperCase() === O || T.id.toUpperCase() === O)
              return T;
          return null;
        }
        static get(O) {
          let T = this.find(O);
          if (!T) throw Error(`Unsupported EC named curve '${O}'`);
          return T;
        }
      }
      (sD.items = []),
        (sD.names = []),
        sD.register({ name: "P-256", id: sy, size: 256 }),
        sD.register({ name: "P-384", id: sb, size: 384 }),
        sD.register({ name: "P-521", id: sA, size: 521 }),
        sD.register({ name: "K-256", id: sw, size: 256 }),
        sD.register({ name: "brainpoolP160r1", id: sk, size: 160 }),
        sD.register({ name: "brainpoolP160t1", id: sE, size: 160 }),
        sD.register({ name: "brainpoolP192r1", id: sS, size: 192 }),
        sD.register({ name: "brainpoolP192t1", id: sP, size: 192 }),
        sD.register({ name: "brainpoolP224r1", id: sx, size: 224 }),
        sD.register({ name: "brainpoolP224t1", id: sC, size: 224 }),
        sD.register({ name: "brainpoolP256r1", id: sB, size: 256 }),
        sD.register({ name: "brainpoolP256t1", id: sO, size: 256 }),
        sD.register({ name: "brainpoolP320r1", id: sT, size: 320 }),
        sD.register({ name: "brainpoolP320t1", id: sN, size: 320 }),
        sD.register({ name: "brainpoolP384r1", id: sR, size: 384 }),
        sD.register({ name: "brainpoolP384t1", id: sI, size: 384 }),
        sD.register({ name: "brainpoolP512r1", id: sM, size: 512 }),
        sD.register({ name: "brainpoolP512t1", id: sU, size: 512 });
      class s_ extends nF {
        constructor() {
          super(...arguments),
            (this.name = "HMAC"),
            (this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"]),
            (this.usages = ["sign", "verify"]);
        }
        getDefaultLength(O) {
          switch (O.toUpperCase()) {
            case "SHA-1":
            case "SHA-256":
            case "SHA-384":
            case "SHA-512":
              return 512;
            default:
              throw Error(`Unknown algorithm name '${O}'`);
          }
        }
        checkGenerateKeyParams(O) {
          if (
            (this.checkRequiredProperty(O, "hash"),
            this.checkHashAlgorithm(O.hash, this.hashAlgorithms),
            "length" in O)
          ) {
            if ("number" != typeof O.length)
              throw TypeError("length: Is not a Number");
            if (O.length < 1)
              throw RangeError("length: Number is out of range");
          }
        }
        checkImportParams(O) {
          this.checkRequiredProperty(O, "hash"),
            this.checkHashAlgorithm(O.hash, this.hashAlgorithms);
        }
      }
      class sF extends nF {
        constructor() {
          super(...arguments),
            (this.name = "PBKDF2"),
            (this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"]),
            (this.usages = ["deriveBits", "deriveKey"]);
        }
        checkAlgorithmParams(O) {
          if (
            (this.checkRequiredProperty(O, "hash"),
            this.checkHashAlgorithm(O.hash, this.hashAlgorithms),
            this.checkRequiredProperty(O, "salt"),
            !(O.salt instanceof ArrayBuffer || ArrayBuffer.isView(O.salt)))
          )
            throw TypeError(
              "salt: Is not of type '(ArrayBuffer or ArrayBufferView)'"
            );
          if (
            (this.checkRequiredProperty(O, "iterations"),
            "number" != typeof O.iterations)
          )
            throw TypeError("iterations: Is not a Number");
          if (O.iterations < 1) throw TypeError("iterations: Is less than 1");
        }
        checkImportKey(O, T, L, J, W, ...Y) {
          if ((super.checkImportKey(O, T, L, J, W, ...Y), J))
            throw SyntaxError("extractable: Must be 'false'");
        }
      }
      class sK extends nF {
        constructor() {
          super(...arguments),
            (this.name = "HKDF"),
            (this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"]),
            (this.usages = ["deriveKey", "deriveBits"]);
        }
        checkAlgorithmParams(O) {
          if (
            (this.checkRequiredProperty(O, "hash"),
            this.checkHashAlgorithm(O.hash, this.hashAlgorithms),
            this.checkRequiredProperty(O, "salt"),
            !e2.vJ.isBufferSource(O.salt) ||
              (this.checkRequiredProperty(O, "info"),
              !e2.vJ.isBufferSource(O.info)))
          )
            throw TypeError(
              "salt: Is not of type '(ArrayBuffer or ArrayBufferView)'"
            );
        }
        checkImportKey(O, T, L, J, W, ...Y) {
          if ((super.checkImportKey(O, T, L, J, W, ...Y), J))
            throw SyntaxError("extractable: Must be 'false'");
        }
      }
      class sj extends nF {
        constructor() {
          super(...arguments), (this.usages = []), (this.defaultLength = 0);
        }
        digest(...O) {
          return (
            (O[0] = { length: this.defaultLength, ...O[0] }),
            super.digest.apply(this, O)
          );
        }
        checkDigest(O, T) {
          super.checkDigest(O, T);
          let L = O.length || 0;
          if ("number" != typeof L) throw TypeError("length: Is not a Number");
          if (L < 0) throw TypeError("length: Is negative");
        }
      }
      class sH extends sj {
        constructor() {
          super(...arguments),
            (this.name = "shake128"),
            (this.defaultLength = 16);
        }
      }
      class s$ extends sj {
        constructor() {
          super(...arguments),
            (this.name = "shake256"),
            (this.defaultLength = 32);
        }
      }
      class sV {
        get [Symbol.toStringTag]() {
          return "Crypto";
        }
        randomUUID() {
          let O = this.getRandomValues(new Uint8Array(16));
          (O[6] = (15 & O[6]) | 64), (O[8] = (63 & O[8]) | 128);
          let T = e2.ep.ToHex(O).toLowerCase();
          return `${T.substring(0, 8)}-${T.substring(8, 12)}-${T.substring(
            12,
            16
          )}-${T.substring(16, 20)}-${T.substring(20)}`;
        }
      }
      class sG {
        constructor() {
          this.items = {};
        }
        get(O) {
          return this.items[O.toLowerCase()] || null;
        }
        set(O) {
          this.items[O.name.toLowerCase()] = O;
        }
        removeAt(O) {
          let T = this.get(O.toLowerCase());
          return T && delete this.items[O], T;
        }
        has(O) {
          return !!this.get(O);
        }
        get length() {
          return Object.keys(this.items).length;
        }
        get algorithms() {
          let O = [];
          for (let T in this.items) {
            let L = this.items[T];
            O.push(L.name);
          }
          return O.sort();
        }
      }
      class sJ {
        constructor() {
          this.providers = new sG();
        }
        static isHashedAlgorithm(O) {
          return !!O && "object" == typeof O && "name" in O && "hash" in O;
        }
        get [Symbol.toStringTag]() {
          return "SubtleCrypto";
        }
        async digest(...O) {
          this.checkRequiredArguments(O, 2, "digest");
          let [T, L, ...J] = O,
            W = this.prepareAlgorithm(T),
            Y = e2.vJ.toArrayBuffer(L),
            Z = this.getProvider(W.name);
          return await Z.digest(W, Y, ...J);
        }
        async generateKey(...O) {
          this.checkRequiredArguments(O, 3, "generateKey");
          let [T, L, J, ...W] = O,
            Y = this.prepareAlgorithm(T),
            Z = this.getProvider(Y.name);
          return await Z.generateKey({ ...Y, name: Z.name }, L, J, ...W);
        }
        async sign(...O) {
          this.checkRequiredArguments(O, 3, "sign");
          let [T, L, J, ...W] = O;
          this.checkCryptoKey(L);
          let Y = this.prepareAlgorithm(T),
            Z = e2.vJ.toArrayBuffer(J),
            X = this.getProvider(Y.name);
          return await X.sign({ ...Y, name: X.name }, L, Z, ...W);
        }
        async verify(...O) {
          this.checkRequiredArguments(O, 4, "verify");
          let [T, L, J, W, ...Y] = O;
          this.checkCryptoKey(L);
          let Z = this.prepareAlgorithm(T),
            X = e2.vJ.toArrayBuffer(W),
            ee = e2.vJ.toArrayBuffer(J),
            et = this.getProvider(Z.name);
          return await et.verify({ ...Z, name: et.name }, L, ee, X, ...Y);
        }
        async encrypt(...O) {
          this.checkRequiredArguments(O, 3, "encrypt");
          let [T, L, J, ...W] = O;
          this.checkCryptoKey(L);
          let Y = this.prepareAlgorithm(T),
            Z = e2.vJ.toArrayBuffer(J),
            X = this.getProvider(Y.name);
          return await X.encrypt(
            { ...Y, name: X.name },
            L,
            Z,
            { keyUsage: !0 },
            ...W
          );
        }
        async decrypt(...O) {
          this.checkRequiredArguments(O, 3, "decrypt");
          let [T, L, J, ...W] = O;
          this.checkCryptoKey(L);
          let Y = this.prepareAlgorithm(T),
            Z = e2.vJ.toArrayBuffer(J),
            X = this.getProvider(Y.name);
          return await X.decrypt(
            { ...Y, name: X.name },
            L,
            Z,
            { keyUsage: !0 },
            ...W
          );
        }
        async deriveBits(...O) {
          this.checkRequiredArguments(O, 3, "deriveBits");
          let [T, L, J, ...W] = O;
          this.checkCryptoKey(L);
          let Y = this.prepareAlgorithm(T),
            Z = this.getProvider(Y.name);
          return await Z.deriveBits(
            { ...Y, name: Z.name },
            L,
            J,
            { keyUsage: !0 },
            ...W
          );
        }
        async deriveKey(...O) {
          this.checkRequiredArguments(O, 5, "deriveKey");
          let [T, L, J, W, Y, ...Z] = O,
            X = this.prepareAlgorithm(J);
          this.getProvider(X.name).checkDerivedKeyParams(X);
          let ee = this.prepareAlgorithm(T),
            et = this.getProvider(ee.name);
          et.checkCryptoKey(L, "deriveKey");
          let er = await et.deriveBits(
            { ...ee, name: et.name },
            L,
            J.length || 512,
            { keyUsage: !1 },
            ...Z
          );
          return this.importKey("raw", er, J, W, Y, ...Z);
        }
        async exportKey(...O) {
          this.checkRequiredArguments(O, 2, "exportKey");
          let [T, L, ...J] = O;
          this.checkCryptoKey(L);
          let W = this.getProvider(L.algorithm.name);
          return await W.exportKey(T, L, ...J);
        }
        async importKey(...O) {
          this.checkRequiredArguments(O, 5, "importKey");
          let [T, L, J, W, Y, ...Z] = O,
            X = this.prepareAlgorithm(J),
            ee = this.getProvider(X.name);
          if (-1 !== ["pkcs8", "spki", "raw"].indexOf(T)) {
            let O = e2.vJ.toArrayBuffer(L);
            return ee.importKey(T, O, { ...X, name: ee.name }, W, Y, ...Z);
          }
          if (!L.kty) throw TypeError("keyData: Is not JSON");
          return ee.importKey(T, L, { ...X, name: ee.name }, W, Y, ...Z);
        }
        async wrapKey(O, T, L, J, ...W) {
          let Y = await this.exportKey(O, T, ...W);
          if ("jwk" === O) {
            let O = JSON.stringify(Y);
            Y = e2.ep.FromUtf8String(O);
          }
          let Z = this.prepareAlgorithm(J),
            X = e2.vJ.toArrayBuffer(Y),
            ee = this.getProvider(Z.name);
          return ee.encrypt(
            { ...Z, name: ee.name },
            L,
            X,
            { keyUsage: !1 },
            ...W
          );
        }
        async unwrapKey(O, T, L, J, W, Y, Z, ...X) {
          let ee = this.prepareAlgorithm(J),
            et = e2.vJ.toArrayBuffer(T),
            er = this.getProvider(ee.name),
            en = await er.decrypt(
              { ...ee, name: er.name },
              L,
              et,
              { keyUsage: !1 },
              ...X
            );
          if ("jwk" === O)
            try {
              en = JSON.parse(e2.ep.ToUtf8String(en));
            } catch (T) {
              let O = TypeError("wrappedKey: Is not a JSON");
              throw ((O.internal = T), O);
            }
          return this.importKey(O, en, W, Y, Z, ...X);
        }
        checkRequiredArguments(O, T, L) {
          if (O.length < T)
            throw TypeError(
              `Failed to execute '${L}' on 'SubtleCrypto': ${T} arguments required, but only ${O.length} present`
            );
        }
        prepareAlgorithm(O) {
          if ("string" == typeof O) return { name: O };
          if (sJ.isHashedAlgorithm(O)) {
            let T = { ...O };
            return (T.hash = this.prepareAlgorithm(O.hash)), T;
          }
          return { ...O };
        }
        getProvider(O) {
          let T = this.providers.get(O);
          if (!T) throw new nM("Unrecognized name");
          return T;
        }
        checkCryptoKey(O) {
          if (!(O instanceof n3))
            throw TypeError("Key is not of type 'CryptoKey'");
        }
      }
      var sz = L(94785),
        sQ = L.n(sz),
        sq = L(26182);
      /*!
 Copyright (c) Peculiar Ventures, LLC
*/ let sW = {
        fromJSON: (O) => eD.Buffer.from(e2.ep.FromBase64Url(O)),
        toJSON: (O) => e2.ep.ToBase64Url(O),
      };
      class sY extends n3 {
        constructor() {
          super(...arguments),
            (this.data = eD.Buffer.alloc(0)),
            (this.algorithm = { name: "" }),
            (this.extractable = !1),
            (this.type = "secret"),
            (this.usages = []),
            (this.kty = "oct"),
            (this.alg = "");
        }
      }
      (0, no.__decorate)(
        [nR({ name: "ext", type: eI.Boolean, optional: !0 })],
        sY.prototype,
        "extractable",
        void 0
      ),
        (0, no.__decorate)(
          [
            nR({
              name: "key_ops",
              type: eI.String,
              repeated: !0,
              optional: !0,
            }),
          ],
          sY.prototype,
          "usages",
          void 0
        ),
        (0, no.__decorate)(
          [nR({ type: eI.String })],
          sY.prototype,
          "kty",
          void 0
        ),
        (0, no.__decorate)(
          [nR({ type: eI.String, optional: !0 })],
          sY.prototype,
          "alg",
          void 0
        );
      class sZ extends sY {
        constructor() {
          super(...arguments), (this.kty = "oct"), (this.type = "secret");
        }
      }
      class sX extends sY {}
      class s0 extends sZ {
        get alg() {
          switch (this.algorithm.name.toUpperCase()) {
            case "AES-CBC":
              return `A${this.algorithm.length}CBC`;
            case "AES-CTR":
              return `A${this.algorithm.length}CTR`;
            case "AES-GCM":
              return `A${this.algorithm.length}GCM`;
            case "AES-KW":
              return `A${this.algorithm.length}KW`;
            case "AES-CMAC":
              return `A${this.algorithm.length}CMAC`;
            case "AES-ECB":
              return `A${this.algorithm.length}ECB`;
            default:
              throw new nM("Unsupported algorithm name");
          }
        }
        set alg(O) {}
      }
      (0, no.__decorate)(
        [nR({ name: "k", converter: sW })],
        s0.prototype,
        "data",
        void 0
      );
      class s1 {
        static async generateKey(O, T, L) {
          let J = new s0();
          return (
            (J.algorithm = O),
            (J.extractable = T),
            (J.usages = L),
            (J.data = sQ().randomBytes(O.length >> 3)),
            J
          );
        }
        static async exportKey(O, T) {
          if (!(T instanceof s0)) throw Error("key: Is not AesCryptoKey");
          switch (O.toLowerCase()) {
            case "jwk":
              return nO.toJSON(T);
            case "raw":
              return new Uint8Array(T.data).buffer;
            default:
              throw new nL("format: Must be 'jwk' or 'raw'");
          }
        }
        static async importKey(O, T, L, J, W) {
          let Y;
          switch (O.toLowerCase()) {
            case "jwk":
              Y = nT.fromJSON(T, { targetSchema: s0 });
              break;
            case "raw":
              (Y = new s0()).data = eD.Buffer.from(T);
              break;
            default:
              throw new nL("format: Must be 'jwk' or 'raw'");
          }
          switch (
            ((Y.algorithm = L),
            (Y.algorithm.length = Y.data.length << 3),
            (Y.extractable = J),
            (Y.usages = W),
            Y.algorithm.length)
          ) {
            case 128:
            case 192:
            case 256:
              break;
            default:
              throw new nL("keyData: Is wrong key length");
          }
          return Y;
        }
        static async encrypt(O, T, L) {
          switch (O.name.toUpperCase()) {
            case "AES-CBC":
              return this.encryptAesCBC(O, T, eD.Buffer.from(L));
            case "AES-CTR":
              return this.encryptAesCTR(O, T, eD.Buffer.from(L));
            case "AES-GCM":
              return this.encryptAesGCM(O, T, eD.Buffer.from(L));
            case "AES-KW":
              return this.encryptAesKW(O, T, eD.Buffer.from(L));
            case "AES-ECB":
              return this.encryptAesECB(O, T, eD.Buffer.from(L));
            default:
              throw new nL("algorithm: Is not recognized");
          }
        }
        static async decrypt(O, T, L) {
          if (!(T instanceof s0)) throw Error("key: Is not AesCryptoKey");
          switch (O.name.toUpperCase()) {
            case "AES-CBC":
              return this.decryptAesCBC(O, T, eD.Buffer.from(L));
            case "AES-CTR":
              return this.decryptAesCTR(O, T, eD.Buffer.from(L));
            case "AES-GCM":
              return this.decryptAesGCM(O, T, eD.Buffer.from(L));
            case "AES-KW":
              return this.decryptAesKW(O, T, eD.Buffer.from(L));
            case "AES-ECB":
              return this.decryptAesECB(O, T, eD.Buffer.from(L));
            default:
              throw new nL("algorithm: Is not recognized");
          }
        }
        static async encryptAesCBC(O, T, L) {
          let J = sQ().createCipheriv(
              `aes-${T.algorithm.length}-cbc`,
              T.data,
              new Uint8Array(O.iv)
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async decryptAesCBC(O, T, L) {
          let J = sQ().createDecipheriv(
              `aes-${T.algorithm.length}-cbc`,
              T.data,
              new Uint8Array(O.iv)
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async encryptAesCTR(O, T, L) {
          let J = sQ().createCipheriv(
              `aes-${T.algorithm.length}-ctr`,
              T.data,
              eD.Buffer.from(O.counter)
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async decryptAesCTR(O, T, L) {
          let J = sQ().createDecipheriv(
              `aes-${T.algorithm.length}-ctr`,
              T.data,
              new Uint8Array(O.counter)
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async encryptAesGCM(O, T, L) {
          let J = sQ().createCipheriv(
            `aes-${T.algorithm.length}-gcm`,
            T.data,
            eD.Buffer.from(O.iv),
            { authTagLength: (O.tagLength || 128) >> 3 }
          );
          O.additionalData && J.setAAD(eD.Buffer.from(O.additionalData));
          let W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final(), J.getAuthTag()])),
            new Uint8Array(W).buffer
          );
        }
        static async decryptAesGCM(O, T, L) {
          let J = (O.tagLength || 128) >> 3,
            W = sQ().createDecipheriv(
              `aes-${T.algorithm.length}-gcm`,
              T.data,
              new Uint8Array(O.iv),
              { authTagLength: J }
            ),
            Y = L.slice(0, L.length - J),
            Z = L.slice(L.length - J);
          O.additionalData && W.setAAD(eD.Buffer.from(O.additionalData)),
            W.setAuthTag(Z);
          let X = W.update(Y);
          return (
            (X = eD.Buffer.concat([X, W.final()])), new Uint8Array(X).buffer
          );
        }
        static async encryptAesKW(O, T, L) {
          let J = sQ().createCipheriv(
              `id-aes${T.algorithm.length}-wrap`,
              T.data,
              this.AES_KW_IV
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async decryptAesKW(O, T, L) {
          let J = sQ().createDecipheriv(
              `id-aes${T.algorithm.length}-wrap`,
              T.data,
              this.AES_KW_IV
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async encryptAesECB(O, T, L) {
          let J = sQ().createCipheriv(
              `aes-${T.algorithm.length}-ecb`,
              T.data,
              new Uint8Array(0)
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async decryptAesECB(O, T, L) {
          let J = sQ().createDecipheriv(
              `aes-${T.algorithm.length}-ecb`,
              T.data,
              new Uint8Array(0)
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
      }
      s1.AES_KW_IV = eD.Buffer.from("A6A6A6A6A6A6A6A6", "hex");
      let s2 = new WeakMap();
      function s3(O) {
        let T = s2.get(O);
        if (!T) throw new nL("Cannot get CryptoKey from secure storage");
        return T;
      }
      function s4(O) {
        let T = n3.create(O.algorithm, O.type, O.extractable, O.usages);
        return Object.freeze(T), s2.set(T, O), T;
      }
      class s8 extends nj {
        async onGenerateKey(O, T, L) {
          return s4(
            await s1.generateKey({ name: this.name, length: O.length }, T, L)
          );
        }
        async onEncrypt(O, T, L) {
          return s1.encrypt(O, s3(T), new Uint8Array(L));
        }
        async onDecrypt(O, T, L) {
          return s1.decrypt(O, s3(T), new Uint8Array(L));
        }
        async onExportKey(O, T) {
          return s1.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await s1.importKey(O, T, { name: L.name }, J, W));
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof s0)))
            throw TypeError("key: Is not a AesCryptoKey");
        }
      }
      let s6 = eD.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        s5 = eD.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]),
        s7 = 16;
      function s9(O) {
        let T = eD.Buffer.alloc(O.length),
          L = O.length - 1;
        for (let J = 0; J < L; J++)
          (T[J] = O[J] << 1), 128 & O[J + 1] && (T[J] += 1);
        return (T[L] = O[L] << 1), T;
      }
      function ie(O, T) {
        let L = Math.min(O.length, T.length),
          J = eD.Buffer.alloc(L);
        for (let W = 0; W < L; W++) J[W] = O[W] ^ T[W];
        return J;
      }
      function it(O, T) {
        let L = sz.createCipheriv(`aes${O.length << 3}`, O, s6),
          J = L.update(T);
        return L.final(), J;
      }
      function ir(O, T) {
        let L = eD.Buffer.alloc(s7),
          J = T * s7,
          W = J + s7;
        return O.copy(L, 0, J, W), L;
      }
      function is(O, T) {
        let L = eD.Buffer.alloc(s7),
          J = T * s7,
          W = O.length;
        return L.fill(0), O.copy(L, 0, J, W), (L[W - J] = 128), L;
      }
      function ia(O) {
        let T = it(O, s6),
          L = s9(T);
        128 & T[0] && (L = ie(L, s5));
        let J = s9(L);
        return 128 & L[0] && (J = ie(J, s5)), { subkey1: L, subkey2: J };
      }
      function io(O, T) {
        let L, J, W;
        let Y = ia(O),
          Z = Math.ceil(T.length / s7);
        0 === Z ? ((Z = 1), (L = !1)) : (L = T.length % s7 == 0);
        let X = Z - 1;
        J = L ? ie(ir(T, X), Y.subkey1) : ie(is(T, X), Y.subkey2);
        let ee = s6;
        for (let L = 0; L < X; L++) ee = it(O, (W = ie(ee, ir(T, L))));
        return it(O, (W = ie(J, ee)));
      }
      class ic extends nH {
        async onGenerateKey(O, T, L) {
          return s4(
            await s1.generateKey({ name: this.name, length: O.length }, T, L)
          );
        }
        async onSign(O, T, L) {
          let J = io(s3(T).data, eD.Buffer.from(L));
          return new Uint8Array(J).buffer;
        }
        async onVerify(O, T, L, J) {
          let W = await this.sign(O, T, J);
          return 0 === eD.Buffer.from(L).compare(eD.Buffer.from(W));
        }
        async onExportKey(O, T) {
          return s1.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await s1.importKey(O, T, { name: L.name }, J, W));
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof s0)))
            throw TypeError("key: Is not a AesCryptoKey");
        }
      }
      class iu extends n$ {
        async onGenerateKey(O, T, L) {
          return s4(
            await s1.generateKey({ name: this.name, length: O.length }, T, L)
          );
        }
        async onEncrypt(O, T, L) {
          return s1.encrypt(O, s3(T), new Uint8Array(L));
        }
        async onDecrypt(O, T, L) {
          return s1.decrypt(O, s3(T), new Uint8Array(L));
        }
        async onExportKey(O, T) {
          return s1.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await s1.importKey(O, T, { name: L.name }, J, W));
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof s0)))
            throw TypeError("key: Is not a AesCryptoKey");
        }
      }
      class ih extends nG {
        async onGenerateKey(O, T, L) {
          return s4(
            await s1.generateKey({ name: this.name, length: O.length }, T, L)
          );
        }
        async onEncrypt(O, T, L) {
          return s1.encrypt(O, s3(T), new Uint8Array(L));
        }
        async onDecrypt(O, T, L) {
          return s1.decrypt(O, s3(T), new Uint8Array(L));
        }
        async onExportKey(O, T) {
          return s1.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await s1.importKey(O, T, { name: L.name }, J, W));
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof s0)))
            throw TypeError("key: Is not a AesCryptoKey");
        }
      }
      class ip extends nJ {
        async onGenerateKey(O, T, L) {
          return s4(
            await s1.generateKey({ name: this.name, length: O.length }, T, L)
          );
        }
        async onExportKey(O, T) {
          return s1.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await s1.importKey(O, T, { name: L.name }, J, W));
        }
        async onEncrypt(O, T, L) {
          return s1.encrypt(O, s3(T), new Uint8Array(L));
        }
        async onDecrypt(O, T, L) {
          return s1.decrypt(O, s3(T), new Uint8Array(L));
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof s0)))
            throw TypeError("key: Is not a AesCryptoKey");
        }
      }
      class ig extends nV {
        async onGenerateKey(O, T, L) {
          return s4(
            await s1.generateKey({ name: this.name, length: O.length }, T, L)
          );
        }
        async onEncrypt(O, T, L) {
          return s1.encrypt(O, s3(T), new Uint8Array(L));
        }
        async onDecrypt(O, T, L) {
          return s1.decrypt(O, s3(T), new Uint8Array(L));
        }
        async onExportKey(O, T) {
          return s1.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await s1.importKey(O, T, { name: L.name }, J, W));
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof s0)))
            throw TypeError("key: Is not a AesCryptoKey");
        }
      }
      class iy extends sZ {
        get alg() {
          switch (this.algorithm.name.toUpperCase()) {
            case "DES-CBC":
              return "DES-CBC";
            case "DES-EDE3-CBC":
              return "3DES-CBC";
            default:
              throw new nM("Unsupported algorithm name");
          }
        }
        set alg(O) {}
      }
      (0, no.__decorate)(
        [nR({ name: "k", converter: sW })],
        iy.prototype,
        "data",
        void 0
      );
      class im {
        static async generateKey(O, T, L) {
          let J = new iy();
          return (
            (J.algorithm = O),
            (J.extractable = T),
            (J.usages = L),
            (J.data = sQ().randomBytes(O.length >> 3)),
            J
          );
        }
        static async exportKey(O, T) {
          switch (O.toLowerCase()) {
            case "jwk":
              return nO.toJSON(T);
            case "raw":
              return new Uint8Array(T.data).buffer;
            default:
              throw new nL("format: Must be 'jwk' or 'raw'");
          }
        }
        static async importKey(O, T, L, J, W) {
          let Y;
          switch (O.toLowerCase()) {
            case "jwk":
              Y = nT.fromJSON(T, { targetSchema: iy });
              break;
            case "raw":
              (Y = new iy()).data = eD.Buffer.from(T);
              break;
            default:
              throw new nL("format: Must be 'jwk' or 'raw'");
          }
          return (Y.algorithm = L), (Y.extractable = J), (Y.usages = W), Y;
        }
        static async encrypt(O, T, L) {
          switch (O.name.toUpperCase()) {
            case "DES-CBC":
              return this.encryptDesCBC(O, T, eD.Buffer.from(L));
            case "DES-EDE3-CBC":
              return this.encryptDesEDE3CBC(O, T, eD.Buffer.from(L));
            default:
              throw new nL("algorithm: Is not recognized");
          }
        }
        static async decrypt(O, T, L) {
          if (!(T instanceof iy)) throw Error("key: Is not DesCryptoKey");
          switch (O.name.toUpperCase()) {
            case "DES-CBC":
              return this.decryptDesCBC(O, T, eD.Buffer.from(L));
            case "DES-EDE3-CBC":
              return this.decryptDesEDE3CBC(O, T, eD.Buffer.from(L));
            default:
              throw new nL("algorithm: Is not recognized");
          }
        }
        static async encryptDesCBC(O, T, L) {
          let J = sQ().createCipheriv("des-cbc", T.data, new Uint8Array(O.iv)),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async decryptDesCBC(O, T, L) {
          let J = sQ().createDecipheriv(
              "des-cbc",
              T.data,
              new Uint8Array(O.iv)
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async encryptDesEDE3CBC(O, T, L) {
          let J = sQ().createCipheriv(
              "des-ede3-cbc",
              T.data,
              eD.Buffer.from(O.iv)
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
        static async decryptDesEDE3CBC(O, T, L) {
          let J = sQ().createDecipheriv(
              "des-ede3-cbc",
              T.data,
              new Uint8Array(O.iv)
            ),
            W = J.update(L);
          return (
            (W = eD.Buffer.concat([W, J.final()])), new Uint8Array(W).buffer
          );
        }
      }
      class ib extends nz {
        constructor() {
          super(...arguments),
            (this.keySizeBits = 64),
            (this.ivSize = 8),
            (this.name = "DES-CBC");
        }
        async onGenerateKey(O, T, L) {
          return s4(
            await im.generateKey(
              { name: this.name, length: this.keySizeBits },
              T,
              L
            )
          );
        }
        async onEncrypt(O, T, L) {
          return im.encrypt(O, s3(T), new Uint8Array(L));
        }
        async onDecrypt(O, T, L) {
          return im.decrypt(O, s3(T), new Uint8Array(L));
        }
        async onExportKey(O, T) {
          return im.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          let Y = await im.importKey(
            O,
            T,
            { name: this.name, length: this.keySizeBits },
            J,
            W
          );
          if (Y.data.length !== this.keySizeBits >> 3)
            throw new nL("keyData: Wrong key size");
          return s4(Y);
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof iy)))
            throw TypeError("key: Is not a DesCryptoKey");
        }
      }
      class iA extends nz {
        constructor() {
          super(...arguments),
            (this.keySizeBits = 192),
            (this.ivSize = 8),
            (this.name = "DES-EDE3-CBC");
        }
        async onGenerateKey(O, T, L) {
          return s4(
            await im.generateKey(
              { name: this.name, length: this.keySizeBits },
              T,
              L
            )
          );
        }
        async onEncrypt(O, T, L) {
          return im.encrypt(O, s3(T), new Uint8Array(L));
        }
        async onDecrypt(O, T, L) {
          return im.decrypt(O, s3(T), new Uint8Array(L));
        }
        async onExportKey(O, T) {
          return im.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          let Y = await im.importKey(
            O,
            T,
            { name: this.name, length: this.keySizeBits },
            J,
            W
          );
          if (Y.data.length !== this.keySizeBits >> 3)
            throw new nL("keyData: Wrong key size");
          return s4(Y);
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof iy)))
            throw TypeError("key: Is not a DesCryptoKey");
        }
      }
      function iw(O) {
        switch (O.name.toUpperCase()) {
          case "RSA-OAEP": {
            let T = /(\d+)$/.exec(O.hash.name)[1];
            return `RSA-OAEP${"1" !== T ? `-${T}` : ""}`;
          }
          case "RSASSA-PKCS1-V1_5":
            return `RS${/(\d+)$/.exec(O.hash.name)[1]}`;
          case "RSA-PSS":
            return `PS${/(\d+)$/.exec(O.hash.name)[1]}`;
          case "RSA-PKCS1":
            return "RS1";
          default:
            throw new nL("algorithm: Is not recognized");
        }
      }
      class ik extends sX {
        constructor() {
          super(...arguments), (this.type = "private");
        }
        getKey() {
          let O = ns.parse(this.data, sL.PrivateKeyInfo);
          return ns.parse(O.privateKey, sL.RsaPrivateKey);
        }
        toJSON() {
          let O = this.getKey();
          return Object.assign(
            {
              kty: "RSA",
              alg: iw(this.algorithm),
              key_ops: this.usages,
              ext: this.extractable,
            },
            nO.toJSON(O)
          );
        }
        fromJSON(O) {
          let T = nT.fromJSON(O, { targetSchema: sL.RsaPrivateKey }),
            L = new sL.PrivateKeyInfo();
          (L.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1"),
            (L.privateKeyAlgorithm.parameters = null),
            (L.privateKey = ni.serialize(T)),
            (this.data = eD.Buffer.from(ni.serialize(L)));
        }
      }
      class iE extends sX {
        constructor() {
          super(...arguments), (this.type = "public");
        }
        getKey() {
          let O = ns.parse(this.data, sL.PublicKeyInfo);
          return ns.parse(O.publicKey, sL.RsaPublicKey);
        }
        toJSON() {
          let O = this.getKey();
          return Object.assign(
            {
              kty: "RSA",
              alg: iw(this.algorithm),
              key_ops: this.usages,
              ext: this.extractable,
            },
            nO.toJSON(O)
          );
        }
        fromJSON(O) {
          let T = nT.fromJSON(O, { targetSchema: sL.RsaPublicKey }),
            L = new sL.PublicKeyInfo();
          (L.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1"),
            (L.publicKeyAlgorithm.parameters = null),
            (L.publicKey = ni.serialize(T)),
            (this.data = eD.Buffer.from(ni.serialize(L)));
        }
      }
      class iS {
        static async generateKey(O, T, L) {
          let J = new ik();
          (J.algorithm = O),
            (J.extractable = T),
            (J.usages = L.filter(
              (O) => -1 !== this.privateKeyUsages.indexOf(O)
            ));
          let W = new iE();
          (W.algorithm = O),
            (W.extractable = !0),
            (W.usages = L.filter(
              (O) => -1 !== this.publicKeyUsages.indexOf(O)
            ));
          let Y = eD.Buffer.concat([
              eD.Buffer.alloc(4 - O.publicExponent.byteLength, 0),
              eD.Buffer.from(O.publicExponent),
            ]).readInt32BE(0),
            Z = sQ().generateKeyPairSync("rsa", {
              modulusLength: O.modulusLength,
              publicExponent: Y,
              publicKeyEncoding: { format: "der", type: "spki" },
              privateKeyEncoding: { format: "der", type: "pkcs8" },
            });
          return (
            (J.data = Z.privateKey),
            (W.data = Z.publicKey),
            { privateKey: J, publicKey: W }
          );
        }
        static async exportKey(O, T) {
          switch (O.toLowerCase()) {
            case "jwk":
              return nO.toJSON(T);
            case "pkcs8":
            case "spki":
              return new Uint8Array(T.data).buffer;
            default:
              throw new nL("format: Must be 'jwk', 'pkcs8' or 'spki'");
          }
        }
        static async importKey(O, T, L, J, W) {
          switch (O.toLowerCase()) {
            case "jwk":
              if (T.d) {
                let O = nT.fromJSON(T, { targetSchema: sL.RsaPrivateKey });
                return this.importPrivateKey(O, L, J, W);
              }
              {
                let O = nT.fromJSON(T, { targetSchema: sL.RsaPublicKey });
                return this.importPublicKey(O, L, J, W);
              }
            case "spki": {
              let O = ns.parse(new Uint8Array(T), sL.PublicKeyInfo),
                Y = ns.parse(O.publicKey, sL.RsaPublicKey);
              return this.importPublicKey(Y, L, J, W);
            }
            case "pkcs8": {
              let O = ns.parse(new Uint8Array(T), sL.PrivateKeyInfo),
                Y = ns.parse(O.privateKey, sL.RsaPrivateKey);
              return this.importPrivateKey(Y, L, J, W);
            }
            default:
              throw new nL("format: Must be 'jwk', 'pkcs8' or 'spki'");
          }
        }
        static async sign(O, T, L) {
          switch (O.name.toUpperCase()) {
            case "RSA-PSS":
            case "RSASSA-PKCS1-V1_5":
              return this.signRsa(O, T, L);
            default:
              throw new nL("algorithm: Is not recognized");
          }
        }
        static async verify(O, T, L, J) {
          switch (O.name.toUpperCase()) {
            case "RSA-PSS":
            case "RSASSA-PKCS1-V1_5":
              return this.verifySSA(O, T, J, L);
            default:
              throw new nL("algorithm: Is not recognized");
          }
        }
        static async encrypt(O, T, L) {
          if ("RSA-OAEP" === O.name.toUpperCase())
            return this.encryptOAEP(O, T, L);
          throw new nL("algorithm: Is not recognized");
        }
        static async decrypt(O, T, L) {
          if ("RSA-OAEP" === O.name.toUpperCase())
            return this.decryptOAEP(O, T, L);
          throw new nL("algorithm: Is not recognized");
        }
        static importPrivateKey(O, T, L, J) {
          let W = new sL.PrivateKeyInfo();
          (W.privateKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1"),
            (W.privateKeyAlgorithm.parameters = null),
            (W.privateKey = ni.serialize(O));
          let Y = new ik();
          return (
            (Y.data = eD.Buffer.from(ni.serialize(W))),
            (Y.algorithm = Object.assign({}, T)),
            (Y.algorithm.publicExponent = new Uint8Array(O.publicExponent)),
            (Y.algorithm.modulusLength = O.modulus.byteLength << 3),
            (Y.extractable = L),
            (Y.usages = J),
            Y
          );
        }
        static importPublicKey(O, T, L, J) {
          let W = new sL.PublicKeyInfo();
          (W.publicKeyAlgorithm.algorithm = "1.2.840.113549.1.1.1"),
            (W.publicKeyAlgorithm.parameters = null),
            (W.publicKey = ni.serialize(O));
          let Y = new iE();
          return (
            (Y.data = eD.Buffer.from(ni.serialize(W))),
            (Y.algorithm = Object.assign({}, T)),
            (Y.algorithm.publicExponent = new Uint8Array(O.publicExponent)),
            (Y.algorithm.modulusLength = O.modulus.byteLength << 3),
            (Y.extractable = L),
            (Y.usages = J),
            Y
          );
        }
        static getCryptoAlgorithm(O) {
          switch (O.hash.name.toUpperCase()) {
            case "SHA-1":
              return "RSA-SHA1";
            case "SHA-256":
              return "RSA-SHA256";
            case "SHA-384":
              return "RSA-SHA384";
            case "SHA-512":
              return "RSA-SHA512";
            case "SHA3-256":
              return "RSA-SHA3-256";
            case "SHA3-384":
              return "RSA-SHA3-384";
            case "SHA3-512":
              return "RSA-SHA3-512";
            default:
              throw new nL("algorithm.hash: Is not recognized");
          }
        }
        static signRsa(O, T, L) {
          let J = this.getCryptoAlgorithm(T.algorithm),
            W = sQ().createSign(J);
          W.update(eD.Buffer.from(L)),
            T.pem ||
              (T.pem = `-----BEGIN PRIVATE KEY-----
${T.data.toString("base64")}
-----END PRIVATE KEY-----`);
          let Y = { key: T.pem };
          "RSA-PSS" === O.name.toUpperCase() &&
            ((Y.padding = sQ().constants.RSA_PKCS1_PSS_PADDING),
            (Y.saltLength = O.saltLength));
          let Z = W.sign(Y);
          return new Uint8Array(Z).buffer;
        }
        static verifySSA(O, T, L, J) {
          let W = this.getCryptoAlgorithm(T.algorithm),
            Y = sQ().createVerify(W);
          Y.update(eD.Buffer.from(L)),
            T.pem ||
              (T.pem = `-----BEGIN PUBLIC KEY-----
${T.data.toString("base64")}
-----END PUBLIC KEY-----`);
          let Z = { key: T.pem };
          return (
            "RSA-PSS" === O.name.toUpperCase() &&
              ((Z.padding = sQ().constants.RSA_PKCS1_PSS_PADDING),
              (Z.saltLength = O.saltLength)),
            Y.verify(Z, J)
          );
        }
        static encryptOAEP(O, T, L) {
          let J = {
            key: `-----BEGIN PUBLIC KEY-----
${T.data.toString("base64")}
-----END PUBLIC KEY-----`,
            padding: sQ().constants.RSA_PKCS1_OAEP_PADDING,
          };
          return O.label, new Uint8Array(sQ().publicEncrypt(J, L)).buffer;
        }
        static decryptOAEP(O, T, L) {
          let J = {
            key: `-----BEGIN PRIVATE KEY-----
${T.data.toString("base64")}
-----END PRIVATE KEY-----`,
            padding: sQ().constants.RSA_PKCS1_OAEP_PADDING,
          };
          return O.label, new Uint8Array(sQ().privateDecrypt(J, L)).buffer;
        }
      }
      (iS.publicKeyUsages = ["verify", "encrypt", "wrapKey"]),
        (iS.privateKeyUsages = ["sign", "decrypt", "unwrapKey"]);
      class iP extends nq {
        constructor() {
          super(...arguments),
            (this.hashAlgorithms = [
              "SHA-1",
              "SHA-256",
              "SHA-384",
              "SHA-512",
              "shake128",
              "shake256",
              "SHA3-256",
              "SHA3-384",
              "SHA3-512",
            ]);
        }
        async onGenerateKey(O, T, L) {
          let J = await iS.generateKey({ ...O, name: this.name }, T, L);
          return { privateKey: s4(J.privateKey), publicKey: s4(J.publicKey) };
        }
        async onSign(O, T, L) {
          return iS.sign(O, s3(T), new Uint8Array(L));
        }
        async onVerify(O, T, L, J) {
          return iS.verify(O, s3(T), new Uint8Array(L), new Uint8Array(J));
        }
        async onExportKey(O, T) {
          return iS.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await iS.importKey(O, T, { ...L, name: this.name }, J, W));
        }
        checkCryptoKey(O, T) {
          super.checkCryptoKey(O, T);
          let L = s3(O);
          if (!(L instanceof ik || L instanceof iE))
            throw TypeError("key: Is not RSA CryptoKey");
        }
      }
      class ix extends nW {
        constructor() {
          super(...arguments),
            (this.hashAlgorithms = [
              "SHA-1",
              "SHA-256",
              "SHA-384",
              "SHA-512",
              "shake128",
              "shake256",
              "SHA3-256",
              "SHA3-384",
              "SHA3-512",
            ]);
        }
        async onGenerateKey(O, T, L) {
          let J = await iS.generateKey({ ...O, name: this.name }, T, L);
          return { privateKey: s4(J.privateKey), publicKey: s4(J.publicKey) };
        }
        async onSign(O, T, L) {
          return iS.sign(O, s3(T), new Uint8Array(L));
        }
        async onVerify(O, T, L, J) {
          return iS.verify(O, s3(T), new Uint8Array(L), new Uint8Array(J));
        }
        async onExportKey(O, T) {
          return iS.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await iS.importKey(O, T, { ...L, name: this.name }, J, W));
        }
        checkCryptoKey(O, T) {
          super.checkCryptoKey(O, T);
          let L = s3(O);
          if (!(L instanceof ik || L instanceof iE))
            throw TypeError("key: Is not RSA CryptoKey");
        }
      }
      class iC {
        static size(O) {
          switch (O.name.toUpperCase()) {
            case "SHA-1":
              return 160;
            case "SHA-256":
            case "SHA3-256":
              return 256;
            case "SHA-384":
            case "SHA3-384":
              return 384;
            case "SHA-512":
            case "SHA3-512":
              return 512;
            default:
              throw Error("Unrecognized name");
          }
        }
        static getAlgorithmName(O) {
          switch (O.name.toUpperCase()) {
            case "SHA-1":
              return "sha1";
            case "SHA-256":
              return "sha256";
            case "SHA-384":
              return "sha384";
            case "SHA-512":
              return "sha512";
            case "SHA3-256":
              return "sha3-256";
            case "SHA3-384":
              return "sha3-384";
            case "SHA3-512":
              return "sha3-512";
            default:
              throw Error("Unrecognized name");
          }
        }
        static digest(O, T) {
          let L = this.getAlgorithmName(O),
            J = sQ().createHash(L).update(eD.Buffer.from(T)).digest();
          return new Uint8Array(J).buffer;
        }
      }
      class iB extends nY {
        async onGenerateKey(O, T, L) {
          let J = await iS.generateKey({ ...O, name: this.name }, T, L);
          return { privateKey: s4(J.privateKey), publicKey: s4(J.publicKey) };
        }
        async onEncrypt(O, T, L) {
          let J = s3(T),
            W = new Uint8Array(L),
            Y = Math.ceil(J.algorithm.modulusLength >> 3),
            Z = iC.size(J.algorithm.hash) >> 3,
            X = W.byteLength,
            ee = Y - X - 2 * Z - 2;
          if (X > Y - 2 * Z - 2) throw Error("Data too large");
          let et = new Uint8Array(Y),
            er = et.subarray(1, Z + 1),
            en = et.subarray(Z + 1);
          en.set(W, Z + ee + 1);
          let es = sQ()
            .createHash(J.algorithm.hash.name.replace("-", ""))
            .update(e2.vJ.toUint8Array(O.label || new Uint8Array(0)))
            .digest();
          en.set(es, 0), (en[Z + ee] = 1), sQ().randomFillSync(er);
          let ei = this.mgf1(J.algorithm.hash, er, en.length);
          for (let O = 0; O < en.length; O++) en[O] ^= ei[O];
          let ea = this.mgf1(J.algorithm.hash, en, er.length);
          for (let O = 0; O < er.length; O++) er[O] ^= ea[O];
          J.pem ||
            (J.pem = `-----BEGIN PUBLIC KEY-----
${J.data.toString("base64")}
-----END PUBLIC KEY-----`);
          let eo = sQ().publicEncrypt(
            { key: J.pem, padding: sQ().constants.RSA_NO_PADDING },
            eD.Buffer.from(et)
          );
          return new Uint8Array(eo).buffer;
        }
        async onDecrypt(O, T, L) {
          let J = s3(T),
            W = Math.ceil(J.algorithm.modulusLength >> 3),
            Y = iC.size(J.algorithm.hash) >> 3;
          if (L.byteLength !== W) throw Error("Bad data");
          J.pem ||
            (J.pem = `-----BEGIN PRIVATE KEY-----
${J.data.toString("base64")}
-----END PRIVATE KEY-----`);
          let Z = sQ().privateDecrypt(
              { key: J.pem, padding: sQ().constants.RSA_NO_PADDING },
              eD.Buffer.from(L)
            ),
            X = Z[0],
            ee = Z.subarray(1, Y + 1),
            et = Z.subarray(Y + 1);
          if (0 !== X) throw Error("Decryption failed");
          let er = this.mgf1(J.algorithm.hash, et, ee.length);
          for (let O = 0; O < ee.length; O++) ee[O] ^= er[O];
          let en = this.mgf1(J.algorithm.hash, ee, et.length);
          for (let O = 0; O < et.length; O++) et[O] ^= en[O];
          let es = sQ()
            .createHash(J.algorithm.hash.name.replace("-", ""))
            .update(e2.vJ.toUint8Array(O.label || new Uint8Array(0)))
            .digest();
          for (let O = 0; O < Y; O++)
            if (es[O] !== et[O]) throw Error("Decryption failed");
          let ei = Y;
          for (; ei < et.length; ei++) {
            let O = et[ei];
            if (1 === O) break;
            if (0 !== O) throw Error("Decryption failed");
          }
          if (ei === et.length) throw Error("Decryption failed");
          return (Z = et.subarray(ei + 1)), new Uint8Array(Z).buffer;
        }
        async onExportKey(O, T) {
          return iS.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await iS.importKey(O, T, { ...L, name: this.name }, J, W));
        }
        checkCryptoKey(O, T) {
          super.checkCryptoKey(O, T);
          let L = s3(O);
          if (!(L instanceof ik || L instanceof iE))
            throw TypeError("key: Is not RSA CryptoKey");
        }
        mgf1(O, T, L = 0) {
          let J = iC.size(O) >> 3,
            W = new Uint8Array(L),
            Y = new Uint8Array(4),
            Z = Math.ceil(L / J);
          for (let L = 0; L < Z; L++) {
            (Y[0] = L >>> 24),
              (Y[1] = (L >>> 16) & 255),
              (Y[2] = (L >>> 8) & 255),
              (Y[3] = 255 & L);
            let Z = W.subarray(L * J),
              X = sQ()
                .createHash(O.name.replace("-", ""))
                .update(T)
                .update(Y)
                .digest();
            X.length > Z.length && (X = X.subarray(0, Z.length)), Z.set(X);
          }
          return W;
        }
      }
      class iO extends nF {
        constructor() {
          super(...arguments),
            (this.name = "RSAES-PKCS1-v1_5"),
            (this.usages = {
              publicKey: ["encrypt", "wrapKey"],
              privateKey: ["decrypt", "unwrapKey"],
            });
        }
        async onGenerateKey(O, T, L) {
          let J = await iS.generateKey({ ...O, name: this.name }, T, L);
          return { privateKey: s4(J.privateKey), publicKey: s4(J.publicKey) };
        }
        checkGenerateKeyParams(O) {
          if (
            (this.checkRequiredProperty(O, "publicExponent"),
            !(O.publicExponent && O.publicExponent instanceof Uint8Array))
          )
            throw TypeError("publicExponent: Missing or not a Uint8Array");
          let T = e2.ep.ToBase64(O.publicExponent);
          if (!("Aw==" === T || "AQAB" === T))
            throw TypeError("publicExponent: Must be [3] or [1,0,1]");
          switch (
            (this.checkRequiredProperty(O, "modulusLength"), O.modulusLength)
          ) {
            case 1024:
            case 2048:
            case 4096:
              break;
            default:
              throw TypeError("modulusLength: Must be 1024, 2048, or 4096");
          }
        }
        async onEncrypt(O, T, L) {
          let J = this.toCryptoOptions(T),
            W = sz.publicEncrypt(J, new Uint8Array(L));
          return new Uint8Array(W).buffer;
        }
        async onDecrypt(O, T, L) {
          let J = this.toCryptoOptions(T),
            W = sz.privateDecrypt(J, new Uint8Array(L));
          return new Uint8Array(W).buffer;
        }
        async onExportKey(O, T) {
          return iS.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await iS.importKey(O, T, { ...L, name: this.name }, J, W));
        }
        checkCryptoKey(O, T) {
          super.checkCryptoKey(O, T);
          let L = s3(O);
          if (!(L instanceof ik || L instanceof iE))
            throw TypeError("key: Is not RSA CryptoKey");
        }
        toCryptoOptions(O) {
          let T = O.type.toUpperCase();
          return {
            key: `-----BEGIN ${T} KEY-----
${s3(O).data.toString("base64")}
-----END ${T} KEY-----`,
            padding: sz.constants.RSA_PKCS1_PADDING,
          };
        }
      }
      let iT = {
        "1.2.840.10045.3.1.7": "P-256",
        "P-256": "1.2.840.10045.3.1.7",
        "1.3.132.0.34": "P-384",
        "P-384": "1.3.132.0.34",
        "1.3.132.0.35": "P-521",
        "P-521": "1.3.132.0.35",
        "1.3.132.0.10": "K-256",
        "K-256": "1.3.132.0.10",
        brainpoolP160r1: "1.3.36.3.3.2.8.1.1.1",
        "1.3.36.3.3.2.8.1.1.1": "brainpoolP160r1",
        brainpoolP160t1: "1.3.36.3.3.2.8.1.1.2",
        "1.3.36.3.3.2.8.1.1.2": "brainpoolP160t1",
        brainpoolP192r1: "1.3.36.3.3.2.8.1.1.3",
        "1.3.36.3.3.2.8.1.1.3": "brainpoolP192r1",
        brainpoolP192t1: "1.3.36.3.3.2.8.1.1.4",
        "1.3.36.3.3.2.8.1.1.4": "brainpoolP192t1",
        brainpoolP224r1: "1.3.36.3.3.2.8.1.1.5",
        "1.3.36.3.3.2.8.1.1.5": "brainpoolP224r1",
        brainpoolP224t1: "1.3.36.3.3.2.8.1.1.6",
        "1.3.36.3.3.2.8.1.1.6": "brainpoolP224t1",
        brainpoolP256r1: "1.3.36.3.3.2.8.1.1.7",
        "1.3.36.3.3.2.8.1.1.7": "brainpoolP256r1",
        brainpoolP256t1: "1.3.36.3.3.2.8.1.1.8",
        "1.3.36.3.3.2.8.1.1.8": "brainpoolP256t1",
        brainpoolP320r1: "1.3.36.3.3.2.8.1.1.9",
        "1.3.36.3.3.2.8.1.1.9": "brainpoolP320r1",
        brainpoolP320t1: "1.3.36.3.3.2.8.1.1.10",
        "1.3.36.3.3.2.8.1.1.10": "brainpoolP320t1",
        brainpoolP384r1: "1.3.36.3.3.2.8.1.1.11",
        "1.3.36.3.3.2.8.1.1.11": "brainpoolP384r1",
        brainpoolP384t1: "1.3.36.3.3.2.8.1.1.12",
        "1.3.36.3.3.2.8.1.1.12": "brainpoolP384t1",
        brainpoolP512r1: "1.3.36.3.3.2.8.1.1.13",
        "1.3.36.3.3.2.8.1.1.13": "brainpoolP512r1",
        brainpoolP512t1: "1.3.36.3.3.2.8.1.1.14",
        "1.3.36.3.3.2.8.1.1.14": "brainpoolP512t1",
      };
      function iN(O) {
        let T = iT[O];
        if (!T)
          throw new nL(`Cannot convert WebCrypto named curve '${O}' to OID`);
        return T;
      }
      class iR extends sX {
        constructor() {
          super(...arguments), (this.type = "private");
        }
        getKey() {
          let O = ns.parse(this.data, sL.PrivateKeyInfo);
          return ns.parse(O.privateKey, sL.EcPrivateKey);
        }
        toJSON() {
          let O = this.getKey();
          return Object.assign(
            {
              kty: "EC",
              crv: this.algorithm.namedCurve,
              key_ops: this.usages,
              ext: this.extractable,
            },
            nO.toJSON(O)
          );
        }
        fromJSON(O) {
          if (!O.crv)
            throw new nL(
              "Cannot get named curve from JWK. Property 'crv' is required"
            );
          let T = new sL.PrivateKeyInfo();
          (T.privateKeyAlgorithm.algorithm = "1.2.840.10045.2.1"),
            (T.privateKeyAlgorithm.parameters = ni.serialize(
              new sL.ObjectIdentifier(iN(O.crv))
            ));
          let L = nT.fromJSON(O, { targetSchema: sL.EcPrivateKey });
          return (
            (T.privateKey = ni.serialize(L)),
            (this.data = eD.Buffer.from(ni.serialize(T))),
            this
          );
        }
      }
      class iI extends sX {
        constructor() {
          super(...arguments), (this.type = "public");
        }
        getKey() {
          let O = ns.parse(this.data, sL.PublicKeyInfo);
          return new sL.EcPublicKey(O.publicKey);
        }
        toJSON() {
          let O = this.getKey();
          return Object.assign(
            {
              kty: "EC",
              crv: this.algorithm.namedCurve,
              key_ops: this.usages,
              ext: this.extractable,
            },
            nO.toJSON(O)
          );
        }
        fromJSON(O) {
          if (!O.crv)
            throw new nL(
              "Cannot get named curve from JWK. Property 'crv' is required"
            );
          let T = nT.fromJSON(O, { targetSchema: sL.EcPublicKey }),
            L = new sL.PublicKeyInfo();
          return (
            (L.publicKeyAlgorithm.algorithm = "1.2.840.10045.2.1"),
            (L.publicKeyAlgorithm.parameters = ni.serialize(
              new sL.ObjectIdentifier(iN(O.crv))
            )),
            (L.publicKey = ni.toASN(T).valueHex),
            (this.data = eD.Buffer.from(ni.serialize(L))),
            this
          );
        }
      }
      class iM extends nF {
        constructor() {
          super(...arguments), (this.name = "SHA-1"), (this.usages = []);
        }
        async onDigest(O, T) {
          return iC.digest(O, T);
        }
      }
      class iU extends nF {
        constructor() {
          super(...arguments), (this.name = "SHA-256"), (this.usages = []);
        }
        async onDigest(O, T) {
          return iC.digest(O, T);
        }
      }
      class iL extends nF {
        constructor() {
          super(...arguments), (this.name = "SHA-384"), (this.usages = []);
        }
        async onDigest(O, T) {
          return iC.digest(O, T);
        }
      }
      class iD extends nF {
        constructor() {
          super(...arguments), (this.name = "SHA-512"), (this.usages = []);
        }
        async onDigest(O, T) {
          return iC.digest(O, T);
        }
      }
      class i_ extends nF {
        constructor() {
          super(...arguments), (this.name = "SHA3-256"), (this.usages = []);
        }
        async onDigest(O, T) {
          return iC.digest(O, T);
        }
      }
      class iF extends nF {
        constructor() {
          super(...arguments), (this.name = "SHA3-384"), (this.usages = []);
        }
        async onDigest(O, T) {
          return iC.digest(O, T);
        }
      }
      class iK extends nF {
        constructor() {
          super(...arguments), (this.name = "SHA3-512"), (this.usages = []);
        }
        async onDigest(O, T) {
          return iC.digest(O, T);
        }
      }
      class ij {
        static async generateKey(O, T, L) {
          let J = new iR();
          (J.algorithm = O),
            (J.extractable = T),
            (J.usages = L.filter(
              (O) => -1 !== this.privateKeyUsages.indexOf(O)
            ));
          let W = new iI();
          (W.algorithm = O),
            (W.extractable = !0),
            (W.usages = L.filter(
              (O) => -1 !== this.publicKeyUsages.indexOf(O)
            ));
          let Y = sQ().generateKeyPairSync("ec", {
            namedCurve: this.getOpenSSLNamedCurve(O.namedCurve),
            publicKeyEncoding: { format: "der", type: "spki" },
            privateKeyEncoding: { format: "der", type: "pkcs8" },
          });
          return (
            (J.data = Y.privateKey),
            (W.data = Y.publicKey),
            { privateKey: J, publicKey: W }
          );
        }
        static async sign(O, T, L) {
          let J = iC.getAlgorithmName(O.hash),
            W = sQ().createSign(J);
          W.update(eD.Buffer.from(L)),
            T.pem ||
              (T.pem = `-----BEGIN PRIVATE KEY-----
${T.data.toString("base64")}
-----END PRIVATE KEY-----`);
          let Y = { key: T.pem },
            Z = W.sign(Y),
            X = ns.parse(Z, sL.EcDsaSignature);
          return su.encodeSignature(X, sD.get(T.algorithm.namedCurve).size)
            .buffer;
        }
        static async verify(O, T, L, J) {
          let W = iC.getAlgorithmName(O.hash),
            Y = sQ().createVerify(W);
          Y.update(eD.Buffer.from(J)),
            T.pem ||
              (T.pem = `-----BEGIN PUBLIC KEY-----
${T.data.toString("base64")}
-----END PUBLIC KEY-----`);
          let Z = { key: T.pem },
            X = new sL.EcDsaSignature(),
            ee = sD.get(T.algorithm.namedCurve),
            et = su.decodeSignature(L, ee.size);
          (X.r = e2.vJ.toArrayBuffer(et.r)), (X.s = e2.vJ.toArrayBuffer(et.s));
          let er = eD.Buffer.from(ni.serialize(X));
          return Y.verify(Z, er);
        }
        static async deriveBits(O, T, L) {
          let J = this.getOpenSSLNamedCurve(T.algorithm.namedCurve),
            W = sQ().createECDH(J),
            Y = ns.parse(T.data, sL.PrivateKeyInfo),
            Z = ns.parse(Y.privateKey, sL.EcPrivateKey);
          W.setPrivateKey(eD.Buffer.from(Z.privateKey));
          let X = ns.parse(O.public.data, sL.PublicKeyInfo),
            ee = W.computeSecret(eD.Buffer.from(X.publicKey));
          return null === L ? ee : new Uint8Array(ee).buffer.slice(0, L >> 3);
        }
        static async exportKey(O, T) {
          switch (O.toLowerCase()) {
            case "jwk":
              return nO.toJSON(T);
            case "pkcs8":
            case "spki":
              return new Uint8Array(T.data).buffer;
            case "raw":
              return ns.parse(T.data, sL.PublicKeyInfo).publicKey;
            default:
              throw new nL("format: Must be 'jwk', 'raw', pkcs8' or 'spki'");
          }
        }
        static async importKey(O, T, L, J, W) {
          switch (O.toLowerCase()) {
            case "jwk":
              if (T.d) {
                let O = nT.fromJSON(T, { targetSchema: sL.EcPrivateKey });
                return this.importPrivateKey(O, L, J, W);
              }
              {
                let O = nT.fromJSON(T, { targetSchema: sL.EcPublicKey });
                return this.importPublicKey(O, L, J, W);
              }
            case "raw": {
              let O = new sL.EcPublicKey(T);
              return this.importPublicKey(O, L, J, W);
            }
            case "spki": {
              let O = ns.parse(new Uint8Array(T), sL.PublicKeyInfo),
                Y = new sL.EcPublicKey(O.publicKey);
              return (
                this.assertKeyParameters(
                  O.publicKeyAlgorithm.parameters,
                  L.namedCurve
                ),
                this.importPublicKey(Y, L, J, W)
              );
            }
            case "pkcs8": {
              let O = ns.parse(new Uint8Array(T), sL.PrivateKeyInfo),
                Y = ns.parse(O.privateKey, sL.EcPrivateKey);
              return (
                this.assertKeyParameters(
                  O.privateKeyAlgorithm.parameters,
                  L.namedCurve
                ),
                this.importPrivateKey(Y, L, J, W)
              );
            }
            default:
              throw new nL("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
          }
        }
        static assertKeyParameters(O, T) {
          if (!O) throw new nI("Key info doesn't have required parameters");
          let L = "";
          try {
            L = ns.parse(O, sL.ObjectIdentifier).value;
          } catch (O) {
            throw new nI("Cannot read key info parameters");
          }
          if (iN(T) !== L)
            throw new nI("Key info parameter doesn't match to named curve");
        }
        static async importPrivateKey(O, T, L, J) {
          let W = new sL.PrivateKeyInfo();
          (W.privateKeyAlgorithm.algorithm = "1.2.840.10045.2.1"),
            (W.privateKeyAlgorithm.parameters = ni.serialize(
              new sL.ObjectIdentifier(iN(T.namedCurve))
            )),
            (W.privateKey = ni.serialize(O));
          let Y = new iR();
          return (
            (Y.data = eD.Buffer.from(ni.serialize(W))),
            (Y.algorithm = Object.assign({}, T)),
            (Y.extractable = L),
            (Y.usages = J),
            Y
          );
        }
        static async importPublicKey(O, T, L, J) {
          let W = new sL.PublicKeyInfo();
          W.publicKeyAlgorithm.algorithm = "1.2.840.10045.2.1";
          let Y = iN(T.namedCurve);
          (W.publicKeyAlgorithm.parameters = ni.serialize(
            new sL.ObjectIdentifier(Y)
          )),
            (W.publicKey = O.value);
          let Z = new iI();
          return (
            (Z.data = eD.Buffer.from(ni.serialize(W))),
            (Z.algorithm = Object.assign({}, T)),
            (Z.extractable = L),
            (Z.usages = J),
            Z
          );
        }
        static getOpenSSLNamedCurve(O) {
          switch (O.toUpperCase()) {
            case "P-256":
              return "prime256v1";
            case "K-256":
              return "secp256k1";
            case "P-384":
              return "secp384r1";
            case "P-521":
              return "secp521r1";
            default:
              return O;
          }
        }
      }
      (ij.publicKeyUsages = ["verify"]),
        (ij.privateKeyUsages = ["sign", "deriveKey", "deriveBits"]);
      class iH extends nX {
        constructor() {
          super(...arguments),
            (this.namedCurves = sD.names),
            (this.hashAlgorithms = [
              "SHA-1",
              "SHA-256",
              "SHA-384",
              "SHA-512",
              "shake128",
              "shake256",
              "SHA3-256",
              "SHA3-384",
              "SHA3-512",
            ]);
        }
        async onGenerateKey(O, T, L) {
          let J = await ij.generateKey({ ...O, name: this.name }, T, L);
          return { privateKey: s4(J.privateKey), publicKey: s4(J.publicKey) };
        }
        async onSign(O, T, L) {
          return ij.sign(O, s3(T), new Uint8Array(L));
        }
        async onVerify(O, T, L, J) {
          return ij.verify(O, s3(T), new Uint8Array(L), new Uint8Array(J));
        }
        async onExportKey(O, T) {
          return ij.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await ij.importKey(O, T, { ...L, name: this.name }, J, W));
        }
        checkCryptoKey(O, T) {
          super.checkCryptoKey(O, T);
          let L = s3(O);
          if (!(L instanceof iR || L instanceof iI))
            throw TypeError("key: Is not EC CryptoKey");
        }
      }
      class i$ extends n4 {
        constructor() {
          super(...arguments), (this.namedCurves = sD.names);
        }
        async onGenerateKey(O, T, L) {
          let J = await ij.generateKey({ ...O, name: this.name }, T, L);
          return { privateKey: s4(J.privateKey), publicKey: s4(J.publicKey) };
        }
        async onExportKey(O, T) {
          return ij.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await ij.importKey(O, T, { ...L, name: this.name }, J, W));
        }
        checkCryptoKey(O, T) {
          super.checkCryptoKey(O, T);
          let L = s3(O);
          if (!(L instanceof iR || L instanceof iI))
            throw TypeError("key: Is not EC CryptoKey");
        }
        async onDeriveBits(O, T, L) {
          return await ij.deriveBits({ ...O, public: s3(O.public) }, s3(T), L);
        }
      }
      let iV = {
        [sL.idEd448]: "Ed448",
        ed448: sL.idEd448,
        [sL.idX448]: "X448",
        x448: sL.idX448,
        [sL.idEd25519]: "Ed25519",
        ed25519: sL.idEd25519,
        [sL.idX25519]: "X25519",
        x25519: sL.idX25519,
      };
      function iG(O) {
        let T = iV[O.toLowerCase()];
        if (!T)
          throw new nL(`Cannot convert WebCrypto named curve '${O}' to OID`);
        return T;
      }
      class iJ extends sX {
        constructor() {
          super(...arguments), (this.type = "private");
        }
        getKey() {
          let O = ns.parse(this.data, sL.PrivateKeyInfo);
          return ns.parse(O.privateKey, sL.CurvePrivateKey);
        }
        toJSON() {
          let O = this.getKey();
          return Object.assign(
            {
              kty: "OKP",
              crv: this.algorithm.namedCurve,
              key_ops: this.usages,
              ext: this.extractable,
            },
            nO.toJSON(O)
          );
        }
        fromJSON(O) {
          if (!O.crv)
            throw new nL(
              "Cannot get named curve from JWK. Property 'crv' is required"
            );
          let T = new sL.PrivateKeyInfo();
          T.privateKeyAlgorithm.algorithm = iG(O.crv);
          let L = nT.fromJSON(O, { targetSchema: sL.CurvePrivateKey });
          return (
            (T.privateKey = ni.serialize(L)),
            (this.data = eD.Buffer.from(ni.serialize(T))),
            this
          );
        }
      }
      class iz extends sX {
        constructor() {
          super(...arguments), (this.type = "public");
        }
        getKey() {
          return ns.parse(this.data, sL.PublicKeyInfo).publicKey;
        }
        toJSON() {
          let O = this.getKey();
          return Object.assign(
            {
              kty: "OKP",
              crv: this.algorithm.namedCurve,
              key_ops: this.usages,
              ext: this.extractable,
            },
            { x: e2.ep.ToBase64Url(O) }
          );
        }
        fromJSON(O) {
          if (!O.crv)
            throw new nL(
              "Cannot get named curve from JWK. Property 'crv' is required"
            );
          if (!O.x)
            throw new nL(
              "Cannot get property from JWK. Property 'x' is required"
            );
          let T = new sL.PublicKeyInfo();
          return (
            (T.publicKeyAlgorithm.algorithm = iG(O.crv)),
            (T.publicKey = e2.ep.FromBase64Url(O.x)),
            (this.data = eD.Buffer.from(ni.serialize(T))),
            this
          );
        }
      }
      class iQ {
        static async generateKey(O, T, L) {
          let J = new iJ();
          (J.algorithm = O),
            (J.extractable = T),
            (J.usages = L.filter(
              (O) => -1 !== this.privateKeyUsages.indexOf(O)
            ));
          let W = new iz();
          (W.algorithm = O),
            (W.extractable = !0),
            (W.usages = L.filter(
              (O) => -1 !== this.publicKeyUsages.indexOf(O)
            ));
          let Y = O.namedCurve.toLowerCase(),
            Z = sQ().generateKeyPairSync(Y, {
              publicKeyEncoding: { format: "der", type: "spki" },
              privateKeyEncoding: { format: "der", type: "pkcs8" },
            });
          return (
            (J.data = Z.privateKey),
            (W.data = Z.publicKey),
            { privateKey: J, publicKey: W }
          );
        }
        static async sign(O, T, L) {
          T.pem ||
            (T.pem = `-----BEGIN PRIVATE KEY-----
${T.data.toString("base64")}
-----END PRIVATE KEY-----`);
          let J = { key: T.pem },
            W = sQ().sign(null, eD.Buffer.from(L), J);
          return e2.vJ.toArrayBuffer(W);
        }
        static async verify(O, T, L, J) {
          T.pem ||
            (T.pem = `-----BEGIN PUBLIC KEY-----
${T.data.toString("base64")}
-----END PUBLIC KEY-----`);
          let W = { key: T.pem };
          return sQ().verify(null, eD.Buffer.from(J), W, eD.Buffer.from(L));
        }
        static async deriveBits(O, T, L) {
          let J = sQ().createPublicKey({
              key: O.public.data,
              format: "der",
              type: "spki",
            }),
            W = sQ().createPrivateKey({
              key: T.data,
              format: "der",
              type: "pkcs8",
            }),
            Y = sQ().diffieHellman({ publicKey: J, privateKey: W });
          return new Uint8Array(Y).buffer.slice(0, L >> 3);
        }
        static async exportKey(O, T) {
          switch (O.toLowerCase()) {
            case "jwk":
              return nO.toJSON(T);
            case "pkcs8":
            case "spki":
              return new Uint8Array(T.data).buffer;
            case "raw":
              return ns.parse(T.data, sL.PublicKeyInfo).publicKey;
            default:
              throw new nL("format: Must be 'jwk', 'raw', pkcs8' or 'spki'");
          }
        }
        static async importKey(O, T, L, J, W) {
          switch (O.toLowerCase()) {
            case "jwk": {
              let O = T;
              if (O.d) {
                let O = nT.fromJSON(T, { targetSchema: sL.CurvePrivateKey });
                return this.importPrivateKey(O, L, J, W);
              }
              if (!O.x)
                throw TypeError("keyData: Cannot get required 'x' filed");
              return this.importPublicKey(e2.ep.FromBase64Url(O.x), L, J, W);
            }
            case "raw":
              return this.importPublicKey(T, L, J, W);
            case "spki": {
              let O = ns.parse(new Uint8Array(T), sL.PublicKeyInfo);
              return this.importPublicKey(O.publicKey, L, J, W);
            }
            case "pkcs8": {
              let O = ns.parse(new Uint8Array(T), sL.PrivateKeyInfo),
                Y = ns.parse(O.privateKey, sL.CurvePrivateKey);
              return this.importPrivateKey(Y, L, J, W);
            }
            default:
              throw new nL("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'");
          }
        }
        static importPrivateKey(O, T, L, J) {
          let W = new iJ();
          return (
            W.fromJSON({ crv: T.namedCurve, d: e2.ep.ToBase64Url(O.d) }),
            (W.algorithm = Object.assign({}, T)),
            (W.extractable = L),
            (W.usages = J),
            W
          );
        }
        static async importPublicKey(O, T, L, J) {
          let W = new iz();
          return (
            W.fromJSON({ crv: T.namedCurve, x: e2.ep.ToBase64Url(O) }),
            (W.algorithm = Object.assign({}, T)),
            (W.extractable = L),
            (W.usages = J),
            W
          );
        }
      }
      (iQ.publicKeyUsages = ["verify"]),
        (iQ.privateKeyUsages = ["sign", "deriveKey", "deriveBits"]);
      class iq extends n6 {
        async onGenerateKey(O, T, L) {
          let J = await iQ.generateKey(
            { name: this.name, namedCurve: O.namedCurve.replace(/^ed/i, "Ed") },
            T,
            L
          );
          return { privateKey: s4(J.privateKey), publicKey: s4(J.publicKey) };
        }
        async onSign(O, T, L) {
          return iQ.sign(O, s3(T), new Uint8Array(L));
        }
        async onVerify(O, T, L, J) {
          return iQ.verify(O, s3(T), new Uint8Array(L), new Uint8Array(J));
        }
        async onExportKey(O, T) {
          return iQ.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await iQ.importKey(O, T, { ...L, name: this.name }, J, W));
        }
      }
      class iW extends n8 {
        async onGenerateKey(O, T, L) {
          let J = await iQ.generateKey(
            { name: this.name, namedCurve: O.namedCurve.toUpperCase() },
            T,
            L
          );
          return { privateKey: s4(J.privateKey), publicKey: s4(J.publicKey) };
        }
        async onDeriveBits(O, T, L) {
          return await iQ.deriveBits({ ...O, public: s3(O.public) }, s3(T), L);
        }
        async onExportKey(O, T) {
          return iQ.exportKey(O, s3(T));
        }
        async onImportKey(O, T, L, J, W) {
          return s4(await iQ.importKey(O, T, { ...L, name: this.name }, J, W));
        }
      }
      class iY extends sY {}
      class iZ extends sF {
        async onDeriveBits(O, T, L) {
          return new Promise((J, W) => {
            let Y = e2.vJ.toArrayBuffer(O.salt),
              Z = O.hash.name.replace("-", "");
            sQ().pbkdf2(
              s3(T).data,
              eD.Buffer.from(Y),
              O.iterations,
              L >> 3,
              Z,
              (O, T) => {
                O ? W(O) : J(new Uint8Array(T).buffer);
              }
            );
          });
        }
        async onImportKey(O, T, L, J, W) {
          if ("raw" === O) {
            let O = new iY();
            return (
              (O.data = eD.Buffer.from(T)),
              (O.algorithm = { name: this.name }),
              (O.extractable = !1),
              (O.usages = W),
              s4(O)
            );
          }
          throw new nL("format: Must be 'raw'");
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof iY)))
            throw TypeError("key: Is not PBKDF CryptoKey");
        }
      }
      class iX extends sY {
        get alg() {
          let O = this.algorithm.hash.name.toUpperCase();
          return `HS${O.replace("SHA-", "")}`;
        }
        set alg(O) {}
      }
      (0, no.__decorate)(
        [nR({ name: "k", converter: sW })],
        iX.prototype,
        "data",
        void 0
      );
      class i0 extends s_ {
        async onGenerateKey(O, T, L) {
          let J = ((O.length || this.getDefaultLength(O.hash.name)) >> 3) << 3,
            W = new iX();
          return (
            (W.algorithm = { ...O, length: J, name: this.name }),
            (W.extractable = T),
            (W.usages = L),
            (W.data = sQ().randomBytes(J >> 3)),
            s4(W)
          );
        }
        async onSign(O, T, L) {
          let J = iC.getAlgorithmName(T.algorithm.hash),
            W = sQ()
              .createHmac(J, s3(T).data)
              .update(eD.Buffer.from(L))
              .digest();
          return new Uint8Array(W).buffer;
        }
        async onVerify(O, T, L, J) {
          let W = iC.getAlgorithmName(T.algorithm.hash);
          return (
            0 ===
            sQ()
              .createHmac(W, s3(T).data)
              .update(eD.Buffer.from(J))
              .digest()
              .compare(eD.Buffer.from(L))
          );
        }
        async onImportKey(O, T, L, J, W) {
          let Y;
          switch (O.toLowerCase()) {
            case "jwk":
              Y = nT.fromJSON(T, { targetSchema: iX });
              break;
            case "raw":
              (Y = new iX()).data = eD.Buffer.from(T);
              break;
            default:
              throw new nL("format: Must be 'jwk' or 'raw'");
          }
          return (
            (Y.algorithm = {
              hash: { name: L.hash.name },
              name: this.name,
              length: Y.data.length << 3,
            }),
            (Y.extractable = J),
            (Y.usages = W),
            s4(Y)
          );
        }
        async onExportKey(O, T) {
          switch (O.toLowerCase()) {
            case "jwk":
              return nO.toJSON(s3(T));
            case "raw":
              return new Uint8Array(s3(T).data).buffer;
            default:
              throw new nL("format: Must be 'jwk' or 'raw'");
          }
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof iX)))
            throw TypeError("key: Is not HMAC CryptoKey");
        }
      }
      class i4 extends sY {}
      class i8 extends sK {
        async onImportKey(O, T, L, J, W) {
          if ("raw" !== O.toLowerCase())
            throw new nL("Operation not supported");
          let Y = new i4();
          return (
            (Y.data = eD.Buffer.from(T)),
            (Y.algorithm = { name: this.name }),
            (Y.extractable = J),
            (Y.usages = W),
            s4(Y)
          );
        }
        async onDeriveBits(O, T, L) {
          let J = O.hash.name.replace("-", ""),
            W = sQ().createHash(J).digest().length,
            Y = L / 8,
            Z = e2.vJ.toUint8Array(O.info),
            X = sQ()
              .createHmac(J, e2.vJ.toUint8Array(O.salt))
              .update(e2.vJ.toUint8Array(s3(T).data))
              .digest(),
            ee = [eD.Buffer.alloc(0)],
            et = Math.ceil(Y / W) + 1;
          for (let O = 1; O < et; ++O)
            ee.push(
              sQ()
                .createHmac(J, X)
                .update(eD.Buffer.concat([ee[O - 1], Z, eD.Buffer.from([O])]))
                .digest()
            );
          return eD.Buffer.concat(ee).slice(0, Y);
        }
        checkCryptoKey(O, T) {
          if ((super.checkCryptoKey(O, T), !(s3(O) instanceof i4)))
            throw TypeError("key: Is not HKDF CryptoKey");
        }
      }
      class i6 {
        static digest(O, T) {
          let L = sQ()
            .createHash(O.name.toLowerCase(), { outputLength: O.length })
            .update(eD.Buffer.from(T))
            .digest();
          return new Uint8Array(L).buffer;
        }
      }
      class i5 extends sH {
        async onDigest(O, T) {
          return i6.digest(O, T);
        }
      }
      class i7 extends s$ {
        async onDigest(O, T) {
          return i6.digest(O, T);
        }
      }
      class i9 extends sJ {
        constructor() {
          var O;
          super(),
            this.providers.set(new s8()),
            this.providers.set(new iu()),
            this.providers.set(new ih()),
            this.providers.set(new ic()),
            this.providers.set(new ip()),
            this.providers.set(new ig()),
            sz.getCiphers().includes("des-cbc") && this.providers.set(new ib()),
            this.providers.set(new iA()),
            this.providers.set(new iP()),
            this.providers.set(new ix()),
            this.providers.set(new iB()),
            this.providers.set(new iO()),
            this.providers.set(new iH()),
            this.providers.set(new i$()),
            this.providers.set(new iM()),
            this.providers.set(new iU()),
            this.providers.set(new iL()),
            this.providers.set(new iD()),
            this.providers.set(new iZ()),
            this.providers.set(new i0()),
            this.providers.set(new i8());
          let T =
            null === (O = /^v(\d+)/.exec(sq.version)) || void 0 === O
              ? void 0
              : O[1];
          T &&
            parseInt(T, 10) >= 12 &&
            (this.providers.set(new i5()), this.providers.set(new i7()));
          let L = sz.getHashes();
          L.includes("sha3-256") && this.providers.set(new i_()),
            L.includes("sha3-384") && this.providers.set(new iF()),
            L.includes("sha3-512") && this.providers.set(new iK()),
            T &&
              parseInt(T, 10) >= 14 &&
              (this.providers.set(new iq()), this.providers.set(new iW()));
        }
      }
      class ae extends sV {
        constructor() {
          super(...arguments), (this.subtle = new i9());
        }
        getRandomValues(O) {
          if (!ArrayBuffer.isView(O))
            throw TypeError(
              "Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'"
            );
          let T = eD.Buffer.from(O.buffer, O.byteOffset, O.byteLength);
          return sQ().randomFillSync(T), O;
        }
      }
      var an = 60,
        as = 1296e3,
        aa = 2,
        ao = "~",
        ac = {
          ttl: as,
          cookieOptions: {
            httpOnly: !0,
            secure: !0,
            sameSite: "lax",
            path: "/",
          },
        };
      function au(O, T, L) {
        return async (O, J, W) => {
          if (!O || !J || !W || !W.cookieName || !W.password)
            throw Error(
              'iron-session: Bad usage. Minimum usage is const session = await getIronSession(req, res, { cookieName: "...", password: "...". Check the usage here: https://github.com/vvo/iron-session'
            );
          let Y = ay(W.password);
          Object.values(ay(W.password)).forEach((O) => {
            if (O.length < 32)
              throw Error(
                "iron-session: Bad usage. Password must be at least 32 characters long."
              );
          });
          let Z = {
            ...ac,
            ...W,
            cookieOptions: { ...ac.cookieOptions, ...(W.cookieOptions || {}) },
          };
          0 === Z.ttl && (Z.ttl = 2147483647),
            W.cookieOptions && "maxAge" in W.cookieOptions
              ? void 0 === W.cookieOptions.maxAge
                ? (Z.ttl = 0)
                : (Z.cookieOptions.maxAge = ad(W.cookieOptions.maxAge))
              : (Z.cookieOptions.maxAge = ad(Z.ttl));
          let X = e1.parse(
              "credentials" in O
                ? O.headers.get("cookie") || ""
                : O.headers.cookie || ""
            )[Z.cookieName],
            ee = void 0 === X ? {} : await T(X, { password: Y, ttl: Z.ttl });
          return (
            Object.defineProperties(ee, {
              save: {
                value: async function () {
                  if ("headersSent" in J && !0 === J.headersSent)
                    throw Error(
                      "iron-session: Cannot set session cookie: session.save() was called after headers were sent. Make sure to call it before any res.send() or res.end()"
                    );
                  let O = await L(ee, { password: Y, ttl: Z.ttl }),
                    T = e1.serialize(Z.cookieName, O, Z.cookieOptions);
                  if (T.length > 4096)
                    throw Error(
                      `iron-session: Cookie length is too big ${T.length}, browsers will refuse it. Try to remove some data.`
                    );
                  ah(T, J);
                },
              },
              destroy: {
                value: function () {
                  Object.keys(ee).forEach((O) => {
                    delete ee[O];
                  }),
                    ah(
                      e1.serialize(Z.cookieName, "", {
                        ...Z.cookieOptions,
                        maxAge: 0,
                      }),
                      J
                    );
                },
              },
            }),
            ee
          );
        };
      }
      function ah(O, T) {
        var L;
        if ("headers" in T) {
          T.headers.append("set-cookie", O);
          return;
        }
        let J = null != (L = T.getHeader("set-cookie")) ? L : [];
        "string" == typeof J && (J = [J]), T.setHeader("set-cookie", [...J, O]);
      }
      function ad(O) {
        return O - an;
      }
      function ap(O) {
        return async (T, { password: L, ttl: J = as }) => {
          let W = ay(L),
            { sealWithoutVersion: Y, tokenVersion: Z } = af(T);
          try {
            let T = (await e0(O, Y, W, { ...eF, ttl: 1e3 * J })) || {};
            if (2 === Z) return T;
            return { ...T.persistent };
          } catch (O) {
            if (
              O instanceof Error &&
              ("Expired seal" === O.message ||
                "Bad hmac value" === O.message ||
                O.message.startsWith("Cannot find password: ") ||
                "Incorrect number of sealed components" === O.message)
            )
              return {};
            throw O;
          }
        };
      }
      function af(O) {
        if (O[O.length - 2] === ao) {
          let [T, L] = O.split(ao);
          return { sealWithoutVersion: T, tokenVersion: parseInt(L, 10) };
        }
        return { sealWithoutVersion: O, tokenVersion: null };
      }
      function ag(O) {
        return async (T, { password: L, ttl: J = as }) => {
          let W = ay(L),
            Y = Math.max(...Object.keys(W).map((O) => parseInt(O, 10))),
            Z = { id: Y.toString(), secret: W[Y] },
            X = await eZ(O, T, Z, { ...eF, ttl: 1e3 * J });
          return `${X}${ao}${aa}`;
        };
      }
      function ay(O) {
        return "string" == typeof O ? { 1: O } : O;
      }
      var am = new ae(),
        ab = ap(am),
        aA = ag(am);
      au(am, ab, aA);
      var aw = L(71970);
      L(26182);
      let av = ({
        apiRoutePrefix: O,
        statement: T = "Sign In With Ethereum.",
      }) => ({
        Provider: (L) =>
          (0, eU.jsx)(eL.Og, {
            getNonce: async () => {
              let T = await fetch(`${O}/nonce`);
              if (!T.ok) throw Error("Failed to fetch SIWE nonce");
              return await T.text();
            },
            createMessage: ({ nonce: O, address: L, chainId: J }) =>
              new aw.SiweMessage({
                version: "1",
                domain: window.location.host,
                uri: window.location.origin,
                address: L,
                chainId: J,
                nonce: O,
                statement: T,
              }).prepareMessage(),
            verifyMessage: ({ message: T, signature: L }) =>
              fetch(`${O}/verify`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ message: T, signature: L }),
              }).then((O) => O.ok),
            getSession: async () => {
              let T = await fetch(`${O}/session`);
              if (!T.ok) throw Error("Failed to fetch SIWE session");
              let { address: L, chainId: J } = await T.json();
              return L && J ? { address: L, chainId: J } : null;
            },
            signOut: () => fetch(`${O}/logout`).then((O) => O.ok),
            ...L,
          }),
      });
    },
    51818: function (O, T, L) {
      // "use strict";
      function J(O) {
        return (T) => {
          let L = (O ? Math[O] : Math.trunc)(T);
          return 0 === L ? 0 : L;
        };
      }
      L.d(T, {
        u: function () {
          return J;
        },
      });
    },
    67062: function (O, T, L) {
      // "use strict";
      L.d(T, {
        _: function () {
          return W;
        },
      });
      var J = L(28194);
      function W(O, T) {
        return +(0, J.Q)(O) - +(0, J.Q)(T);
      }
    },
    48255: function (O, T, L) {
      // "use strict";
      L.d(T, {
        c: function () {
          return Y;
        },
      });
      var J = L(51818),
        W = L(67062);
      function Y(O, T, L) {
        let Y = (0, W._)(O, T) / 1e3;
        return (0, J.u)(L?.roundingMethod)(Y);
      }
    },
    28194: function (O, T, L) {
      // "use strict";
      function J(O) {
        let T = Object.prototype.toString.call(O);
        return O instanceof Date ||
          ("object" == typeof O && "[object Date]" === T)
          ? new O.constructor(+O)
          : new Date(
              "number" == typeof O ||
              "[object Number]" === T ||
              "string" == typeof O ||
              "[object String]" === T
                ? O
                : NaN
            );
      }
      L.d(T, {
        Q: function () {
          return J;
        },
      });
    },
    33731: function (O, T, L) {
      // "use strict";
      L.d(T, {
        Z: function () {
          return J;
        },
      });
      let J = (0, L(80189).a)({
        id: 421614,
        name: "Arbitrum Sepolia",
        nativeCurrency: {
          name: "Arbitrum Sepolia Ether",
          symbol: "ETH",
          decimals: 18,
        },
        rpcUrls: {
          default: { http: ["https://sepolia-rollup.arbitrum.io/rpc"] },
        },
        blockExplorers: {
          default: {
            name: "Arbiscan",
            url: "https://sepolia.arbiscan.io",
            apiUrl: "https://sepolia.arbiscan.io/api",
          },
        },
        contracts: {
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 81930,
          },
        },
        testnet: !0,
      });
    },
    23123: function (O, T, L) {
      // "use strict";
      L.d(T, {
        u: function () {
          return Z;
        },
      });
      var J = L(80189),
        W = L(8223);
      let Y = 1,
        Z = (0, J.a)({
          ...W.i,
          id: 8453,
          name: "Base",
          nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
          rpcUrls: { default: { http: ["https://mainnet.base.org"] } },
          blockExplorers: {
            default: {
              name: "Basescan",
              url: "https://basescan.org",
              apiUrl: "https://api.basescan.org/api",
            },
          },
          contracts: {
            ...W.i.contracts,
            l2OutputOracle: {
              [Y]: { address: "0x56315b90c40730925ec5485cf004d835058518A0" },
            },
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 5022,
            },
            portal: {
              [Y]: {
                address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
                blockCreated: 17482143,
              },
            },
            l1StandardBridge: {
              [Y]: {
                address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
                blockCreated: 17482143,
              },
            },
          },
          sourceId: Y,
        });
    },
    18507: function (O, T, L) {
      // "use strict";
      L.d(T, {
        L: function () {
          return Z;
        },
      });
      var J = L(80189),
        W = L(8223);
      let Y = 11155111,
        Z = (0, J.a)({
          ...W.i,
          id: 84532,
          network: "base-sepolia",
          name: "Base Sepolia",
          nativeCurrency: {
            name: "Sepolia Ether",
            symbol: "ETH",
            decimals: 18,
          },
          rpcUrls: { default: { http: ["https://sepolia.base.org"] } },
          blockExplorers: {
            default: {
              name: "Basescan",
              url: "https://sepolia.basescan.org",
              apiUrl: "https://api-sepolia.basescan.org/api",
            },
          },
          contracts: {
            ...W.i.contracts,
            l2OutputOracle: {
              [Y]: { address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254" },
            },
            portal: {
              [Y]: {
                address: "0x49f53e41452c74589e85ca1677426ba426459e85",
                blockCreated: 4446677,
              },
            },
            l1StandardBridge: {
              [Y]: {
                address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
                blockCreated: 4446677,
              },
            },
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 1059647,
            },
          },
          testnet: !0,
          sourceId: Y,
        });
    },
    5781: function (O, T, L) {
      // "use strict";
      L.d(T, {
        A: function () {
          return Y;
        },
      });
      var J = L(80189);
      let W = 1,
        Y = (0, J.a)({
          id: 81457,
          name: "Blast",
          nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
          rpcUrls: { default: { http: ["https://rpc.blast.io"] } },
          blockExplorers: {
            default: { name: "Blastscan", url: "https://blastscan.io" },
          },
          contracts: {
            multicall3: {
              address: "0xcA11bde05977b3631167028862bE2a173976CA11",
              blockCreated: 212929,
            },
          },
          sourceId: W,
        });
    },
    12618: function (O, T, L) {
      // "use strict";
      L.d(T, {
        d: function () {
          return Y;
        },
      });
      var J = L(80189);
      let W = 11155111,
        Y = (0, J.a)({
          id: 168587773,
          name: "Blast Sepolia",
          nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
          rpcUrls: { default: { http: ["https://sepolia.blast.io"] } },
          blockExplorers: {
            default: { name: "Blastscan", url: "https://testnet.blastscan.io" },
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 756690,
            },
          },
          testnet: !0,
          sourceId: W,
        });
    },
    67934: function (O, T, L) {
      // "use strict";
      L.d(T, {
        c: function () {
          return J;
        },
      });
      let J = (0, L(80189).a)({
        id: 31337,
        name: "Hardhat",
        nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
        rpcUrls: { default: { http: ["http://127.0.0.1:8545"] } },
      });
    },
    33999: function (O, T, L) {
      // "use strict";
      L.d(T, {
        d: function () {
          return J;
        },
      });
      let J = (0, L(80189).a)({
        id: 1337,
        name: "Localhost",
        nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
        rpcUrls: { default: { http: ["http://127.0.0.1:8545"] } },
      });
    },
    57214: function (O, T, L) {
      // "use strict";
      L.d(T, {
        F: function () {
          return J;
        },
      });
      let J = (0, L(80189).a)({
        id: 11155111,
        name: "Sepolia",
        nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
        rpcUrls: { default: { http: ["https://rpc.sepolia.org"] } },
        blockExplorers: {
          default: {
            name: "Etherscan",
            url: "https://sepolia.etherscan.io",
            apiUrl: "https://api-sepolia.etherscan.io/api",
          },
        },
        contracts: {
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 751532,
          },
          ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
          },
          ensUniversalResolver: {
            address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
            blockCreated: 5317080,
          },
        },
        testnet: !0,
      });
    },
  },
]);
